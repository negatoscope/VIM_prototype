<!DOCTYPE html>
<html lang="en" id="htmlTag">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VIM Prototype - Final Corrected</title>
    <style>
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; min-height: 100vh; margin: 0; padding: 10px; box-sizing: border-box; background-color: #f4f4f4; }
        .main-container { border: 1px solid #ccc; padding: 20px; text-align: center; background-color: white; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); width: 90%; max-width: 800px; margin-top: 20px; }
        /* This is the new top-level wrapper for our split-screen view */
        /* REPLACEMENT CSS RULES */

        .split-container {
            display: flex;
            flex-direction: row;
            align-items: stretch; /* Make panels equal height */
            justify-content: center;
            gap: 20px;
            width: 100%; /* Use the full browser width */
            height: calc(100vh - 40px); /* Fill the full screen height, minus some padding */
            padding: 20px;
            box-sizing: border-box; /* Include padding in the width/height calculation */
        }

        /* We also need to remove the fixed height from the image panel to let it be flexible */
        /*.image-panel {
            flex: 1; /* This is the key: it will grow to fill all available horizontal space */
            /*display: flex;
            align-items: center;
            justify-content: center;
            background-color: #eee;
            border-radius: 8px;
            /* The explicit height is removed. It will now be controlled by the parent. */
        /*}

        /* This is the new LEFT panel, which will hold the image */
        .image-panel {
            flex: 1; 
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: #eee;
            height: 90vh; /* Increased from 85vh */
            border-radius: 8px;
            /* padding: 10px;  <-- REMOVED to maximize space */
        }

        /* This is the new RIGHT panel, for all our text and buttons */
        .controls-panel {
            /* --- Your existing properties --- */
            flex: 0 0 400px; 
            border: 1px solid #ccc;
            padding: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            height: 85vh; 
            overflow-y: auto; 
            text-align: center;
            
            /* --- The new properties to add --- */
            display: flex;
            flex-direction: column;
        }

        /* This is the generic "spacer" that will push content apart.
        This is the most important missing piece. */
        .flex-spacer {
            flex-grow: 1; /* This makes the element take up all available empty vertical space */
        }

        /* This styles the container for the buttons at the bottom */
        .controls-bottom {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* We need to update the existing .image-display rules to work inside the new panels */
        /*.image-display {
            width: 100%;
            height: 100%; 
            margin-bottom: 0; /* No longer need margin */
        /* }

        .image-display img {
            max-width: 100%;
            max-height: 100%; 
            border: 1px solid black;
            object-fit: contain;
        /*} */

        .confidence-rating {
            margin-top: 20px;
        }

        /* This is the new parent container for the scale and its labels */
        .likert-container {
            display: flex;
            align-items: center; 
            justify-content: center;
            gap: 10px; 
            margin: 15px 0;
            margin-top: 25px; /* Added this line to create more space above */
        }

        /* This is the existing scale, no major changes needed */
        .likert-scale {
            display: flex;
            justify-content: center;
            flex-grow: 1; /* Allow the button container to take up the space */
        }

        .likert-button {
            padding: 10px;
            min-width: 40px; /* Give buttons a consistent width */
            background-color: #f0f0f0;
            color: #333;
            border: 1px solid #ccc;
        }

        .likert-button:hover {
            background-color: #e0e0e0;
        }

        /* Style for the selected confidence button */
        .likert-button.selected {
            background-color: #007bff;
            color: white;
            border-color: #007bff;
        }

        /* ADD THIS NEW CSS RULE */
        .likert-label-end {
            width: 150px; /* Give the labels a fixed width */
            font-size: 13px; /* Slightly smaller to help with fitting */
            color: #666;
        }
        .likert-label-end:first-child {
            text-align: right; /* Align the left label to the right */
        }
        .likert-label-end:last-child {
            text-align: left; /* Align the right label to the left */
        }

        .likert-labels {
            display: flex;
            justify-content: space-between;
            max-width: 350px;
            margin: 0 auto;
            font-size: 14px;
            color: #555;
        }
        /* ADD THESE NEW VVIQ STYLES */

        #vviqScreen {
            text-align: left;
            max-width: 800px;
        }
        #vviqScreen h2 {
            text-align: center;
        }
        .vviq-instructions {
            line-height: 1.6;
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }
        .vviq-rating-scale-table {
            margin: 20px 0;
            width: 100%;
            border-collapse: collapse;
        }
        .vviq-rating-scale-table td, .vviq-rating-scale-table th {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .vviq-item-container {
            margin-top: 25px;
            padding-top: 15px;
            border-top: 1px solid #ddd;
        }
        .vviq-prompt-header {
            font-weight: bold;
            margin-bottom: 15px;
        }
        .vviq-item {
            margin-bottom: 15px;
        }
        .vviq-item-text {
            display: block;
            margin-bottom: 5px;
        }
        .vviq-radio-group label {
            margin-right: 15px;
            cursor: pointer;
        }
        #vviqSubmitBtn {
            display: block;
            margin: 30px auto 10px auto;
            width: 200px;
        }
        .image-display { display: flex; align-items: center; justify-content: center; background-color: #eee; min-height: 30vh; max-height:100%; width: 100%;}
        .image-display img { max-width: 100%; max-height: 100%; border: 1px solid black; object-fit: contain; }
        .slider-value-display {
            display: none;
        }
        .image-display p.preview-instruction { padding: 20px; color: #555; }
        button { margin: 5px; padding: 10px 15px; font-size: 16px; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 4px; }
        button:hover { background-color: #0056b3; }
        .control-group { margin-bottom: 15px; }
        .coarse-selection button { background-color: #6c757d;}
        .coarse-selection button:hover { background-color: #5a6268;}
        .fine-tuning input[type="range"] { width: 80%; max-width: 400px; margin-top: 10px;}
        .hidden { display: none !important; }
        #mainMenu button, #parameterSelector button { margin-bottom:10px; width: 200px;}
        #resultsDisplay ul { list-style-type: none; padding: 0;}
        #resultsDisplay li { margin-bottom: 5px; text-align: left; }
        #resultsDisplay li strong { display: block; margin-top: 10px; }
        .back-button { background-color: #6c757d; margin-top: 20px; }
        .back-button:hover { background-color: #545b62; }
        #fixationScreen, #preVimImageScreenDiv, #holdImageInstructionScreen, #conditionInstructionScreen { 
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            width: 100%; min-height: 60vh; font-size: 18px; line-height: 1.6;
        }
        #conditionInstructionScreen p { max-width: 80%; margin-bottom: 20px; }
        #fixationCross { font-size: 48px; }
        #preVimImageScreenDiv img { 
            max-width: 100%; 
            max-height: 100%; /* Allows image to fill the panel's height */
            border: 1px solid #ddd; 
            object-fit: contain; /* Ensures aspect ratio is maintained */
        }
        .keyboard-focus { outline: 3px solid dodgerblue; box-shadow: 0 0 8px dodgerblue; }
        #paramButtonsContainer { display: flex; flex-direction: column; align-items: center; }
        #paramButtonsContainer button { width: 80%; margin-bottom: 10px; }
        #languageSelector { position: absolute; bottom: 10px; right: 10px; z-index: 100; }
        #languageSelector button { font-size: 14px; padding: 5px 10px; width: auto; background-color: #f8f9fa; color: #333; border: 1px solid #ddd; }
        #languageSelector button.active-lang { background-color: #007bff; color: white; border-color: #007bff;}
        /* --- NEW --- */
        #downloadResultsBtn { background-color: #28a745; margin-top: 20px; }
        #downloadResultsBtn:hover { background-color: #218838; }
        /* ADD THIS NEW RULE */
        #fineTuneActionButtons {
            display: flex;
            flex-direction: row;
            justify-content: center;
        }
    </style>
</head>
<body id="htmlTag" lang="en">

    <div id="languageSelector">
        <button data-lang="en">English</button>
        <button data-lang="es">Español</button>
    </div>

    <div id="mainMenu" class="main-container">
        <h1 data-lang-key="mainMenuTitle"></h1>
        <p data-lang-key="mainMenuWelcome"></p>
        <button id="testParameterBtn" data-lang-key="testParamButton"></button><br>
        <button id="testVVIQBtn">Test VVIQ-2</button><br>
        <button id="startActualTaskBtn" data-lang-key="startTaskButton"></button>
        <p id="setInfo" style="margin-top: 20px; font-size: 12px; color: #888;"></p>
        <!-- ADD THIS NEW BLOCK -->
        <div class="vviq-toggle" style="margin-top: 25px; padding-top: 15px; border-top: 1px solid #eee;">
            <label>
                <input type="checkbox" id="vviqCheckbox">
                <span data-lang-key="vviqCheckboxLabel">Include VVIQ-2 Questionnaire</span>
            </label>
        </div>
    </div>

    <!-- ADD THIS FIRST NEW BLOCK: The Welcome Screen -->
    <div id="welcomeScreen" class="main-container hidden">
        <h1 data-lang-key="welcomeTitle">Welcome!</h1>
        <p data-lang-key="welcomeInstructions"></p>
        <button id="startInstructionsBtn" data-lang-key="continueButton">Continue</button>
    </div>

    <!-- ADD THIS SECOND NEW BLOCK: The How-To Explanation Screen -->
    <div id="howToScreen" class="main-container hidden">
        <h2 data-lang-key="howToTitle">How the Task Works</h2>
        <div style="text-align: left; max-width: 600px; margin: 20px auto;">
            <p data-lang-key="howToStep1"></p>
            <p data-lang-key="howToStep2"></p>
            <p data-lang-key="howToStep3"></p>
        </div>
        <button id="startTutorialBtn" data-lang-key="startPracticeButton">Start Practice Round</button>
    </div>

    <div id="readyScreen" class="main-container hidden">
        <h2 data-lang-key="readyTitle"></h2>
        <p data-lang-key="readyText"></p>
        <button id="startExperimentBtn" data-lang-key="startExperimentButton"></button>
    </div>

    <div id="parameterSelector" class="main-container hidden">
        <h2 data-lang-key="paramSelectorTitle"></h2>
        <div id="paramButtonsContainer"></div>
        <button id="backToMenuFromTestSelectBtn" class="back-button" data-lang-key="backToMenuButton"></button>
    </div>

    <div id="conditionInstructionScreen" class="main-container hidden">
        <h2 id="conditionInstructionTitle"></h2>
        <p id="conditionInstructionText"></p>
        <button id="startTrialFromInstructionsBtn" data-lang-key="trialContinueButton"></button>
    </div>

    <!-- This container now uses the 'split-container' class for the two-panel layout -->
    <div id="preVimScreenContainer" class="split-container hidden">

        <!-- The LEFT panel will hold the visual stimuli (fixation and image) -->
        <div class="image-panel">
            <div id="fixationScreen" class="hidden"><div id="fixationCross">+</div></div>
            <div id="preVimImageScreenDiv" class="hidden"><img id="originalImageDisplay" src="" alt="Original Image"></div>
        </div>

        <!-- The RIGHT panel will hold the text prompt and button -->
        <div class="controls-panel">
            <div id="holdImageInstructionScreen" class="hidden">
                <p id="holdImagePrompt" style="margin-top: 20vh;"></p> <!-- Added style to vertically center the prompt a bit -->
                <button id="holdImageContinueBtn" data-lang-key="trialContinueButton"></button>
            </div>
        </div>

    </div>
    
    <div id="vimTaskInterface" class="split-container hidden">

        <!-- 1. The new LEFT panel for the image -->
        <div class="image-panel">
            
            <!-- MOVE THE COARSE IMAGE DISPLAY HERE -->
            <div class="image-display" id="coarseImageDisplay">
                <p class="preview-instruction" data-lang-key="coarsePreviewText"></p> 
                <img id="coarsePreviewImg" src="" alt="Press Arrow/Hover Mouse">
            </div>

            <!-- MOVE THE FINE-TUNE IMAGE DISPLAY HERE (and hide it) -->
            <div class="image-display hidden" id="fineTuneImageDisplay">
                <img id="fineTuneImg" src="" alt="Fine-tuned image">
            </div>

        </div>

        <!-- 2. The new RIGHT panel for the controls -->
        <div class="controls-panel">
            <!-- TOP SECTION -->
            <h2 id="currentParamDisplay">Parameter: <span></span></h2>
            <p id="vimGeneralInstruction"></p> 

            <!-- ADD THIS FIRST SPACER to push the middle section down -->
            <div class="flex-spacer"></div>

            <!-- MIDDLE SECTION (Interactive Elements) -->
            <div id="coarseStep" class="coarse-selection control-group">
                <p><span data-lang-key="vimCoarsePrompt"></span> <strong id="coarseParamName"></strong>:</p>
                <button data-level-key="low"><span data-lang-key="coarseButtonLow"></span></button>
                <button data-level-key="mid"><span data-lang-key="coarseButtonMid"></span></button>
                <button data-level-key="high"><span data-lang-key="coarseButtonHigh"></span></button>
            </div>

            <div id="fineTuneStep" class="fine-tuning control-group hidden">
                <p><span data-lang-key="fineTunePrompt"></span> <strong id="fineTuneParamName"></strong>:</p>
                <input type="range" id="fineTuneSlider" min="1" max="7" value="4">
                <!-- This is the line you correctly fixed -->
                <p class="slider-value-display"><span id="fineTuneLevelDisplay"></span></p>
                <!-- NOTE: The two buttons that were here have been moved to the bottom -->
            </div>

            <!-- ADD THIS ENTIRE NEW BLOCK -->
            <div id="confidenceStep" class="confidence-rating control-group hidden">
                <p id="confidencePrompt"></p>
                <div class="likert-scale">
                    <button class="likert-button" data-value="1">1</button>
                    <button class="likert-button" data-value="2">2</button>
                    <button class="likert-button" data-value="3">3</button>
                    <button class="likert-button" data-value="4">4</button>
                    <button class="likert-button" data-value="5">5</button>
                    <button class="likert-button" data-value="6">6</button>
                    <button class="likert-button" data-value="7">7</button>
                </div>
                <div class="likert-labels">
                    <span id="likertLabelLow"></span>
                    <span id="likertLabelHigh"></span>
                </div>
            </div>

            <!-- This new spacer element pushes everything below it to the bottom -->
            <div class="flex-spacer"></div>

            <!-- BOTTOM SECTION (Action Buttons) -->
            <div class="controls-bottom">
                <!-- This new wrapper will hold the side-by-side buttons -->
                <div id="fineTuneActionButtons">
                    <button id="backToCoarseBtn" data-lang-key="backToCoarseButton"></button>
                    <button id="confirmSelectionBtn" data-lang-key="confirmLevelButton"></button>
                    <button id="confirmConfidenceBtn" data-lang-key="confirmConfidenceButton" class="hidden"></button>
                </div>
                <button id="backToMenuFromTaskBtn" class="back-button" data-lang-key="exitTaskButton"></button>
            </div>
        </div>

    </div>

    <!-- ADD THIS ENTIRE NEW BLOCK FOR THE VVIQ -->
    <div id="vviqScreen" class="main-container hidden">
        <!-- VVIQ content will be generated by JavaScript here -->
    </div>

    <div id="resultsDisplay" class="main-container hidden">
        <h2 data-lang-key="resultsTitle"></h2>
        <ul id="resultsList"></ul>
        <!-- --- NEW --- -->
        <p id="saveStatus" style="font-style: italic; color: #555;"></p>
        <button id="downloadResultsBtn" data-lang-key="downloadResultsButton">Download Results</button>
        <button id="backToMenuFromResultsBtn" class="back-button hidden" data-lang-key="backToMenuButton"></button>
    </div>

    <!-- UNTIL HERE EVERYTHING WORKS -->

    <script>

        // --- CONFIGURATION AND STATE MANAGEMENT ---
        const DEBUG_SHOW_RESULTS = false; // Set to true to show results for debugging
        
        // REPLACE your existing LANG_STRINGS object

        const LANG_STRINGS = {
            "en": {
                // --- Existing Strings ---
                mainMenuTitle: "Visual Quality Rating Task", mainMenuWelcome: "Welcome! Please read the general instructions before starting.", testParamButton: "Test Single Parameter", startTaskButton: "Start Full Task (12 Trials)", paramSelectorTitle: "Select Parameter to Test", conditionInstructionTitle: "Instructions: {condition} Task", trialContinueButton: "Continue", holdImagePrompt_recall: "Please keep the image you just saw in your mind. Press Continue when ready.", holdImagePrompt_imagine: "Once you have formed a clear mental image of the scene as instructed, press Continue.", vimGeneralInstruction: "Please keep the image of your {sceneType} in your mind.", vimCoarsePrompt: "Select the image that best represents the overall level for", coarseButtonLow: "Low", coarseButtonMid: "Medium", coarseButtonHigh: "High", coarsePreviewText: "Hover over buttons to preview, click to select.", fineTunePrompt: "Now, fine-tune your selection for", selectedLevelLabel: "Selected Level:", backToCoarseButton: "Back to Coarse Selection", confirmLevelButton: "Confirm This Level", backToMenuButton: "Back to Main Menu", exitTaskButton: "Back to Main Menu (Exit Task)", exitConfirmMessage: "Are you sure you want to exit the current task and return to the main menu? Progress will be lost.", resultsTitle: "Trial Results", downloadResultsButton: "Download Results", confidencePrompt: "How confident are you in your selection?", likertLabelLow: "Not at all confident", likertLabelHigh: "Completely confident", confirmConfidenceButton: "Confirm Confidence",
                // --- New Onboarding Strings ---
                welcomeTitle: "Welcome!",
                welcomeInstructions: "Thank you for participating. This experiment investigates the nature of mental imagery. It will take approximately 15-20 minutes. You will first complete a short, interactive practice round, followed by the 12 main trials.",
                continueButton: "Continue",
                howToTitle: "How the Task Works",
                howToStep1: "1. You will be asked to remember or imagine a scene. Please try to form as clear a mental image as you can.",
                howToStep2: "2. You will then adjust an image on the screen to match the qualities of your mental image (e.g., its brightness, blurriness, etc.).",
                howToStep3: "3. After each adjustment, you will rate how confident you are in your choice.",
                startPracticeButton: "Start Practice Round",
                readyTitle: "Practice Complete",
                readyText: "You have completed the practice round. The main experiment will now begin. Remember to take your time and answer as accurately as possible.",
                startExperimentButton: "Start Experiment"
            },
            "es": {
                // --- Existing Strings ---
                mainMenuTitle: "Tarea de Calificación de Calidad Visual", mainMenuWelcome: "¡Bienvenido/a! Por favor, lea las instrucciones generales antes de comenzar.", testParamButton: "Probar un Parámetro", startTaskButton: "Comenzar Tarea Completa (12 Ensayos)", paramSelectorTitle: "Seleccione el Parámetro a Probar", conditionInstructionTitle: "Instrucciones: Tarea de {condition}", trialContinueButton: "Continuar", holdImagePrompt_recall: "Por favor, mantenga la imagen que acaba de ver en su mente. Presione Continuar cuando esté listo/a.", holdImagePrompt_imagine: "Una vez que haya formado una imagen mental clara de la escena como se le indicó, presione Continuar.", vimGeneralInstruction: "Por favor, mantenga la imagen de su {sceneType} en su mente.", vimCoarsePrompt: "Seleccione la imagen que mejor represente el nivel general para", coarseButtonLow: "Bajo", coarseButtonMid: "Medio", coarseButtonHigh: "Alto", coarsePreviewText: "Pase el cursor sobre los botones para previsualizar, haga clic para seleccionar.", fineTunePrompt: "Ahora, ajuste su selección para", selectedLevelLabel: "Nivel Seleccionado:", backToCoarseButton: "Volver a Selección General", confirmLevelButton: "Confirmar este Nivel", backToMenuButton: "Volver al Menú Principal", exitTaskButton: "Volver al Menú Principal (Salir de la Tarea)", exitConfirmMessage: "¿Está seguro/a de que desea salir de la tarea actual y volver al menú principal? El progreso se perderá.", resultsTitle: "Resultados de los Ensayos", downloadResultsButton: "Descargar Resultados", confidencePrompt: "¿Qué tan seguro/a está de su selección?", likertLabelLow: "Nada seguro/a", likertLabelHigh: "Completamente seguro/a", confirmConfidenceButton: "Confirmar Confianza",
                // --- New Onboarding Strings ---
                welcomeTitle: "¡Bienvenido/a!",
                welcomeInstructions: "Gracias por participar. Este experimento investiga la naturaleza de las imágenes mentales. Tomará aproximadamente 15-20 minutos. Primero completará una breve ronda de práctica interactiva, seguida de los 12 ensayos principales.",
                continueButton: "Continuar",
                howToTitle: "Cómo Funciona la Tarea",
                howToStep1: "1. Se le pedirá que recuerde o imagine una escena. Por favor, intente formar la imagen mental más clara posible.",
                howToStep2: "2. Luego, ajustará una imagen en la pantalla para que coincida con las cualidades de su imagen mental (por ejemplo, su brillo, desenfoque, etc.).",
                howToStep3: "3. Después de cada ajuste, calificará qué tan seguro/a está de su elección.",
                startPracticeButton: "Comenzar Ronda de Práctica",
                readyTitle: "Práctica Completada",
                readyText: "Ha completado la ronda de práctica. El experimento principal comenzará ahora. Recuerde tomarse su tiempo y responder con la mayor precisión posible.",
                startExperimentButton: "Comenzar Experimento"
            }
        };

        // REPLACE your existing PARAMETERS object

        const PARAMETERS = {
            saturation:   { name: {en: "Saturation", es: "Saturación"}, levels: 21, coarse: { low: 4, mid: 11, high: 18 }, parameter_specific_instruction: {en: "how colorful or saturated it was.", es: "qué tan colorido o saturado era."}},
            brightness:   { name: {en: "Brightness", es: "Brillo"}, levels: 21, coarse: { low: 4, mid: 11, high: 18 }, parameter_specific_instruction: {en: "how bright or dim it appeared.", es: "qué tan brillante u oscuro parecía."}},
            contrast:     { name: {en: "Contrast", es: "Contraste"}, levels: 21, coarse: { low: 4, mid: 11, high: 18 }, parameter_specific_instruction: {en: "the difference between light and dark areas.", es: "la diferencia entre áreas claras y oscuras."}},
            blurriness:   { name: {en: "Blurriness", es: "Desenfoque"}, levels: 21, coarse: { low: 4, mid: 11, high: 18 }, parameter_specific_instruction: {en: "how sharp or out-of-focus it was.", es: "qué tan nítido o desenfocado estaba."}},
            detailedness: { name: {en: "Detailedness", es: "Nivel de Detalle"}, levels: 21, coarse: { low: 4, mid: 11, high: 18 }, parameter_specific_instruction: {en: "how rich in fine features and textures it was.", es: "qué tan rico en detalles finos y texturas era."}},
            precision:    { name: {en: "Color Precision", es: "Precisión de Color"}, levels: 21, coarse: { low: 4, mid: 11, high: 18 }, parameter_specific_instruction: {en: "how specific or ambiguous the colors were.", es: "qué tan específicos o ambiguos eran los colores."}},
            // --- THIS IS THE NEW ATTENTION CHECK PARAMETER ---
            attention_check: { name: {en: "Attention Check", es: "Prueba de Atención"}, levels: 21, coarse: { low: 4, mid: 11, high: 18 }, 
                parameter_specific_instruction: {
                    en: "For this check, please select the 'Medium' button, then move the slider to level 11.", 
                    es: "Para esta prueba, por favor seleccione el botón 'Medio', y luego mueva el deslizador al nivel 11."
                },
                is_attention_check: true // Flag to identify this special parameter
            }
        };
        
        // ADD THIS NEW DATA OBJECT (replaces the old allTrialsMasterList)

        const IMAGE_DATA = [
            // --- INDOOR IMAGES (6) ---
            { id: 'image01', type: 'indoor', filename: 'image01.png', prompts: {
                episodic_recall:   {en: "Please recall a recent, vivid memory of relaxing in a LIVING ROOM with friends or family present. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria reciente y vívida de estar relajándose en una SALA DE ESTAR con amigos o familiares. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine a quiet, empty LIVING ROOM in the middle of the day, with sunlight coming through a window. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine una SALA DE ESTAR tranquila y vacía a mediodía, con la luz del sol entrando por una ventana. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image03', type: 'indoor', filename: 'image03.png', prompts: {
                episodic_recall:   {en: "Please recall a specific, vivid memory of being in a CLASSROOM, listening to a lesson. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria específica y vívida de estar en un AULA, escuchando una lección. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine an old, empty CLASSROOM after school, with chalk dust on the blackboard. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine un AULA vieja y vacía después de clases, con polvo de tiza en la pizarra. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image04', type: 'indoor', filename: 'image04.png', prompts: {
                episodic_recall:   {en: "Please recall a recent, vivid memory of pushing a shopping cart through a busy SUPERMARKET. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria reciente y vívida de estar empujando un carrito de compras en un SUPERMERCADO concurrido. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine standing in a SUPERMARKET aisle late at night, with almost no one else around. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine que está en el pasillo de un SUPERMERCADO por la noche, casi sin nadie más alrededor. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image08', type: 'indoor', filename: 'image08.png', prompts: {
                episodic_recall:   {en: "Please recall a vivid memory of looking for a specific item in a SUPERMARKET AISLE. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria vívida de estar buscando un artículo específico en un PASILLO DE SUPERMERCADO. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine a brightly lit and perfectly organized SUPERMARKET AISLE that is completely empty. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine un PASILLO DE SUPERMERCADO perfectamente ordenado y muy iluminado, que está completamente vacío. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image09', type: 'indoor', filename: 'image09.png', prompts: {
                episodic_recall:   {en: "Please recall a vivid memory of having a conversation in a comfortable LIVING ROOM. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria vívida de tener una conversación en una SALA DE ESTAR cómoda. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine a minimalist LIVING ROOM with modern furniture and no personal items. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine una SALA DE ESTAR minimalista con muebles modernos y sin objetos personales. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image12', type: 'indoor', filename: 'image12.png', prompts: {
                episodic_recall:   {en: "Please recall a vivid memory of working on a group project with other students in a CLASSROOM. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria vívida de trabajar en un proyecto grupal con otros estudiantes en un AULA. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine the first day of school, in a CLASSROOM filled with students finding their seats. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine el primer día de clases, en un AULA llena de estudiantes buscando sus asientos. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los los ojos y presione Continuar."}
            }},
            // --- OUTDOOR IMAGES (6) ---
            { id: 'image02', type: 'outdoor', filename: 'image02.png', prompts: {
                episodic_recall:   {en: "Please recall a vivid memory of walking down an empty CITY STREET early in the morning. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria vívida de caminar por una CALLE de una CIUDAD vacía temprano en la mañana. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine a wide CITY STREET in a futuristic city, with sleek, silent vehicles. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine una CALLE ancha en una CIUDAD futurista, con vehículos elegantes y silenciosos. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image05', type: 'outdoor', filename: 'image05.png', prompts: {
                episodic_recall:   {en: "Please recall a vivid memory of standing on a BEACH, feeling the spray from the waves. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria vívida de estar en una PLAYA, sintiendo la brisa de las olas. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine a secret BEACH on a tropical island, with a hidden waterfall and no footprints in the sand. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine una PLAYA secreta en una isla tropical, con una cascada escondida y sin huellas en la arena. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image06', type: 'outdoor', filename: 'image06.png', prompts: {
                episodic_recall:   {en: "Please recall a vivid memory of having a picnic or relaxing in a lush, green PARK. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria vívida de tener un picnic o relajarse en un PARQUE verde y frondoso. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine a vast botanical PARK with many strange and colorful exotic plants you've never seen before. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine un vasto PARQUE botánico con muchas plantas exóticas, extrañas y coloridas que nunca ha visto. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image07', type: 'outdoor', filename: 'image07.png', prompts: {
                episodic_recall:   {en: "Please recall a vivid memory of a pleasant walk through a PARK on a cool autumn day. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria vívida de un paseo agradable por un PARQUE en un día fresco de otoño. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine a PARK in the middle of winter, with bare trees and a light dusting of snow on the ground. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine un PARQUE en pleno invierno, con árboles sin hojas y una fina capa de nieve en el suelo. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image10', type: 'outdoor', filename: 'image10.png', prompts: {
                episodic_recall:   {en: "Please recall a vivid memory of being in a crowd on a BUSY CITY STREET. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria vívida de estar entre una multitud en una CALLE CONCURRIDA de una CIUDAD. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine a BUSY CITY STREET during a parade, with confetti in the air and music playing. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine una CALLE CONCURRIDA de una CIUDAD durante un desfile, con confeti en el aire y música sonando. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image11', type: 'outdoor', filename: 'image11.png', prompts: {
                episodic_recall:   {en: "Please recall a vivid memory of playing or building a sandcastle on a sunny BEACH. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria vívida de jugar o construir un castillo de arena en una PLAYA soleada. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine a BEACH at sunset, with the sky full of orange and purple colors. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine una PLAYA al atardecer, con el cielo lleno de colores naranjas y morados. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }}
        ];

        // --- VVIQ-2 Data and Configuration ---

        // Add the new checkbox label to the LANG_STRINGS object
        LANG_STRINGS.en.vviqCheckboxLabel = "Include VVIQ-2 Questionnaire";
        LANG_STRINGS.es.vviqCheckboxLabel = "Incluir Cuestionario VVIQ-2";

        const VVIQ_DATA = {
            instructions: {
                inst_1: {
                    en: "Visual imagery refers to the ability to visualize, that is, the ability to form mental pictures, or to 'see in the mind's eye'. Marked individual differences are found in the strength and clarity of reported visual imagery and these differences are of considerable psychological interest.",
                    es: "La imaginación visual se refiere a la capacidad de visualizar, es decir, la habilidad de formar imágenes mentales o de \"ver con los ojos de la mente\". Existen diferencias individuales marcadas en cuanto a la intensidad y claridad con que las personas experimentan estas imágenes, y dichas diferencias son de gran interés psicológico."
                },
                inst_2: {
                    en: "The aim of this test is to determine the vividness of your visual imagery. The items of the test will possibly bring certain images to your mind. You are asked to rate the vividness of each image by reference to the five-point scale given below. For example, if your image is 'vague and dim', then give it a rating of 2.",
                    es: "El objetivo de este cuestionario es evaluar la viveza de tu imaginación visual. Los ítems del test pueden evocarte ciertas imágenes. Se te pide que califiques la viveza de cada imagen utilizando la escala de cinco puntos que se presenta a continuación. Por ejemplo, si la imagen que formas es \"vaga y borrosa\", asígnale una puntuación de 2."
                },
                inst_3: {
                    en: "Before you turn to the items, familiarize yourself with the different categories on the rating scale. Throughout the test, refer to the rating scale when judging the vividness of each image. Try to do each item separately, independent of how you may have done other items.",
                    es: "Antes de comenzar con los ítems, familiarízate con las categorías de la escala de calificación. A lo largo del cuestionario, consulta esta escala cada vez que evalúes la viveza de una imagen. Intenta responder cada ítem por separado, de forma independiente de cómo hayas respondido los anteriores."
                },
                inst_4: {
                    en: "This test consists of 32 items to be imaged with your eyes closed. When we say \"eyes closed\", we mean the question is read, you close your eyes, an image is formed with them closed, and then open them to write the score. Try to score each item separately and independently of how you scored the other items.",
                    es: "Este test consta de 32 ítems, que deberás imaginar con los ojos cerrados. Cuando decimos \"los ojos cerrados\", significa que debes leer el enunciado, cerrar los ojos, formar la imagen mental con los ojos cerrados, y luego abrirlos para anotar tu puntuación. Intenta calificar cada ítem de forma independiente de los demás."
                }
            },
            scale: [
                { score: 5, en: "Perfectly clear and as vivid as real seeing", es: "Perfectamente clara y tan viva como si estuvieses viendo el objeto" },
                { score: 4, en: "Clear and reasonably vivid", es: "Clara y bastante viva" },
                { score: 3, en: "Moderately clear and vivid", es: "Moderadamente clara y viva" },
                { score: 2, en: "Vague and dim", es: "Vaga y borrosa" },
                { score: 1, en: "No image at all, you only \"know\" that you are thinking of the object", es: "Ninguna imagen, tú sólo \"sabes\" lo que estás pensando del objeto" }
            ],
            prompts: [
                {
                    prompt: { en: "Think of some relative or friend whom you frequently see (but who is not with you at present) and consider carefully the picture that comes before your mind's eye.", es: "Piensa en algún pariente o amigo al que ves frecuentemente (pero que no está contigo ahora). Considera la imagen que te viene a la cabeza." },
                    items: [
                        { en: "The outline of the face, head, shoulders and body.", es: "El contorno de la cara, cabeza, hombros y cuerpo." },
                        { en: "Characteristic posture, gesture, movement, etc.", es: "Las posturas características de la cabeza, ademanes corporales, etc." },
                        { en: "The precise carriage, length of step, etc., in walking.", es: "El modo exacto de andar, la longitud del paso, etc., cuando pasea." },
                        { en: "The different colours worn in clothes.", es: "Los diferentes colores que utiliza en su ropa habitual." }
                    ]
                },
                {
                    prompt: { en: "Visualise a rising sun. Consider the picture that comes before your mind's eye.", es: "Piensa en un sol naciente. Considera la imagen que te viene a la cabeza." },
                    items: [
                        { en: "The sun rising above the horizon into a hazy sky.", es: "El sol está naciendo sobre el horizonte en el cielo nebuloso." },
                        { en: "The sky clears and surrounds the sun with blueness.", es: "El cielo está claro y rodea al sol con su azul." },
                        { en: "Clouds. A storm blows up with flashes of lightning.", es: "Nubes. Una tormenta hace explosión, con destellos de relámpago." },
                        { en: "A rainbow appears.", es: "Aparece un arco iris." }
                    ]
                },
                {
                    prompt: { en: "Think of the front of a shop which you often go to. Consider the picture that comes before your mind's eye.", es: "Piensa en la fachada de la tienda a la que tú vas a menudo. Considera la imagen que te viene a la cabeza." },
                    items: [
                        { en: "The overall appearance of the shop from the opposite side of the road.", es: "El aspecto total de la tienda desde la acera de enfrente." },
                        { en: "A window display including colours, shapes, and details of the items for sale.", es: "Un escaparate, con los colores, formas y detalles de los productos expuestos." },
                        { en: "You are near the entrance. The colour, shape, and details of the door.", es: "Tú estás cerca de la entrada. El color, forma y detalles de la puerta." },
                        { en: "You enter the shop and go to the counter. The assistant serves you.", es: "Tú entras en la tienda y vas al mostrador. El vendedor te sirve." }
                    ]
                },
                {
                    prompt: { en: "Think of a countryside scene which includes trees, mountains, and a lake. Consider the picture that comes before your mind's eye.", es: "Piensa en una escena de campo que tenga árboles, montañas y un lago. Considera la imagen que te viene a la cabeza." },
                    items: [
                        { en: "The contours of the landscape.", es: "Los contornos del paisaje." },
                        { en: "The colour and shape of the trees.", es: "El color y forma de los árboles." },
                        { en: "The colour and shape of the lake.", es: "El color y forma del lago." },
                        { en: "A strong wind blows through the trees and over the lake causing ripples.", es: "Un fuerte viento sopla sobre los árboles y el lago, causando ondulaciones." }
                    ]
                },
                {
                    prompt: { en: "Imagine that a friend or relative is driving you at great speed on a motorway. Consider the picture that comes before your mind's eye.", es: "Piensa que un familiar o amigo te está llevando en coche a gran velocidad por una autopista. Considera la imagen que te viene a la cabeza."},
                    items: [
                        { en: "The overall appearance of fast-moving traffic around your car.", es: "Observa el denso tráfico que circula a gran velocidad alrededor de vuestro coche."},
                        { en: "Your car overtakes and you see worried expressions on other drivers' faces.", es: "Vuestro coche adelanta. Ves preocupación en la cara del conductor y de la gente de otros vehículos."},
                        { en: "A large truck flashes headlights and your car pulls aside.", es: "Un gran camión te da las luces largas. Tu coche se echa a un lado."},
                        { en: "A broken-down car with flashing lights and a woman on the phone.", es: "Un vehículo averiado fuera de la carretera. Conductora preocupada llama por teléfono."}
                    ]
                },
                {
                    prompt: { en: "Visualise a beach on a hot summer day. Consider the picture that comes before your mind's eye.", es: "Piensa en una playa en un caluroso día de verano. Considera la imagen que te viene a la cabeza."},
                    items: [
                        { en: "The appearance and colour of the sea, waves, and sky.", es: "La apariencia global y el color del agua, el reventar de las olas y el cielo."},
                        { en: "Swimmers playing with a brightly coloured beach ball.", es: "Los bañistas nadan y chapotean. Algunos juegan con una pelota de playa de colores brillantes."},
                        { en: "An ocean liner on the horizon trailing smoke.", es: "Un transatlántico cruza el horizonte dejando una estela de humo."},
                        { en: "A colourful hot-air balloon floats overhead and passengers wave.", es: "Un bonito globo hinchable pasa por encima. Los pasajeros saludan."}
                    ]
                },
                {
                    prompt: { en: "Visualise a railway station. Consider the picture that comes before your mind's eye.", es: "Piensa en una estación de tren. Considera la imagen que te viene a la cabeza."},
                    items: [
                        { en: "The overall appearance of the station from the front entrance.", es: "La apariencia general de la estación mirando frente a la entrada principal."},
                        { en: "Walking through the hall: its colour, shape, and details.", es: "Caminas por la estación. Color, forma y detalles del hall de entrada."},
                        { en: "Approaching the ticket counter and buying a ticket.", es: "Te acercas a las taquillas, vas a la ventanilla libre y compras tu billete."},
                        { en: "On the platform: watching passengers and boarding the train.", es: "Caminas por el andén. Observas pasajeros y vías. Llega un tren y te subes."}
                    ]
                },
                {
                    prompt: { en: "Visualise a garden with lawns, trees, flowers, and shrubs. Consider the picture that comes before your mind's eye.", es: "Finalmente, piensa en un jardín con césped, árboles, flores y arbustos. Considera la imagen que te viene a la cabeza."},
                    items: [
                        { en: "The general layout and appearance of the garden.", es: "El aspecto general y la disposición del jardín."},
                        { en: "The colour and shape of trees and bushes.", es: "El color y la forma de los árboles y arbustos."},
                        { en: "The colour and appearance of the flowers.", es: "El color y aspecto de las flores."},
                        { en: "Birds on the lawn pecking for food.", es: "Algunos pájaros se posan en el césped y comienzan a picotear."}
                    ]
                }
            ]
        };

        const GOOGLE_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbwkcpn2kATIjVlfgGAT6um4sN2LOcTU6Qde2vj8mKzd19VtfVxHynh3KR-qMBuNeanSkQ/exec';
        const saveStatus = document.getElementById('saveStatus');

        let currentLanguage = 'en';
        const imageBaseFolder = "images"; 
        const imageExtension = ".png";
        const fineTuneRange = 3; 
        let currentSessionTrials = []; 
        let currentGlobalTrialIndex = 0; 
        let currentTrialData = null;     
        let currentTrialResponses = {};  
        let allCollectedResponses = [];  
        let currentTaskMode = null; 
        // --- NEW ---
        let sessionID = null;
        let currentParameterKey = null;
        let currentParameterConfig = null;
        let actualTaskOrder = []; 
        let currentParameterIndexInTask = 0; 
        let currentFocusableElements = [];
        let currentFocusedIndex = -1;      
        const KEYBOARD_FOCUS_CLASS = 'keyboard-focus';
        const isTouchDevice = (('ontouchstart' in window) || (navigator.maxTouchPoints > 0));

        // --- DOM Elements ---
        const mainMenuDiv = document.getElementById('mainMenu');
        const parameterSelectorDiv = document.getElementById('parameterSelector');
        const paramButtonsContainer = document.getElementById('paramButtonsContainer');
        const vimTaskInterfaceDiv = document.getElementById('vimTaskInterface');
        const resultsDisplayDiv = document.getElementById('resultsDisplay');
        // --- NEW ---
        const downloadResultsBtn = document.getElementById('downloadResultsBtn');
        const conditionInstructionScreenDiv = document.getElementById('conditionInstructionScreen');
        const conditionInstructionTitleH2 = document.getElementById('conditionInstructionTitle');
        const conditionInstructionTextP = document.getElementById('conditionInstructionText');
        const startTrialFromInstructionsBtn = document.getElementById('startTrialFromInstructionsBtn');
        const preVimScreenContainerDiv = document.getElementById('preVimScreenContainer');
        const fixationScreenDiv = document.getElementById('fixationScreen');
        const preVimImageScreenDiv = document.getElementById('preVimImageScreenDiv');
        const originalImageDisplayImg = document.getElementById('originalImageDisplay');
        const holdImageInstructionScreenDiv = document.getElementById('holdImageInstructionScreen');
        const holdImagePromptP = document.getElementById('holdImagePrompt');
        const holdImageContinueBtn = document.getElementById('holdImageContinueBtn');
        const vimGeneralInstructionP = document.getElementById('vimGeneralInstruction');
        const currentParamDisplay = document.getElementById('currentParamDisplay').querySelector('span');
        const coarseStepDiv = document.getElementById('coarseStep');
        const coarseParamNameStrong = document.getElementById('coarseParamName');
        const coarseButtons = coarseStepDiv.querySelectorAll('button');
        const coarsePreviewImg = document.getElementById('coarsePreviewImg');
        const coarseImageDisplayP = document.querySelector('#coarseImageDisplay p.preview-instruction');
        const paramNameInlineSpans = document.querySelectorAll('.param-name-inline');
        const fineTuneStepDiv = document.getElementById('fineTuneStep');
        const fineTuneParamNameStrong = document.getElementById('fineTuneParamName');
        const fineTuneImg = document.getElementById('fineTuneImg');
        const fineTuneSlider = document.getElementById('fineTuneSlider');
        const fineTuneLevelDisplay = document.getElementById('fineTuneLevelDisplay');
        const backToCoarseBtn = document.getElementById('backToCoarseBtn');
        const confirmSelectionBtn = document.getElementById('confirmSelectionBtn');
        const resultsListUl = document.getElementById('resultsList');
        const backToMenuFromTestSelectBtn = document.getElementById('backToMenuFromTestSelectBtn');
        const backToMenuFromTaskBtn = document.getElementById('backToMenuFromTaskBtn');
        const backToMenuFromResultsBtn = document.getElementById('backToMenuFromResultsBtn');

        let currentCoarseSelectionLevel = null;
        let sliderToActualLevelMap = [];

        // ADD these new variable definitions at the top of the script
        const confidenceStepDiv = document.getElementById('confidenceStep');
        const likertButtons = document.querySelectorAll('.likert-button');
        const confirmConfidenceBtn = document.getElementById('confirmConfidenceBtn');
        let currentConfidenceSelection = null;

        const welcomeScreen = document.getElementById('welcomeScreen');
        const howToScreen = document.getElementById('howToScreen');

        // --- Utility Functions ---
        function shuffleArray(array) { 
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        // REPLACE your existing getVariantImagePath function with this one

        function getVariantImagePath(baseImageId, paramKey, level) { 
            // --- THIS IS THE FIX ---
            // If the parameter is an attention check, we need to get an image from a REAL parameter's folder.
            // We can just default to using the 'brightness' folder for this purpose.
            const folderParam = paramKey === 'attention_check' ? 'brightness' : paramKey;

            const levelStr = level < 10 ? '0' + level : level.toString();
            
            // Construct the path using the corrected folder parameter.
            return `${imageBaseFolder}/${folderParam}/${baseImageId}_${folderParam}_${levelStr}${imageExtension}`;
        }

        function getOriginalImagePath(originalFilename) { 
            return `${imageBaseFolder}/originals/${originalFilename}`;
        }
        
        function resetFullTaskState() { 
            currentTrialData = null;
            currentTrialResponses = {};
            currentTaskMode = null;
            // --- MODIFIED ---
            sessionID = null; 
            currentParameterKey = null;
            currentParameterConfig = null;
            actualTaskOrder = [];
            currentParameterIndexInTask = 0;
            currentSessionTrials = [];
            currentGlobalTrialIndex = 0;
            allCollectedResponses = []; 
            console.log("Full task state reset.");
        }

        // ADD THIS NEW HELPER FUNCTION
        function clearAllFocus() {
            // This function finds ANY element that currently has the focus class and removes it.
            const focusedEl = document.querySelector('.' + KEYBOARD_FOCUS_CLASS);
            if (focusedEl) {
                focusedEl.classList.remove(KEYBOARD_FOCUS_CLASS);
            }
            // It also resets the global tracking variables for safety.
            currentFocusableElements = [];
            currentFocusedIndex = -1;
        }

        function updateKeyboardFocus(newIndex) {
            if (currentFocusableElements && currentFocusableElements[currentFocusedIndex]) {
                currentFocusableElements[currentFocusedIndex].classList.remove(KEYBOARD_FOCUS_CLASS);
            }
            currentFocusedIndex = newIndex;
            if (currentFocusableElements && currentFocusableElements[currentFocusedIndex]) {
                currentFocusableElements[currentFocusedIndex].classList.add(KEYBOARD_FOCUS_CLASS);
                currentFocusableElements[currentFocusedIndex].focus(); // Also set browser focus
            }
        }

        function setupMainMenuFocus() {
            currentFocusableElements = [document.getElementById('testParameterBtn'), document.getElementById('startActualTaskBtn')];
            updateKeyboardFocus(0);
        }
        
        function setupParameterSelectorFocus() {
            currentFocusableElements = Array.from(paramButtonsContainer.querySelectorAll('button'));
            updateKeyboardFocus(currentFocusableElements.length > 0 ? 0 : -1);
        }
        
        function setupCoarseStepFocus() {
            currentFocusableElements = Array.from(coarseStepDiv.querySelectorAll('button[data-level-key]'));
            let initialFocus = currentFocusableElements.length > 1 ? 1 : (currentFocusableElements.length === 1 ? 0 : -1);
            updateKeyboardFocus(initialFocus);
            if (initialFocus !== -1 && !isTouchDevice) {
                currentFocusableElements[initialFocus].dispatchEvent(new Event('mouseover'));
            }
        }

        
        // REPLACE your existing showDiv function with this one

        function showDiv(divToShow) { 
            // This list now includes all possible screens that can be shown.
            [mainMenuDiv, welcomeScreen, howToScreen, document.getElementById('readyScreen'),
            parameterSelectorDiv, vimTaskInterfaceDiv, resultsDisplayDiv, 
            preVimScreenContainerDiv, conditionInstructionScreenDiv].forEach(div => {
                if(div) div.classList.add('hidden');
            });

            if (currentFocusableElements && currentFocusableElements[currentFocusedIndex]) {
                currentFocusableElements[currentFocusedIndex].classList.remove(KEYBOARD_FOCUS_CLASS);
            }
            currentFocusableElements = []; currentFocusedIndex = -1;

            if (divToShow) {
                divToShow.classList.remove('hidden');
                if (divToShow === mainMenuDiv) setupMainMenuFocus();
                else if (divToShow === parameterSelectorDiv) setupParameterSelectorFocus();
                else if (divToShow === conditionInstructionScreenDiv) {
                    currentFocusableElements = [startTrialFromInstructionsBtn];
                    updateKeyboardFocus(0);
                } else if (divToShow === vimTaskInterfaceDiv && !coarseStepDiv.classList.contains('hidden')) {
                    setupCoarseStepFocus();
                }
            }
        }
        // --- LANGUAGE SWITCHING ---
        function setLanguage(lang) {
            currentLanguage = lang;
            document.getElementById('htmlTag').lang = lang; 

            document.querySelectorAll('#languageSelector button').forEach(btn => {
                btn.classList.toggle('active-lang', btn.dataset.lang === lang);
            });

            document.querySelectorAll('[data-lang-key]').forEach(el => {
                const key = el.dataset.langKey;
                if (LANG_STRINGS[currentLanguage] && LANG_STRINGS[currentLanguage][key]) {
                    el.textContent = LANG_STRINGS[currentLanguage][key];
                }
            });

            if (!parameterSelectorDiv.classList.contains('hidden')) {
                populateParameterSelector();
            }

            document.getElementById('confidencePrompt').textContent = LANG_STRINGS[lang].confidencePrompt;
            document.getElementById('likertLabelLow').textContent = LANG_STRINGS[lang].likertLabelLow;
            document.getElementById('likertLabelHigh').textContent = LANG_STRINGS[lang].likertLabelHigh;
        }

        // --- Core Application Logic ---

        function showConditionInstructions(trialDataObject) {
            currentTrialData = trialDataObject; 
            if (!currentTrialData) {
                console.error("showConditionInstructions called with invalid trialData!");
                return;
            }

            const conditionName = {
                en: currentTrialData.condition.replace(/_/g, ' '),
                es: currentTrialData.condition === "perceptual_recall" ? "Recuerdo Perceptual" : 
                    currentTrialData.condition === "episodic_recall" ? "Recuerdo Episódico" : "Imaginación de Escena"
            }[currentLanguage];

            let titlePrefix = currentTaskMode === 'test' ? "Test Mode" : `Trial ${currentGlobalTrialIndex + 1} of ${currentSessionTrials.length}`;
            conditionInstructionTitleH2.textContent = `${titlePrefix}: ${conditionName}`;
            conditionInstructionTextP.textContent = currentTrialData.condition_instruction[currentLanguage];
            showDiv(conditionInstructionScreenDiv);
            currentFocusableElements = [startTrialFromInstructionsBtn];
            updateKeyboardFocus(0);
        }

        // REPLACE this event listener
        startTrialFromInstructionsBtn.addEventListener('click', () => {
            if (!currentTrialData) return;
            if (currentTrialData.condition === "perceptual_recall") {
                startPreVimPhase(currentTrialData);
            } else { 
                currentTrialResponses = { 
                    trial_id: currentTrialData.trial_id, condition: currentTrialData.condition,
                    image_id: currentTrialData.base_image_id, parameter_responses: {}
                };
                // It now calls our single, unified function.
                beginVimRating();
            }
        });

        // --- Pre-VIM Task Flow ---
        // REPLACE this function
        function startPreVimPhase(trialData) {
            currentTrialResponses = { 
                trial_id: trialData.trial_id, 
                condition: trialData.condition,
                image_id: trialData.base_image_id, 
                parameter_responses: {}
            };
            
            showDiv(preVimScreenContainerDiv);
            
            fixationScreenDiv.classList.add('hidden');
            preVimImageScreenDiv.classList.add('hidden');
            holdImageInstructionScreenDiv.classList.add('hidden');

            fixationScreenDiv.classList.remove('hidden'); 
            
            setTimeout(() => { 
                fixationScreenDiv.classList.add('hidden');
                preVimImageScreenDiv.classList.remove('hidden');
                originalImageDisplayImg.src = getOriginalImagePath(trialData.original_image_filename);
                
                setTimeout(() => { 
                    preVimImageScreenDiv.classList.add('hidden');
                    originalImageDisplayImg.src = ""; 
                    
                    holdImagePromptP.textContent = LANG_STRINGS[currentLanguage].holdImagePrompt_recall;
                    holdImageInstructionScreenDiv.classList.remove('hidden');
                    
                    currentFocusableElements = [holdImageContinueBtn];
                    updateKeyboardFocus(0);

                }, 1000); // Image display duration: 4 seconds
            }, 2000); // Fixation duration: 1 second
        }

        // REPLACE these two items
        holdImageContinueBtn.addEventListener('click', () => {
            // It now calls our single, unified function.
            beginVimRating();
        });

        // The advanceFromHoldScreen function is no longer needed and can be deleted.

        // --- VIM Parameter Rating Functions ---

        // REPLACE your existing beginVimRating function with this one

        function beginVimRating() {
            if (currentTaskMode === 'tutorial') {
                actualTaskOrder = ['brightness'];
            } else if (currentTaskMode === 'test') {
                actualTaskOrder = [currentParameterKey];
            } else { 
                const realParameters = Object.keys(PARAMETERS).filter(p => p !== 'attention_check');
                let parametersForThisTrial = shuffleArray(realParameters);
                
                // --- THIS IS THE NEW LOGIC ---
                // If the trial is tagged, simply add the attention check as the 7th and final parameter.
                if (currentTrialData.has_attention_check) {
                    parametersForThisTrial.push('attention_check');
                }
                actualTaskOrder = parametersForThisTrial;
            }

            // This part of the logic remains the same
            const sceneTypeKey = currentTrialData.condition === "perceptual_recall" ? "recalled photo" 
                : currentTrialData.condition === "Practice" ? "practice image" 
                : "mental scene";
            const sceneTypeString = {en: sceneTypeKey, es: sceneTypeKey.replace("photo", "foto").replace("image", "imagen").replace("scene", "escena")}[currentLanguage];
            vimGeneralInstructionP.textContent = LANG_STRINGS[currentLanguage].vimGeneralInstruction.replace('{sceneType}', sceneTypeString);
            
            showDiv(vimTaskInterfaceDiv);
            currentParameterIndexInTask = 0;
            loadNextParameterInVim();
        }

        // REPLACE this function
        function loadNextParameterInVim() { 
            if (currentParameterIndexInTask < actualTaskOrder.length) {
                // More parameters to rate for the current trial
                currentParameterKey = actualTaskOrder[currentParameterIndexInTask];
                currentParameterConfig = PARAMETERS[currentParameterKey];
                setupCoarseStepVim(); 
            } else {
                // --- All parameters for the current trial are FINISHED ---
                if (currentTaskMode === 'actual_task_full') {
                    allCollectedResponses.push({...currentTrialResponses}); 
                }
                
                if (currentTaskMode === 'tutorial') {
                    showReadyScreen();
                } else if (currentTaskMode === 'test') {
                    alert(`Test complete for ${PARAMETERS[currentParameterKey].name.en}`);
                    showDiv(parameterSelectorDiv);
                } else {
                    // This was a main trial. Just load the next one.
                    currentGlobalTrialIndex++;
                    if (currentGlobalTrialIndex < currentSessionTrials.length) {
                        showConditionInstructions(currentSessionTrials[currentGlobalTrialIndex]);
                    } else {
                        displayFullResults();
                    }
                }
            }
        }
        
        // REPLACE this function
        // This is your working function with the one necessary line added.
        function setupCoarseStepVim() { 
            clearAllFocus();
            const paramName = currentParameterConfig.name[currentLanguage];
            currentParamDisplay.textContent = paramName;
            coarseParamNameStrong.textContent = currentParameterConfig.parameter_specific_instruction[currentLanguage]; 
            fineTuneParamNameStrong.textContent = currentParameterConfig.parameter_specific_instruction[currentLanguage];
            coarseButtons.forEach(button => {
                const levelKey = button.dataset.levelKey;
                button.dataset.level = currentParameterConfig.coarse[levelKey];
            });

            // Show/hide controls in RIGHT panel
            coarseStepDiv.classList.remove('hidden');
            fineTuneStepDiv.classList.add('hidden');
            confidenceStepDiv.classList.add('hidden'); // Also hide confidence step

            // --- THIS IS THE FIX ---
            // Clear highlighting from BOTH sets of buttons.
            likertButtons.forEach(btn => btn.classList.remove('selected'));
            coarseButtons.forEach(btn => btn.classList.remove('selected')); // THIS IS THE NEW, ADDED LINE

            // Show/hide images in LEFT panel
            document.getElementById('coarseImageDisplay').classList.remove('hidden');
            document.getElementById('fineTuneImageDisplay').classList.add('hidden');

            // Hide ALL action buttons at the bottom initially for the coarse step
            backToCoarseBtn.classList.add('hidden');
            confirmSelectionBtn.classList.add('hidden');
            confirmConfidenceBtn.classList.add('hidden');
            
            // Reset preview
            coarsePreviewImg.src = ""; 
            if (coarseImageDisplayP) coarseImageDisplayP.classList.remove('hidden');
            setupCoarseStepFocus();
        }

        // REPLACE your existing setupFineTuneStepVim function with this one

        function setupFineTuneStepVim(coarseLevelValue) {
            clearAllFocus();
            currentCoarseSelectionLevel = coarseLevelValue;
            fineTuneParamNameStrong.textContent = currentParameterConfig.parameter_specific_instruction[currentLanguage]; 
            const totalParamLevels = currentParameterConfig.levels;
            
            // --- THIS LOGIC IS UNCHANGED ---
            // Determine the min and max levels for the slider range
            let minL, maxL;
            if (coarseLevelValue === PARAMETERS[currentParameterKey].coarse.low) {
                minL = 1;
                maxL = 7;
            } else if (coarseLevelValue === PARAMETERS[currentParameterKey].coarse.mid) {
                minL = 8;
                maxL = 14;
            } else { // High
                minL = 15;
                maxL = 21;
            }
            
            sliderToActualLevelMap = [];
            for (let i = minL; i <= maxL; i++) {
                sliderToActualLevelMap.push(i);
            }

            // --- THIS LOGIC IS NEW (FOR RANDOMIZATION) ---
            // Instead of centering on the coarse value, pick a random starting index for the slider.
            const randomSliderIndex = Math.floor(Math.random() * sliderToActualLevelMap.length); // Get a random index from 0 to length-1
            const initialSliderValue = randomSliderIndex + 1; // Slider values are 1-based

            // --- THIS LOGIC IS NOW UPDATED TO USE THE RANDOM VALUE ---
            fineTuneSlider.min = 1;
            fineTuneSlider.max = sliderToActualLevelMap.length;
            fineTuneSlider.value = initialSliderValue; // Set the slider to the random position

            updateFineTuneImageVim(fineTuneSlider.value);
            
            // --- THIS LOGIC IS UNCHANGED ---
            coarseStepDiv.classList.add('hidden');
            fineTuneStepDiv.classList.remove('hidden');
            document.getElementById('coarseImageDisplay').classList.add('hidden');
            document.getElementById('fineTuneImageDisplay').classList.remove('hidden');
            
            backToCoarseBtn.classList.remove('hidden');
            confirmSelectionBtn.classList.remove('hidden');
            
            fineTuneSlider.focus(); 
            currentFocusableElements = [fineTuneSlider, backToCoarseBtn, confirmSelectionBtn];
            updateKeyboardFocus(0); 
        }

        function updateFineTuneImageVim(sliderValStr) { 
            const sliderValue = parseInt(sliderValStr);
            const actualLevel = sliderToActualLevelMap[sliderValue - 1];
            if (actualLevel !== undefined && currentTrialData && currentParameterKey) { 
                fineTuneImg.src = getVariantImagePath(currentTrialData.base_image_id, currentParameterKey, actualLevel);
                fineTuneLevelDisplay.textContent = actualLevel;
            }
        }
       
        // --- Start/Setup Functions ---
        function populateParameterSelector() { 
            paramButtonsContainer.innerHTML = ''; 
            Object.keys(PARAMETERS).forEach(key => {
                const button = document.createElement('button');
                button.textContent = `${LANG_STRINGS[currentLanguage].testParamButton.split(' ')[0]} ${PARAMETERS[key].name[currentLanguage]}`;
                button.addEventListener('click', () => startParameterTest(key));
                paramButtonsContainer.appendChild(button);
            });
            setupParameterSelectorFocus(); 
        }

        // REPLACE this function
        function startParameterTest(paramKey) {  
            resetFullTaskState(); 
            currentTaskMode = 'test';
            currentParameterKey = paramKey; 
            currentParameterConfig = PARAMETERS[paramKey]; 
            currentTrialData = {
                trial_id: "TestRun",
                condition: "Parameter Test",
                base_image_id: IMAGE_DATA.length > 0 ? IMAGE_DATA[0].id : "image01"
            };
            // It now calls our single, unified function.
            beginVimRating();
        }

        // ADD THESE THREE NEW FUNCTIONS

        // function getUrlParameter(name) {
        //     name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
        //     var regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
        //     var results = regex.exec(location.search);
        //     return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
        // }

        // REPLACE your existing createTrialList function

        function createTrialList(set = 'A') {
            // This function now ONLY creates the 12 main experimental trials.
            const conditions = ["perceptual_recall", "episodic_recall", "scene_imagination"];
            const indoorImages = IMAGE_DATA.filter(img => img.type === 'indoor');
            const outdoorImages = IMAGE_DATA.filter(img => img.type === 'outdoor');
            
            const groupAssignments = {
                'A': [0, 1, 2], 'B': [1, 2, 0], 'C': [2, 0, 1]
            };
            const assignment = groupAssignments[set.toUpperCase()] || groupAssignments['A'];

            let mainTrials = [];
            let trialCounter = 1;

            conditions.forEach((condition, i) => {
                const groupIndex = assignment[i];
                const indoorGroup = indoorImages.slice(groupIndex * 2, groupIndex * 2 + 2);
                const outdoorGroup = outdoorImages.slice(groupIndex * 2, groupIndex * 2 + 2);

                [...indoorGroup, ...outdoorGroup].forEach(img => {
                    let instruction = (condition === 'perceptual_recall')
                        ? { en: "You will be shown an image for a few seconds...", es: "Se le mostrará una imagen por unos segundos..."}
                        : img.prompts[condition];

                    mainTrials.push({
                        trial_id: `main_${trialCounter++}`,
                        is_attention_check: false,
                        condition: condition,
                        base_image_id: img.id,
                        original_image_filename: img.filename,
                        condition_instruction: instruction
                    });
                });
            });
            return mainTrials;
        }

        // ADD THIS ENTIRE NEW BLOCK OF ONBOARDING LOGIC

        // --- Onboarding Flow Control ---

        // When user clicks "Continue" on welcome screen
        document.getElementById('startInstructionsBtn').addEventListener('click', () => {
            showDiv(howToScreen);
        });

        // When user clicks "Start Practice Round"
        document.getElementById('startTutorialBtn').addEventListener('click', () => {
            startTutorial();
        });

        // REPLACE this function
        function startTutorial() {
            currentTaskMode = 'tutorial';
            currentTrialData = {
                trial_id: "TutorialRun",
                condition: "Practice",
                base_image_id: "tutorial" 
            };
            // It now calls our single, unified function.
            beginVimRating();
        }

        // function showReadyScreen() {
        //     // This screen appears after the tutorial is complete
        //     const readyScreen = document.createElement('div');
        //     readyScreen.className = 'main-container';
        //     readyScreen.innerHTML = `
        //         <h2 data-lang-key="readyTitle">${LANG_STRINGS[currentLanguage].readyTitle}</h2>
        //         <p data-lang-key="readyText">${LANG_STRINGS[currentLanguage].readyText}</p>
        //         <button id="startExperimentBtn" data-lang-key="startExperimentButton">${LANG_STRINGS[currentLanguage].startExperimentButton}</button>
        //     `;
            
        //     // Temporarily replace the body content with this screen
        //     document.body.innerHTML = ''; // Clear everything
        //     document.body.appendChild(readyScreen);
            
        //     // The only button on this screen now starts the real task
        //     document.getElementById('startExperimentBtn').addEventListener('click', () => {
        //         // Reload the page to reset all states cleanly, then start the task
        //         // We add a URL parameter to skip the intro on the next load.
        //         window.location.replace(window.location.pathname + '?run=true');
        //     });
        // }

        // ADD THIS ENTIRE FUNCTION BACK INTO YOUR SCRIPT

        function showReadyScreen() {
            // This function now correctly uses the showDiv system.
            const readyScreenDiv = document.getElementById('readyScreen');
            
            // Populate the text content based on the current language
            readyScreenDiv.querySelector('[data-lang-key="readyTitle"]').textContent = LANG_STRINGS[currentLanguage].readyTitle;
            readyScreenDiv.querySelector('[data-lang-key="readyText"]').textContent = LANG_STRINGS[currentLanguage].readyText;
            readyScreenDiv.querySelector('[data-lang-key="startExperimentButton"]').textContent = LANG_STRINGS[currentLanguage].startExperimentButton;

            // Show the screen
            showDiv(readyScreenDiv);
        }
        
        // REPLACE this function
        function startActualTask() {
            resetFullTaskState(); 
            currentTaskMode = 'actual_task_full';
            sessionID = Date.now();
            const set = 'A'; // This can be changed later with getUrlParameter if needed

            // 1. Create the list of 12 main trials
            currentSessionTrials = createTrialList(set);

            // --- NEW ATTENTION CHECK LOGIC ---
            // 2. Randomly select 3 trials to insert an attention check into
            const attentionCheckCount = 3;
            let indices = Array.from(Array(currentSessionTrials.length).keys()); // [0, 1, 2, ..., 11]
            let shuffledIndices = shuffleArray(indices);
            let attentionCheckIndices = shuffledIndices.slice(0, attentionCheckCount); // Pick the first 3
            
            // 3. "Tag" those trials
            attentionCheckIndices.forEach(index => {
                currentSessionTrials[index].has_attention_check = true;
            });
            console.log("Trials with an attention check:", attentionCheckIndices);

            // 4. Shuffle the final list of 12 trials so their order is random
            currentSessionTrials = shuffleArray(currentSessionTrials);

            // Start the experiment
            currentGlobalTrialIndex = 0;
            allCollectedResponses = []; 
            showConditionInstructions(currentSessionTrials[0]);
        }   

        document.getElementById('startExperimentBtn').addEventListener('click', startActualTask);

        // REPLACE your existing displayFullResults function with this one

        // REPLACE this function
        function displayFullResults() {
            // Check if the VVIQ was enabled on the main menu
            if (vviqEnabled) {
                // If yes, start the VVIQ questionnaire
                startVVIQ();
            } else {
                // If no, proceed directly to the final screen and save data
                showDiv(resultsDisplayDiv);
                sendDataToGoogleSheet();
            }

            // --- The old logic for showing results is no longer needed here ---
            // It's either handled by the final screen or done before VVIQ
            if (DEBUG_SHOW_RESULTS) {
                resultsListUl.innerHTML = '';
                allCollectedResponses.forEach(trialResp => {
                    // ... (code to display VIM results for debugging) ...
                });
            } else {
                resultsListUl.style.display = 'none';
                document.querySelector('[data-lang-key="resultsTitle"]').style.display = 'none';
            }
            console.log("VIM Task Complete. All Collected Responses:", JSON.stringify({ sessionID, results: allCollectedResponses }, null, 2));
        }

        // --- NEW ---
        function downloadResults() {
            if (!sessionID || allCollectedResponses.length === 0) {
                alert("No data to download.");
                return;
            }

            // 1. Structure the data with the session ID
            const dataToDownload = {
                sessionID: sessionID,
                results: allCollectedResponses
            };

            // 2. Convert the data object to a JSON string
            const jsonString = JSON.stringify(dataToDownload, null, 2);

            // 3. Create a Blob from the JSON string
            const blob = new Blob([jsonString], { type: "application/json" });

            // 4. Create a temporary URL for the Blob
            const url = URL.createObjectURL(blob);

            // 5. Create a temporary anchor element to trigger the download
            const a = document.createElement('a');
            a.href = url;
            a.download = `VIM_results_session_${sessionID}.json`; // Set the filename
            document.body.appendChild(a); // Append to body to ensure it's clickable
            a.click(); // Programmatically click the link

            // 6. Clean up by removing the temporary anchor and URL
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Add this entire new function to your script

        // REPLACE your existing sendDataToGoogleSheet function with this one:

        async function sendDataToGoogleSheet() {
            if (!sessionID || allCollectedResponses.length === 0) {
                // If there's no data, just show the button immediately.
                backToMenuFromResultsBtn.classList.remove('hidden');
                return; 
            }

            saveStatus.textContent = LANG_STRINGS[currentLanguage].resultsTitle === "Trial Results" ? "Saving data..." : "Guardando datos...";
            
            try {
                const dataToPost = {
                    sessionID: sessionID,
                    results: allCollectedResponses
                };

                await fetch(GOOGLE_SCRIPT_URL, {
                    method: 'POST',
                    mode: 'no-cors',
                    cache: 'no-cache',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    redirect: 'follow',
                    body: JSON.stringify(dataToPost)
                });

                saveStatus.textContent = LANG_STRINGS[currentLanguage].resultsTitle === "Trial Results" ? "Data saved successfully. Thank you!" : "Datos guardados con éxito. ¡Gracias!";
                saveStatus.style.color = 'green';
                console.log("Data submission successful (assumed).");

            } catch (error) {
                saveStatus.textContent = LANG_STRINGS[currentLanguage].resultsTitle === "Trial Results" ? "Error: Could not save data. Please use the download button." : "Error: No se pudieron guardar los datos. Por favor, use el botón de descarga.";
                saveStatus.style.color = 'red';
                console.error("Error sending data to Google Sheet:", error);
            } finally {
                // --- THIS IS THE NEW PART ---
                // This code will run after the 'try' or 'catch' block finishes.
                // It ensures the user always gets a way to leave the screen.
                backToMenuFromResultsBtn.classList.remove('hidden');
            }
        }

        // ADD THIS ENTIRE NEW BLOCK FOR VVIQ LOGIC

        // REPLACE your entire VVIQ JavaScript module with this block

        // --- VVIQ-2 Module (Corrected with Event Delegation) ---

        let vviqEnabled = false;
        const vviqScreen = document.getElementById('vviqScreen');
        let vviqItems = [];
        let vviqCurrentStep = 0;
        let vviqCurrentResponse = null;
        let vviqResponses = [];

        function startVVIQ() {
            vviqCurrentStep = 0;
            vviqItems = createVVIQItems();
            vviqResponses = []; 

            // Generate the static HTML shell for the VVIQ screen
            vviqScreen.innerHTML = generateVVIQ_BaseHTML();

            // Attach ONE smart event listener to the parent container. This is the key.
            vviqScreen.addEventListener('click', handleVVIQ_Clicks);

            // Display the first instruction screen
            displayVVIQStep();
        }

        // The single, smart click handler for the entire VVIQ screen
        function handleVVIQ_Clicks(event) {
            const target = event.target.closest('button'); // Find the button that was clicked
            if (!target || target.disabled) return; // Exit if the click was not on an enabled button

            if (target.id === 'vviqNextBtn') {
                advanceVVIQ();
            } 
            else if (target.id === 'vviqSubmitBtn') {
                collectAndFinishVVIQ();
            }
            else if (target.classList.contains('likert-button')) {
                handleLikertSelection(target);
            }
        }

        function handleLikertSelection(button) {
            vviqCurrentResponse = parseInt(button.dataset.value);
            // Highlight the selected button
            vviqScreen.querySelectorAll('.likert-button').forEach(btn => btn.classList.remove('selected'));
            button.classList.add('selected');
            vviqScreen.querySelector('#vviqNextBtn').disabled = false;
            
            // Update keyboard focus for arrow key navigation
            currentFocusableElements = Array.from(vviqScreen.querySelectorAll('.likert-button'));
            updateKeyboardFocus(currentFocusableElements.indexOf(button));
        }

        function createVVIQItems() {
            const shuffledPrompts = shuffleArray(VVIQ_DATA.prompts);
            const allItems = [];
            let itemCounter = 0;
            shuffledPrompts.forEach(prompt => {
                prompt.items.forEach(item => {
                    allItems.push({ id: ++itemCounter, prompt: prompt.prompt, item: item });
                });
            });
            return allItems;
        }

        // This function now correctly finds elements inside the vviqScreen
        function displayVVIQStep() {
            const lang = currentLanguage;
            const titleEl = vviqScreen.querySelector('#vviqTitle');
            const instructionEl = vviqScreen.querySelector('#vviqInstructionText');
            const scaleTableEl = vviqScreen.querySelector('#vviqScaleTableContainer');
            const itemScreenEl = vviqScreen.querySelector('#vviqItemScreen');
            const nextBtn = vviqScreen.querySelector('#vviqNextBtn');
            
            // Hide all optional components first
            instructionEl.style.display = 'none';
            scaleTableEl.style.display = 'none';
            itemScreenEl.style.display = 'none';
            
            titleEl.textContent = "Vividness of Visual Imagery Questionnaire";
            nextBtn.textContent = LANG_STRINGS[lang].continueButton;
            nextBtn.disabled = false;
            
            if (vviqCurrentStep === 0) {
                instructionEl.style.display = 'block';
                instructionEl.innerHTML = `<p>${VVIQ_DATA.instructions.inst_1[lang]}</p>`;
            } else if (vviqCurrentStep === 1) {
                instructionEl.style.display = 'block';
                scaleTableEl.style.display = 'block';
                instructionEl.innerHTML = `<p>${VVIQ_DATA.instructions.inst_2[lang]}</p><p>${VVIQ_DATA.instructions.inst_3[lang]}</p>`;
                scaleTableEl.innerHTML = generateVVIQScaleTableHTML();
            } else if (vviqCurrentStep === 2) {
                instructionEl.style.display = 'block';
                instructionEl.innerHTML = `<p><strong>${VVIQ_DATA.instructions.inst_4[lang]}</strong></p>`;
                nextBtn.textContent = LANG_STRINGS[lang].startPracticeButton.replace("Practice Round", "Questionnaire");
            } else {
                const itemIndex = vviqCurrentStep - 3;
                displayVVIQItem(vviqItems[itemIndex]);
            }
            showDiv(vviqScreen);
        }

        function displayVVIQItem(itemData) {
            const lang = currentLanguage;
            vviqScreen.querySelector('#vviqTitle').textContent = `Question ${itemData.id} of 32`;
            vviqScreen.querySelector('#vviqItemScreen').style.display = 'block';

            vviqScreen.querySelector('#vviqItemPrompt').textContent = itemData.prompt[lang];
            vviqScreen.querySelector('#vviqItemText').textContent = `${itemData.id}. ${itemData.item[lang]}`;
           // This now targets the new label spans correctly
            vviqScreen.querySelector('#vviqLikertLabelLow').textContent = VVIQ_DATA.scale[4][lang]; // "No image at all..."
            vviqScreen.querySelector('#vviqLikertLabelHigh').textContent = VVIQ_DATA.scale[0][lang]; // "Perfectly clear..."

            const scaleContainer = vviqScreen.querySelector('#vviqLikertScale');
            scaleContainer.innerHTML = ''; 
            VVIQ_DATA.scale.slice().reverse().forEach(scalePoint => {
                const button = document.createElement('button');
                button.className = 'likert-button';
                button.dataset.value = scalePoint.score;
                button.textContent = scalePoint.score;
                scaleContainer.appendChild(button);
            });
            
            vviqCurrentResponse = null;
            vviqScreen.querySelector('#vviqNextBtn').disabled = true;
            vviqScreen.querySelector('#vviqNextBtn').textContent = LANG_STRINGS[lang].confirmConfidenceButton.replace("Confidence", "Rating");

            currentFocusableElements = Array.from(scaleContainer.children);
            updateKeyboardFocus(2);
        }

        function advanceVVIQ() {
            if (vviqCurrentStep >= 3 && vviqCurrentResponse !== null) {
                vviqResponses.push({ id: vviqItems[vviqCurrentStep - 3].id, response: vviqCurrentResponse });
            }
            vviqCurrentStep++;

            if (vviqCurrentStep - 3 < vviqItems.length) {
                displayVVIQStep();
            } else {
                // Finished last item, show the final submit screen
                vviqScreen.querySelector('#vviqItemScreen').style.display = 'none';
                vviqScreen.querySelector('#vviqInstructionText').style.display = 'block';
                vviqScreen.querySelector('#vviqInstructionText').innerHTML = `<p>You have completed the questionnaire. Click Submit to finish the experiment.</p>`;
                vviqScreen.querySelector('#vviqNextBtn').style.display = 'none';
                const submitBtn = vviqScreen.querySelector('#vviqSubmitBtn');
                submitBtn.style.display = 'block';
                submitBtn.textContent = "Submit VVIQ";
                submitBtn.disabled = false;
            }
        }

        function collectAndFinishVVIQ() {
            vviqResponses.sort((a, b) => a.id - b.id);
            const finalScores = vviqResponses.map(r => r.response);
            
            // Create a new property on the global results object to store VVIQ scores
            allCollectedResponses.push({ vviq_scores: finalScores });

            showDiv(resultsDisplayDiv);
            sendDataToGoogleSheet();
        }

        function generateVVIQ_BaseHTML() {
            // This creates the static shell. The text and buttons inside will be managed by other functions.
            return `
                <h2 id="vviqTitle"></h2>
                <div id="vviqInstructionText" class="vviq-instructions"></div>
                <div id="vviqScaleTableContainer"></div>
                <div id="vviqItemScreen" style="display:none;">
                    <p id="vviqItemPrompt" class="vviq-prompt-header"></p>
                    <div class="vviq-item">
                        <span id="vviqItemText" class="vviq-item-text"></span>
                        <!-- This is the new wrapper -->
                        <div class="likert-container">
                            <span id="vviqLikertLabelLow" class="likert-label-end"></span>
                            <div id="vviqLikertScale" class="likert-scale"></div>
                            <span id="vviqLikertLabelHigh" class="likert-label-end"></span>
                        </div>
                    </div>
                </div>
                <button id="vviqNextBtn"></button>
                <button id="vviqSubmitBtn" style="display:none;"></button>
            `;
        }

        function generateVVIQScaleTableHTML() {
            const lang = currentLanguage;
            let table = `<table class="vviq-rating-scale-table"><tr><th>Rating</th><th>Description</th></tr>`;
            VVIQ_DATA.scale.forEach(item => { table += `<tr><td><strong>${item.score}</strong></td><td>${item[lang]}</td></tr>`; });
            return table + `</table>`;
        }

        // --- End VVIQ-2 Module ---

        // --- EVENT LISTENERS ---

        document.getElementById('testVVIQBtn').addEventListener('click', () => {
            // We just need to call the function that starts the VVIQ
            startVVIQ();
        });

        document.getElementById('vviqCheckbox').addEventListener('change', (event) => {
            vviqEnabled = event.target.checked;
        });

        // REPLACE this entire block
        document.addEventListener('DOMContentLoaded', () => {
            resetFullTaskState(); 
            setLanguage('en'); 
            showDiv(mainMenuDiv);
            if(isTouchDevice) document.body.classList.add('touch-device');
        });

        // Language Buttons
        document.querySelectorAll('#languageSelector button').forEach(button => {
            button.addEventListener('click', () => setLanguage(button.dataset.lang));
        });

        // Main Menu Buttons
        document.getElementById('testParameterBtn').addEventListener('click', () => {
            resetFullTaskState(); 
            populateParameterSelector();
            showDiv(parameterSelectorDiv);
        });
        
        document.getElementById('startActualTaskBtn').addEventListener('click', () => {
            // Now, this button simply shows the first welcome screen
            showDiv(welcomeScreen);
        });
        
        // Back Buttons
        backToMenuFromTestSelectBtn.addEventListener('click', () => { resetFullTaskState(); showDiv(mainMenuDiv); });
        backToMenuFromTaskBtn.addEventListener('click', () => {
            let confirmExit = currentTaskMode === 'test' ? true : confirm(LANG_STRINGS[currentLanguage].exitConfirmMessage);
            if (confirmExit) {
                resetFullTaskState();
                showDiv(mainMenuDiv);
            }
        }); 
        backToMenuFromResultsBtn.addEventListener('click', () => { resetFullTaskState(); showDiv(mainMenuDiv); });

        // --- NEW --- Download Button
        downloadResultsBtn.addEventListener('click', downloadResults);

        // REPLACE this entire block to make it more robust

        coarseButtons.forEach(button => {
            button.addEventListener('mouseover', () => {
                if (!currentParameterConfig || coarseStepDiv.classList.contains('hidden') || !currentTrialData) return;
                
                // This is the working preview logic
                const level = parseInt(button.dataset.level);
                coarsePreviewImg.src = getVariantImagePath(currentTrialData.base_image_id, currentParameterKey, level);
                
                // Safety check before using the variable
                if(coarseImageDisplayP) coarseImageDisplayP.classList.add('hidden');
            });
            button.addEventListener('click', () => {
                if (!currentParameterConfig) return;
                setupFineTuneStepVim(parseInt(button.dataset.level)); 
            });
        });
        
        // ... (The rest of the JS code for keyboard handling, etc., remains unchanged) ...
        // REPLACE this event listener block
        document.addEventListener('keydown', (event) => {
            if (document.activeElement.tagName === 'INPUT' && document.activeElement.type !== 'range') return;
            
            if (event.key === "Escape") {
                event.preventDefault();
                const visibleBackButton = document.querySelector('.main-container:not(.hidden) .back-button, .split-container:not(.hidden) .back-button');
                if (visibleBackButton) visibleBackButton.click();
                return;
            }

            // Route to specific handlers based on which screen is active
            if (!welcomeScreen.classList.contains('hidden') && event.key === "Enter") {
                event.preventDefault(); document.getElementById('startInstructionsBtn').click();
            } else if (!howToScreen.classList.contains('hidden') && event.key === "Enter") {
                event.preventDefault(); document.getElementById('startTutorialBtn').click();
            } else if (!document.getElementById('readyScreen').classList.contains('hidden') && event.key === "Enter") {
                event.preventDefault(); document.getElementById('startExperimentBtn').click();
            } else if (!mainMenuDiv.classList.contains('hidden')) {
                handleMainMenuKeys(event);
            } else if (!parameterSelectorDiv.classList.contains('hidden')) {
                handleParameterSelectorKeys(event);
            } else if (!conditionInstructionScreenDiv.classList.contains('hidden') && event.key === "Enter") {
                event.preventDefault(); startTrialFromInstructionsBtn.click();
            } else if (!preVimScreenContainerDiv.classList.contains('hidden') && !holdImageInstructionScreenDiv.classList.contains('hidden') && event.key === "Enter") {
                event.preventDefault(); 
                // It should now call beginVimRating(), just like the mouse click does.
                beginVimRating(); 
            } else if (!vimTaskInterfaceDiv.classList.contains('hidden')) {
                handleVimTaskInterfaceKeys(event);
            }
        });
        
        fineTuneSlider.addEventListener('input', (event) => { 
            if (currentTrialData && currentParameterKey) updateFineTuneImageVim(event.target.value); 
        });

        backToCoarseBtn.addEventListener('click', setupCoarseStepVim); 

        confirmSelectionBtn.addEventListener('click', () => {  
            if (!currentTrialData || !currentParameterKey) {
                console.error("Confirm button clicked with no trial/param context.");
                return;
            }
            // Store the fine-tuned level
            const currentSliderValue = parseInt(fineTuneSlider.value);
            const finalLevel = sliderToActualLevelMap[currentSliderValue - 1];
            
            if (!currentTrialResponses.parameter_responses) {
                currentTrialResponses.parameter_responses = {};
            }
            // We now store the response temporarily in a sub-object
            currentTrialResponses.parameter_responses[currentParameterKey] = {
                level: finalLevel
            };
            
            // Now, transition to the confidence rating step
            showConfidenceStep();
        });

        // ADD this new function to your script

        // REPLACE this function
        function showConfidenceStep() {
            clearAllFocus();
            // Hide the fine-tune UI elements
            fineTuneStepDiv.classList.add('hidden');
            // --- THIS IS THE FIX ---
            // Hide the individual buttons from the previous step
            backToCoarseBtn.classList.add('hidden');
            confirmSelectionBtn.classList.add('hidden');

            // Show the confidence UI elements
            confidenceStepDiv.classList.remove('hidden');
            confirmConfidenceBtn.classList.remove('hidden'); 
            confirmConfidenceBtn.disabled = true; 

            // Reset previous selection
            currentConfidenceSelection = null;
            likertButtons.forEach(btn => btn.classList.remove('selected'));

            // Set up keyboard focus
            currentFocusableElements = Array.from(likertButtons).concat(confirmConfidenceBtn);
            updateKeyboardFocus(3); // Start focus on button '4'
        }

        // ADD this new click handler to your script

        // REPLACE this entire event listener block

        confirmConfidenceBtn.addEventListener('click', () => {
            if (currentConfidenceSelection === null) return;

            // 1. Save the confidence rating to our data object
            if (currentTrialResponses.parameter_responses[currentParameterKey]) {
                currentTrialResponses.parameter_responses[currentParameterKey].confidence = currentConfidenceSelection;
            }

            // 2. Increment the parameter index
            currentParameterIndexInTask++;
            
            // 3. Let the main logic function decide what to do next
            loadNextParameterInVim();
        });

        // ADD this new event listener block for the Likert scale

        likertButtons.forEach(button => {
            button.addEventListener('click', () => {
                // Remove 'selected' from all buttons
                likertButtons.forEach(btn => btn.classList.remove('selected'));
                // Add 'selected' to the clicked button
                button.classList.add('selected');
                // Store the value
                currentConfidenceSelection = parseInt(button.dataset.value);
                // Enable the confirm button
                confirmConfidenceBtn.disabled = false;
                
                // Update keyboard focus to the clicked button
                const buttonIndex = Array.from(likertButtons).indexOf(button);
                if (buttonIndex !== -1) {
                    updateKeyboardFocus(buttonIndex);
                }
            });
        });

        function handleMainMenuKeys(event) {
            if (currentFocusableElements.length === 0) return;
            let handled = false;
            switch (event.key) {
                case "ArrowUp": case "ArrowDown":
                    updateKeyboardFocus(currentFocusedIndex === 0 ? 1 : 0);
                    handled = true;
                    break;
                case "Enter":
                    if (currentFocusedIndex >= 0) currentFocusableElements[currentFocusedIndex].click();
                    handled = true;
                    break;
            }
            if (handled) event.preventDefault();
        }

        function handleParameterSelectorKeys(event) {
            if (currentFocusableElements.length === 0) return;
            let handled = false;
            switch (event.key) {
                case "ArrowUp":
                    updateKeyboardFocus(currentFocusedIndex > 0 ? currentFocusedIndex - 1 : currentFocusableElements.length - 1);
                    handled = true;
                    break;
                case "ArrowDown":
                    updateKeyboardFocus(currentFocusedIndex < currentFocusableElements.length - 1 ? currentFocusedIndex + 1 : 0);
                    handled = true;
                    break;
                case "Enter":
                    if (currentFocusedIndex >= 0) currentFocusableElements[currentFocusedIndex].click();
                    handled = true;
                    break;
                case "Backspace": 
                    backToMenuFromTestSelectBtn.click();
                    handled = true;
                    break;
            }
            if (handled) event.preventDefault();
        }

        // REPLACE the existing handleVimTaskInterfaceKeys function with this one:
        function handleVimTaskInterfaceKeys(event) {
            let handled = false;
            // Logic for Coarse Selection Step
            if (!coarseStepDiv.classList.contains('hidden')) {
                // ... (This part remains exactly the same as your working version) ...
                if (!currentFocusableElements || currentFocusableElements.length === 0) return;
                let newFocusIndex = currentFocusedIndex;
                let arrowPressed = false;
                if (event.key === "ArrowLeft") { newFocusIndex = currentFocusedIndex > 0 ? currentFocusedIndex - 1 : currentFocusableElements.length - 1; arrowPressed = true; handled = true; } 
                else if (event.key === "ArrowRight") { newFocusIndex = currentFocusedIndex < currentFocusableElements.length - 1 ? currentFocusedIndex + 1 : 0; arrowPressed = true; handled = true; }
                if (arrowPressed) {
                    updateKeyboardFocus(newFocusIndex); 
                    const focusedButton = currentFocusableElements[currentFocusedIndex]; 
                    if (focusedButton) {
                        const level = parseInt(focusedButton.dataset.level);
                        if (!isNaN(level) && currentTrialData && currentParameterKey) {
                            coarsePreviewImg.src = getVariantImagePath(currentTrialData.base_image_id, currentParameterKey, level);
                            if (coarseImageDisplayP) coarseImageDisplayP.classList.add('hidden');
                        }
                    }
                } else if (event.key === "Enter") { 
                    if (currentFocusedIndex >= 0 && currentFocusableElements[currentFocusedIndex]) {
                        currentFocusableElements[currentFocusedIndex].click(); 
                        handled = true;
                    }
                }
                if (handled) event.preventDefault();
                return;
            } 
            // Logic for Fine-Tuning Step
            else if (!fineTuneStepDiv.classList.contains('hidden')) {
                // ... (This part remains exactly the same as your working version) ...
                const sliderStep = 1; 
                const sliderIsActiveFocus = document.activeElement === fineTuneSlider;
                switch (event.key) {
                    case "ArrowLeft": if (sliderIsActiveFocus) { fineTuneSlider.value = parseInt(fineTuneSlider.value) - sliderStep; fineTuneSlider.dispatchEvent(new Event('input')); handled = true; } break;
                    case "ArrowRight": if (sliderIsActiveFocus) { fineTuneSlider.value = parseInt(fineTuneSlider.value) + sliderStep; fineTuneSlider.dispatchEvent(new Event('input')); handled = true; } break;
                    case "Enter": confirmSelectionBtn.click(); handled = true; break;
                    case "Backspace": backToCoarseBtn.click(); handled = true; break;
                }
                if (handled) event.preventDefault();
            }
            // --- NEW LOGIC for Confidence Step ---
            else if (!confidenceStepDiv.classList.contains('hidden')) {
                let newFocusIndex = currentFocusedIndex;
                if (event.key === "ArrowLeft") {
                    if (currentFocusedIndex > 0) newFocusIndex = currentFocusedIndex - 1;
                    handled = true;
                } else if (event.key === "ArrowRight") {
                    if (currentFocusedIndex < currentFocusableElements.length - 1) newFocusIndex = currentFocusedIndex + 1;
                    handled = true;
                } else if (event.key === "Enter") {
                    if (currentFocusedIndex >= 0) {
                        currentFocusableElements[currentFocusedIndex].click(); // Select the button
                        if (!confirmConfidenceBtn.disabled) {
                            confirmConfidenceBtn.click(); // If a selection was made, also confirm
                        }
                    }
                    handled = true;
                }
                if (newFocusIndex !== currentFocusedIndex) {
                    updateKeyboardFocus(newFocusIndex);
                }
                if (handled) event.preventDefault();
            }
        }

    </script>
</body>
</html>