<!DOCTYPE html>
<html lang="en" id="htmlTag">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VIM Prototype - Final Corrected</title>
    <style>
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; min-height: 100vh; margin: 0; padding: 10px; box-sizing: border-box; background-color: #f4f4f4; }
        .main-container { border: 1px solid #ccc; padding: 20px; text-align: center; background-color: white; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); width: 90%; max-width: 800px; margin-top: 20px; }
        /* This is the new top-level wrapper for our split-screen view */
        /* REPLACEMENT CSS RULES */

        .split-container {
            display: flex;
            flex-direction: row;
            align-items: stretch; /* Make panels equal height */
            justify-content: center;
            gap: 20px;
            width: 100%; /* Use the full browser width */
            height: calc(100vh - 40px); /* Fill the full screen height, minus some padding */
            padding: 20px;
            box-sizing: border-box; /* Include padding in the width/height calculation */
        }

        /* This is the new LEFT panel, which will hold the image */
        .image-panel {
            flex: 1; 
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: #eee;
            height: 90vh; /* Increased from 85vh */
            border-radius: 8px;
            /* padding: 10px;  <-- REMOVED to maximize space */
        }

        /* This is the new RIGHT panel, for all our text and buttons */
        .controls-panel {
            /* --- Your existing properties --- */
            flex: 0 0 400px; 
            border: 1px solid #ccc;
            padding: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            height: 85vh; 
            overflow-y: auto; 
            text-align: center;
            
            /* --- The new properties to add --- */
            display: flex;
            flex-direction: column;
        }

        /* This is the generic "spacer" that will push content apart.
        This is the most important missing piece. */
        .flex-spacer {
            flex-grow: 1; /* This makes the element take up all available empty vertical space */
        }

        /* This styles the container for the buttons at the bottom */
        .controls-bottom {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .confidence-rating {
            margin-top: 20px;
        }

        /* This is the new parent container for the scale and its labels */
        .likert-container {
            display: flex;
            align-items: center; 
            justify-content: center;
            gap: 10px; 
            margin: 15px 0;
            margin-top: 25px; /* Added this line to create more space above */
        }

        /* This is the existing scale, no major changes needed */
        .likert-scale {
            display: flex;
            justify-content: center;
            flex-grow: 1; /* Allow the button container to take up the space */
        }

        .likert-button {
            padding: 10px;
            min-width: 40px; /* Give buttons a consistent width */
            background-color: #f0f0f0;
            color: #333;
            border: 1px solid #ccc;
        }

        .likert-button:hover {
            background-color: #e0e0e0;
        }

        /* Style for the selected confidence button */
        .likert-button.selected {
            background-color: #007bff;
            color: white;
            border-color: #007bff;
        }

        .likert-label-end {
            width: 150px; /* Give the labels a fixed width */
            font-size: 13px; /* Slightly smaller to help with fitting */
            color: #666;
        }
        .likert-label-end:first-child {
            text-align: right; /* Align the left label to the right */
        }
        .likert-label-end:last-child {
            text-align: left; /* Align the right label to the left */
        }

        .likert-labels {
            display: flex;
            justify-content: space-between;
            max-width: 350px;
            margin: 0 auto;
            font-size: 14px;
            color: #555;
        }
   
        #vviqScreen {
            text-align: left;
            max-width: 800px;
        }
        #vviqScreen h2 {
            text-align: center;
        }
        .vviq-instructions {
            line-height: 1.6;
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }
        .vviq-rating-scale-table {
            margin: 20px 0;
            width: 100%;
            border-collapse: collapse;
        }
        .vviq-rating-scale-table td, .vviq-rating-scale-table th {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .vviq-item-container {
            margin-top: 25px;
            padding-top: 15px;
            border-top: 1px solid #ddd;
        }
        .vviq-prompt-header {
            font-weight: bold;
            margin-bottom: 15px;
        }
        .vviq-item {
            margin-bottom: 15px;
        }
        .vviq-item-text {
            display: block;
            margin-bottom: 5px;
        }
        .vviq-radio-group label {
            margin-right: 15px;
            cursor: pointer;
        }
        #vviqNextBtn, #vviqSubmitBtn {
            display: block;
            margin: 30px auto 10px auto; /* 'auto' on left/right handles the centering */
            width: 200px;
        }
        .image-display { display: flex; align-items: center; justify-content: center; background-color: #eee; min-height: 30vh; max-height:100%; width: 100%;}
        .image-display img { max-width: 100%; max-height: 100%; border: 1px solid black; object-fit: contain; }
        .slider-value-display {
            display: none;
        }
        .image-display p.preview-instruction { padding: 20px; color: #555; }
        button { margin: 5px; padding: 10px 15px; font-size: 16px; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 4px; }
        button:hover { background-color: #0056b3; }
        .control-group { margin-bottom: 15px; }
        .coarse-selection button { background-color: #6c757d;}
        .coarse-selection button:hover { background-color: #5a6268;}
        .fine-tuning input[type="range"] { width: 80%; max-width: 400px; margin-top: 10px;}
        .hidden { display: none !important; }
        #mainMenu button, #parameterSelector button { margin-bottom:10px; width: 200px;}
        #resultsDisplay ul { list-style-type: none; padding: 0;}
        #resultsDisplay li { margin-bottom: 5px; text-align: left; }
        #resultsDisplay li strong { display: block; margin-top: 10px; }
        .back-button { background-color: #6c757d; margin-top: 20px; }
        .back-button:hover { background-color: #545b62; }
        #fixationScreen, #preVimImageScreenDiv, #holdImageInstructionScreen, #conditionInstructionScreen { 
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            width: 100%; min-height: 60vh; font-size: 18px; line-height: 1.6;
        }
        #conditionInstructionScreen p { max-width: 80%; margin-bottom: 20px; }
        #fixationCross { font-size: 48px; }
        #preVimImageScreenDiv img { 
            max-width: 100%; 
            max-height: 100%; /* Allows image to fill the panel's height */
            border: 1px solid #ddd; 
            object-fit: contain; /* Ensures aspect ratio is maintained */
        }
        .keyboard-focus { outline: 3px solid dodgerblue; box-shadow: 0 0 8px dodgerblue; }
        #paramButtonsContainer { display: flex; flex-direction: column; align-items: center; }
        #paramButtonsContainer button { width: 80%; margin-bottom: 10px; }
        #languageSelector { position: absolute; bottom: 10px; right: 10px; z-index: 100; }
        #languageSelector button { font-size: 14px; padding: 5px 10px; width: auto; background-color: #f8f9fa; color: #333; border: 1px solid #ddd; }
        #languageSelector button.active-lang { background-color: #007bff; color: white; border-color: #007bff;}
        #downloadResultsBtn { background-color: #28a745; margin-top: 20px; }
        #downloadResultsBtn:hover { background-color: #218838; }
        #fineTuneActionButtons {
            display: flex;
            flex-direction: row;
            justify-content: center;
        }
        #loadingOverlay {
            position: fixed; /* Sit on top of everything */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent black background */
            z-index: 200; /* High z-index to be on top */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .loading-box {
            background-color: white;
            padding: 30px 40px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
        }

        #loadingText {
            margin: 0 0 15px 0;
            font-size: 18px;
        }

        .progress-bar-container {
            width: 300px;
            height: 20px;
            background-color: #e0e0e0;
            border: 1px solid #ccc;
            border-radius: 10px;
            overflow: hidden; /* Keep the progress bar contained */
        }

        #progressBar {
            width: 0%; /* Start at 0% width */
            height: 100%;
            background-color: #007bff;
            transition: width 0.2s ease-in-out; /* Smooth animation for the bar */
        }
        
        #globalProgressContainer {
            position: fixed; /* Stick to the top of the viewport */
            top: 0;
            left: 0;
            width: 100%;
            height: 8px; /* A thin bar */
            background-color: #e9ecef; /* A light background color */
            z-index: 999; /* High z-index to be on top of most things */
        }

        #globalProgressBar {
            height: 100%;
            width: 0%; /* Start at 0% */
            background-color: #007bff; /* The same blue as your buttons */
            transition: width 0.3s ease; /* Smooth animation */
        }

        .back-button {
            display: none !important; /* Hide by default, !important to override other styles */
        }

        #parameterSelector .back-button {
            display: inline-block !important; /* Re-show the button only on this screen */
        }

        .no-info-button {
            background-color: #333; /* A different color */
            border: 1px solid #555;
            width: 250px; /* Make it wider to fit the text */
            margin-bottom: 15px;
        }
        .no-info-button:hover {
            background-color: #555;
        }
    </style>
</head>
<body id="htmlTag" lang="en">

    <div id="globalProgressContainer" class="hidden">
        <div id="globalProgressBar"></div>
    </div>

    <div id="languageSelector">
        <button data-lang="en">English</button>
        <button data-lang="es">Español</button>
    </div>

    <div id="mainMenu" class="main-container">
        <h1 data-lang-key="mainMenuTitle"></h1>
        <p data-lang-key="mainMenuWelcome"></p>
        <button id="testParameterBtn" data-lang-key="testParamButton"></button><br>
        <button id="testVVIQBtn">Test VVIQ-2</button><br>
        <button id="startActualTaskBtn" data-lang-key="startTaskButton"></button>
        <p id="setInfo" style="margin-top: 20px; font-size: 12px; color: #888;"></p>
        <div class="vviq-toggle" style="margin-top: 25px; padding-top: 15px; border-top: 1px solid #eee;">
            <label>
                <input type="checkbox" id="vviqCheckbox" checked>
                <span data-lang-key="vviqCheckboxLabel">Include VVIQ-2 Questionnaire</span>
            </label>
        </div>
    </div>

    <!-- The Welcome Screen -->
    <div id="welcomeScreen" class="main-container hidden">
        <h1 data-lang-key="welcomeTitle">Welcome!</h1>
        <p data-lang-key="welcomeInstructions"></p>
        <button id="startInstructionsBtn" data-lang-key="continueButton">Continue</button>
    </div>

    <!-- The How-To Explanation Screen -->
    <div id="howToScreen" class="main-container hidden">
        <h2 data-lang-key="howToTitle">How the Task Works</h2>
        <div style="text-align: left; max-width: 600px; margin: 20px auto;">
            <p data-lang-key="howToStep1"></p>
            <p data-lang-key="howToStep2"></p>
            <p data-lang-key="howToStep3"></p>
        </div>
        <button id="startTutorialBtn" data-lang-key="startPracticeButton">Start Practice Round</button>
    </div>

    <div id="readyScreen" class="main-container hidden">
        <h2 data-lang-key="readyTitle"></h2>
        <p data-lang-key="readyText"></p>
        <button id="startExperimentBtn" data-lang-key="startExperimentButton"></button>
    </div>

    <div id="parameterSelector" class="main-container hidden">
        <h2 data-lang-key="paramSelectorTitle"></h2>
        <div id="paramButtonsContainer"></div>
        <button id="backToMenuFromTestSelectBtn" class="back-button" data-lang-key="backToMenuButton"></button>
    </div>

    <div id="conditionInstructionScreen" class="main-container hidden">
        <h2 id="conditionInstructionTitle"></h2>
        <p id="conditionInstructionText"></p>
        <button id="startTrialFromInstructionsBtn" data-lang-key="trialContinueButton"></button>
    </div>

    <!-- This container now uses the 'split-container' class for the two-panel layout -->
    <div id="preVimScreenContainer" class="split-container hidden">

        <!-- The LEFT panel will hold the visual stimuli (fixation and image) -->
        <div class="image-panel">
            <div id="fixationScreen" class="hidden"><div id="fixationCross">+</div></div>
            <div id="preVimImageScreenDiv" class="hidden"><img id="originalImageDisplay" src="" alt="Original Image"></div>
        </div>

        <!-- The RIGHT panel will hold the text prompt and button -->
        <div class="controls-panel">
            <div id="holdImageInstructionScreen" class="hidden">
                <p id="holdImagePrompt" style="margin-top: 20vh;"></p> <!-- Added style to vertically center the prompt a bit -->
                <button id="holdImageContinueBtn" data-lang-key="trialContinueButton"></button>
            </div>
        </div>

    </div>
    
    <div id="vimTaskInterface" class="split-container hidden">

        <!-- 1. The new LEFT panel for the image -->
        <div class="image-panel">
            
            <!-- MOVE THE COARSE IMAGE DISPLAY HERE -->
            <div class="image-display" id="coarseImageDisplay">
                <p class="preview-instruction" data-lang-key="coarsePreviewText"></p> 
                <img id="coarsePreviewImg" src="" alt="Press Arrow/Hover Mouse">
            </div>

            <!-- MOVE THE FINE-TUNE IMAGE DISPLAY HERE (and hide it) -->
            <div class="image-display hidden" id="fineTuneImageDisplay">
                <img id="fineTuneImg" src="" alt="Fine-tuned image">
            </div>

        </div>

        <!-- 2. The new RIGHT panel for the controls -->
        <div class="controls-panel">
            <!-- TOP SECTION -->
            <h2 id="currentParamDisplay">Parameter: <span></span></h2>
            <p id="vimGeneralInstruction"></p> 

            <!-- ADD THIS FIRST SPACER to push the middle section down -->
            <div class="flex-spacer"></div>

            <!-- MIDDLE SECTION (Interactive Elements) -->
            <div id="coarseStep" class="coarse-selection control-group">
                <p><span data-lang-key="vimCoarsePrompt"></span> <strong id="coarseParamName"></strong>:</p>
                
                <button data-level-key="low"><span data-lang-key="coarseButtonLow"></span></button>
                <button data-level-key="mid"><span data-lang-key="coarseButtonMid"></span></button>
                <button data-level-key="high"><span data-lang-key="coarseButtonHigh"></span></button>

                <button id="noInfoBtn" class="no-info-button" data-lang-key="noInfoLabel"></button>

            </div>

            <div id="fineTuneStep" class="fine-tuning control-group hidden">
                <p><span data-lang-key="fineTunePrompt"></span> <strong id="fineTuneParamName"></strong>:</p>
                <input type="range" id="fineTuneSlider" min="1" max="7" value="4">
                <!-- This is the line you correctly fixed -->
                <p class="slider-value-display"><span id="fineTuneLevelDisplay"></span></p>
                <!-- NOTE: The two buttons that were here have been moved to the bottom -->
            </div>

            <div id="confidenceStep" class="confidence-rating control-group hidden">
                <p id="confidencePrompt"></p>
                <div class="likert-scale">
                    <button class="likert-button" data-value="1">1</button>
                    <button class="likert-button" data-value="2">2</button>
                    <button class="likert-button" data-value="3">3</button>
                    <button class="likert-button" data-value="4">4</button>
                    <button class="likert-button" data-value="5">5</button>
                    <button class="likert-button" data-value="6">6</button>
                    <button class="likert-button" data-value="7">7</button>
                </div>
                <div class="likert-labels">
                    <span id="likertLabelLow"></span>
                    <span id="likertLabelHigh"></span>
                </div>
            </div>

            <!-- This new spacer element pushes everything below it to the bottom -->
            <div class="flex-spacer"></div>

            <!-- BOTTOM SECTION (Action Buttons) -->
            <div class="controls-bottom">
                <!-- This new wrapper will hold the side-by-side buttons -->
                <div id="fineTuneActionButtons">
                    <button id="backToCoarseBtn" data-lang-key="backToCoarseButton"></button>
                    <button id="confirmSelectionBtn" data-lang-key="confirmLevelButton"></button>
                    <button id="confirmNoInfoBtn" class="hidden" data-lang-key="continueButton"></button>
                    <button id="confirmConfidenceBtn" data-lang-key="confirmConfidenceButton" class="hidden"></button>
                </div>
                <button id="backToMenuFromTaskBtn" class="back-button" data-lang-key="exitTaskButton"></button>
            </div>
        </div>

    </div>

    <!-- ADD THIS ENTIRE NEW BLOCK FOR THE VVIQ -->
    <div id="vviqScreen" class="main-container hidden">
        <!-- VVIQ content will be generated by JavaScript here -->
    </div>

    <div id="resultsDisplay" class="main-container hidden">
        <h2 data-lang-key="resultsTitle"></h2>
        <ul id="resultsList"></ul>
        <!-- --- NEW --- -->
        <p id="saveStatus" style="font-style: italic; color: #555;"></p>
        <button id="downloadResultsBtn" data-lang-key="downloadResultsButton">Download Results</button>
        <button id="backToMenuFromResultsBtn" class="back-button hidden" data-lang-key="backToMenuButton"></button>
    </div>

    <div id="loadingOverlay" class="hidden">
        <div class="loading-box">
            <p id="loadingText">Loading trial...</p>
            <div class="progress-bar-container">
                <div id="progressBar" style="width: 0%;"></div>
            </div>
        </div>
    </div>

    <script>

        // --- CONFIGURATION AND STATE MANAGEMENT ---
        const DEBUG_SHOW_RESULTS = false; // Set to true to show results for debugging
        const loadingOverlay = document.getElementById('loadingOverlay');
        const progressBar = document.getElementById('progressBar');
        const loadingText = document.getElementById('loadingText');
        
        const LANG_STRINGS = {
            "en": {
                // --- Existing Strings ---
                mainMenuTitle: "Visual Quality Rating Task", mainMenuWelcome: "Welcome! Please read the general instructions before starting.", testParamButton: "Test Single Parameter", startTaskButton: "Start Full Task (12 Trials)", paramSelectorTitle: "Select Parameter to Test", conditionInstructionTitle: "Instructions: {condition} Task", trialContinueButton: "Continue", holdImagePrompt_recall: "Please keep the image you just saw in your mind. Press Continue when ready.", holdImagePrompt_imagine: "Once you have formed a clear mental image of the scene as instructed, press Continue.", vimGeneralInstruction: "Please keep the image of your {sceneType} in your mind.", vimCoarsePrompt: "Select the image that best represents the overall level for", coarseButtonLow: "Low", coarseButtonMid: "Medium", coarseButtonHigh: "High", coarsePreviewText: "Hover over buttons to preview, click to select.", fineTunePrompt: "Now, fine-tune your selection for", selectedLevelLabel: "Selected Level:", backToCoarseButton: "Back to Coarse Selection", confirmLevelButton: "Confirm This Level", backToMenuButton: "Back to Main Menu", exitTaskButton: "Back to Main Menu (Exit Task)", exitConfirmMessage: "Are you sure you want to exit the current task and return to the main menu? Progress will be lost.", resultsTitle: "Trial Results", downloadResultsButton: "Download Results", confidencePrompt: "How confident are you in your selection?", likertLabelLow: "Not at all confident", likertLabelHigh: "Completely confident", confirmConfidenceButton: "Confirm Confidence",
                // --- New Onboarding Strings ---
                welcomeTitle: "Welcome!",
                welcomeInstructions: "Thank you for participating. This experiment investigates the nature of mental imagery. It will take approximately 15-20 minutes. You will first complete a short, interactive practice round, followed by the 12 main trials.",
                continueButton: "Continue",
                howToTitle: "How the Task Works",
                howToStep1: "1. You will be asked to remember or imagine a scene. Please try to form as clear a mental image as you can.",
                howToStep2: "2. You will then adjust an image on the screen to match the qualities of your mental image (e.g., its brightness, blurriness, etc.).",
                howToStep3: "3. After each adjustment, you will rate how confident you are in your choice.",
                startPracticeButton: "Start Practice Round",
                readyTitle: "Practice Complete",
                readyText: "You have completed the practice round. The main experiment will now begin. Remember to take your time and answer as accurately as possible.",
                startExperimentButton: "Start Experiment",
                noInfoLabel: "I have no clear impression of this quality."
            },
            "es": {
                // --- Existing Strings ---
                mainMenuTitle: "Tarea de Calificación de Calidad Visual", mainMenuWelcome: "¡Bienvenido/a! Por favor, lea las instrucciones generales antes de comenzar.", testParamButton: "Probar un Parámetro", startTaskButton: "Comenzar Tarea Completa (12 Ensayos)", paramSelectorTitle: "Seleccione el Parámetro a Probar", conditionInstructionTitle: "Instrucciones: Tarea de {condition}", trialContinueButton: "Continuar", holdImagePrompt_recall: "Por favor, mantenga la imagen que acaba de ver en su mente. Presione Continuar cuando esté listo/a.", holdImagePrompt_imagine: "Una vez que haya formado una imagen mental clara de la escena como se le indicó, presione Continuar.", vimGeneralInstruction: "Por favor, mantenga la imagen de su {sceneType} en su mente.", vimCoarsePrompt: "Seleccione la imagen que mejor represente el nivel general para", coarseButtonLow: "Bajo", coarseButtonMid: "Medio", coarseButtonHigh: "Alto", coarsePreviewText: "Pase el cursor sobre los botones para previsualizar, haga clic para seleccionar.", fineTunePrompt: "Ahora, ajuste su selección para", selectedLevelLabel: "Nivel Seleccionado:", backToCoarseButton: "Volver a Selección General", confirmLevelButton: "Confirmar este Nivel", backToMenuButton: "Volver al Menú Principal", exitTaskButton: "Volver al Menú Principal (Salir de la Tarea)", exitConfirmMessage: "¿Está seguro/a de que desea salir de la tarea actual y volver al menú principal? El progreso se perderá.", resultsTitle: "Resultados de los Ensayos", downloadResultsButton: "Descargar Resultados", confidencePrompt: "¿Qué tan seguro/a está de su selección?", likertLabelLow: "Nada seguro/a", likertLabelHigh: "Completamente seguro/a", confirmConfidenceButton: "Confirmar Confianza",
                // --- New Onboarding Strings ---
                welcomeTitle: "¡Bienvenido/a!",
                welcomeInstructions: "Gracias por participar. Este experimento investiga la naturaleza de las imágenes mentales. Tomará aproximadamente 15-20 minutos. Primero completará una breve ronda de práctica interactiva, seguida de los 12 ensayos principales.",
                continueButton: "Continuar",
                howToTitle: "Cómo Funciona la Tarea",
                howToStep1: "1. Se le pedirá que recuerde o imagine una escena. Por favor, intente formar la imagen mental más clara posible.",
                howToStep2: "2. Luego, ajustará una imagen en la pantalla para que coincida con las cualidades de su imagen mental (por ejemplo, su brillo, desenfoque, etc.).",
                howToStep3: "3. Después de cada ajuste, calificará qué tan seguro/a está de su elección.",
                startPracticeButton: "Comenzar Ronda de Práctica",
                readyTitle: "Práctica Completada",
                readyText: "Ha completado la ronda de práctica. El experimento principal comenzará ahora. Recuerde tomarse su tiempo y responder con la mayor precisión posible.",
                startExperimentButton: "Comenzar Experimento",
                noInfoLabel: "No tengo una impresión clara de esta cualidad."
            }
        };

        const PARAMETERS = {
            saturation:   { name: {en: "Saturation", es: "Saturación"}, levels: 21, coarse: { low: 4, mid: 11, high: 18 }, parameter_specific_instruction: {en: "how colorful or saturated it was.", es: "qué tan colorido o saturado era."}},
            brightness:   { name: {en: "Brightness", es: "Brillo"}, levels: 21, coarse: { low: 4, mid: 11, high: 18 }, parameter_specific_instruction: {en: "how bright or dim it appeared.", es: "qué tan brillante u oscuro parecía."}},
            contrast:     { name: {en: "Contrast", es: "Contraste"}, levels: 21, coarse: { low: 4, mid: 11, high: 18 }, parameter_specific_instruction: {en: "the difference between light and dark areas.", es: "la diferencia entre áreas claras y oscuras."}},
            blurriness:   { name: {en: "Blurriness", es: "Desenfoque"}, levels: 21, coarse: { low: 4, mid: 11, high: 18 }, parameter_specific_instruction: {en: "how sharp or out-of-focus it was.", es: "qué tan nítido o desenfocado estaba."}},
            detailedness: { name: {en: "Detailedness", es: "Nivel de Detalle"}, levels: 21, coarse: { low: 4, mid: 11, high: 18 }, parameter_specific_instruction: {en: "how rich in fine features and textures it was.", es: "qué tan rico en detalles finos y texturas era."}},
            precision:    { name: {en: "Color Precision", es: "Precisión de Color"}, levels: 21, coarse: { low: 4, mid: 11, high: 18 }, parameter_specific_instruction: {en: "how specific or ambiguous the colors were.", es: "qué tan específicos o ambiguos eran los colores."}},
            // --- THIS IS THE NEW ATTENTION CHECK PARAMETER ---
            attention_check: { name: {en: "Attention Check", es: "Prueba de Atención"}, levels: 21, coarse: { low: 4, mid: 11, high: 18 }, 
                parameter_specific_instruction: {
                    en: "For this check, please select the 'Medium' button, then move the slider to level 11.", 
                    es: "Para esta prueba, por favor seleccione el botón 'Medio', y luego mueva el deslizador al nivel 11."
                },
                is_attention_check: true // Flag to identify this special parameter
            }
        };
        
        // ADD THIS NEW DATA OBJECT (replaces the old allTrialsMasterList)

        const IMAGE_DATA = [
            // --- INDOOR IMAGES (6) ---
            { id: 'image01', type: 'indoor', filename: 'image01.jpg', prompts: {
                episodic_recall:   {en: "Please recall a recent, vivid memory of relaxing in a LIVING ROOM with friends or family present. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria reciente y vívida de estar relajándose en una SALA DE ESTAR con amigos o familiares. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine a quiet, empty LIVING ROOM in the middle of the day, with sunlight coming through a window. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine una SALA DE ESTAR tranquila y vacía a mediodía, con la luz del sol entrando por una ventana. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image03', type: 'indoor', filename: 'image03.jpg', prompts: {
                episodic_recall:   {en: "Please recall a specific, vivid memory of being in a CLASSROOM, listening to a lesson. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria específica y vívida de estar en un AULA, escuchando una lección. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine an old, empty CLASSROOM after school, with chalk dust on the blackboard. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine un AULA vieja y vacía después de clases, con polvo de tiza en la pizarra. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image04', type: 'indoor', filename: 'image04.jpg', prompts: {
                episodic_recall:   {en: "Please recall a recent, vivid memory of pushing a shopping cart through a busy SUPERMARKET. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria reciente y vívida de estar empujando un carrito de compras en un SUPERMERCADO concurrido. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine standing in a SUPERMARKET aisle late at night, with almost no one else around. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine que está en el pasillo de un SUPERMERCADO por la noche, casi sin nadie más alrededor. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image08', type: 'indoor', filename: 'image08.jpg', prompts: {
                episodic_recall:   {en: "Please recall a vivid memory of looking for a specific item in a SUPERMARKET AISLE. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria vívida de estar buscando un artículo específico en un PASILLO DE SUPERMERCADO. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine a brightly lit and perfectly organized SUPERMARKET AISLE that is completely empty. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine un PASILLO DE SUPERMERCADO perfectamente ordenado y muy iluminado, que está completamente vacío. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image09', type: 'indoor', filename: 'image09.jpg', prompts: {
                episodic_recall:   {en: "Please recall a vivid memory of having a conversation in a comfortable LIVING ROOM. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria vívida de tener una conversación en una SALA DE ESTAR cómoda. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine a minimalist LIVING ROOM with modern furniture and no personal items. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine una SALA DE ESTAR minimalista con muebles modernos y sin objetos personales. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image12', type: 'indoor', filename: 'image12.jpg', prompts: {
                episodic_recall:   {en: "Please recall a vivid memory of working on a group project with other students in a CLASSROOM. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria vívida de trabajar en un proyecto grupal con otros estudiantes en un AULA. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine the first day of school, in a CLASSROOM filled with students finding their seats. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine el primer día de clases, en un AULA llena de estudiantes buscando sus asientos. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los los ojos y presione Continuar."}
            }},
            // --- OUTDOOR IMAGES (6) ---
            { id: 'image02', type: 'outdoor', filename: 'image02.jpg', prompts: {
                episodic_recall:   {en: "Please recall a vivid memory of walking down an empty CITY STREET early in the morning. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria vívida de caminar por una CALLE de una CIUDAD vacía temprano en la mañana. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine a wide CITY STREET in a futuristic city, with sleek, silent vehicles. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine una CALLE ancha en una CIUDAD futurista, con vehículos elegantes y silenciosos. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image05', type: 'outdoor', filename: 'image05.jpg', prompts: {
                episodic_recall:   {en: "Please recall a vivid memory of standing on a BEACH, feeling the spray from the waves. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria vívida de estar en una PLAYA, sintiendo la brisa de las olas. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine a secret BEACH on a tropical island, with a hidden waterfall and no footprints in the sand. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine una PLAYA secreta en una isla tropical, con una cascada escondida y sin huellas en la arena. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image06', type: 'outdoor', filename: 'image06.jpg', prompts: {
                episodic_recall:   {en: "Please recall a vivid memory of having a picnic or relaxing in a lush, green PARK. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria vívida de tener un picnic o relajarse en un PARQUE verde y frondoso. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine a vast botanical PARK with many strange and colorful exotic plants you've never seen before. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine un vasto PARQUE botánico con muchas plantas exóticas, extrañas y coloridas que nunca ha visto. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image07', type: 'outdoor', filename: 'image07.jpg', prompts: {
                episodic_recall:   {en: "Please recall a vivid memory of a pleasant walk through a PARK on a cool autumn day. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria vívida de un paseo agradable por un PARQUE en un día fresco de otoño. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine a PARK in the middle of winter, with bare trees and a light dusting of snow on the ground. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine un PARQUE en pleno invierno, con árboles sin hojas y una fina capa de nieve en el suelo. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image10', type: 'outdoor', filename: 'image10.jpg', prompts: {
                episodic_recall:   {en: "Please recall a vivid memory of being in a crowd on a BUSY CITY STREET. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria vívida de estar entre una multitud en una CALLE CONCURRIDA de una CIUDAD. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine a BUSY CITY STREET during a parade, with confetti in the air and music playing. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine una CALLE CONCURRIDA de una CIUDAD durante un desfile, con confeti en el aire y música sonando. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image11', type: 'outdoor', filename: 'image11.jpg', prompts: {
                episodic_recall:   {en: "Please recall a vivid memory of playing or building a sandcastle on a sunny BEACH. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria vívida de jugar o construir un castillo de arena en una PLAYA soleada. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine a BEACH at sunset, with the sky full of orange and purple colors. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine una PLAYA al atardecer, con el cielo lleno de colores naranjas y morados. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }}
        ];

        // --- VVIQ-2 Data and Configuration ---

        // Add the new checkbox label to the LANG_STRINGS object
        LANG_STRINGS.en.vviqCheckboxLabel = "Include VVIQ-2 Questionnaire";
        LANG_STRINGS.es.vviqCheckboxLabel = "Incluir Cuestionario VVIQ-2";

        const VVIQ_DATA = {
            instructions: {
                inst_1: {
                    en: "Visual imagery refers to the ability to visualize, that is, the ability to form mental pictures, or to 'see in the mind's eye'. Marked individual differences are found in the strength and clarity of reported visual imagery and these differences are of considerable psychological interest.",
                    es: "La imaginación visual se refiere a la capacidad de visualizar, es decir, la habilidad de formar imágenes mentales o de \"ver con los ojos de la mente\". Existen diferencias individuales marcadas en cuanto a la intensidad y claridad con que las personas experimentan estas imágenes, y dichas diferencias son de gran interés psicológico."
                },
                inst_2: {
                    en: "The aim of this test is to determine the vividness of your visual imagery. The items of the test will possibly bring certain images to your mind. You are asked to rate the vividness of each image by reference to the five-point scale given below. For example, if your image is 'vague and dim', then give it a rating of 2.",
                    es: "El objetivo de este cuestionario es evaluar la viveza de tu imaginación visual. Los ítems del test pueden evocarte ciertas imágenes. Se te pide que califiques la viveza de cada imagen utilizando la escala de cinco puntos que se presenta a continuación. Por ejemplo, si la imagen que formas es \"vaga y borrosa\", asígnale una puntuación de 2."
                },
                inst_3: {
                    en: "Before you turn to the items, familiarize yourself with the different categories on the rating scale. Throughout the test, refer to the rating scale when judging the vividness of each image. Try to do each item separately, independent of how you may have done other items.",
                    es: "Antes de comenzar con los ítems, familiarízate con las categorías de la escala de calificación. A lo largo del cuestionario, consulta esta escala cada vez que evalúes la viveza de una imagen. Intenta responder cada ítem por separado, de forma independiente de cómo hayas respondido los anteriores."
                },
                inst_4: {
                    en: "This test consists of 32 items to be imaged with your eyes closed. When we say \"eyes closed\", we mean the question is read, you close your eyes, an image is formed with them closed, and then open them to write the score. Try to score each item separately and independently of how you scored the other items.",
                    es: "Este test consta de 32 ítems, que deberás imaginar con los ojos cerrados. Cuando decimos \"los ojos cerrados\", significa que debes leer el enunciado, cerrar los ojos, formar la imagen mental con los ojos cerrados, y luego abrirlos para anotar tu puntuación. Intenta calificar cada ítem de forma independiente de los demás."
                }
            },
            scale: [
                { score: 5, en: "Perfectly clear and as vivid as real seeing", es: "Perfectamente clara y tan viva como si estuvieses viendo el objeto" },
                { score: 4, en: "Clear and reasonably vivid", es: "Clara y bastante viva" },
                { score: 3, en: "Moderately clear and vivid", es: "Moderadamente clara y viva" },
                { score: 2, en: "Vague and dim", es: "Vaga y borrosa" },
                { score: 1, en: "No image at all, you only \"know\" that you are thinking of the object", es: "Ninguna imagen, tú sólo \"sabes\" lo que estás pensando del objeto" }
            ],
            prompts: [
                {
                    prompt: { en: "Think of some relative or friend whom you frequently see (but who is not with you at present) and consider carefully the picture that comes before your mind's eye.", es: "Piensa en algún pariente o amigo al que ves frecuentemente (pero que no está contigo ahora). Considera la imagen que te viene a la cabeza." },
                    items: [
                        { en: "The outline of the face, head, shoulders and body.", es: "El contorno de la cara, cabeza, hombros y cuerpo." },
                        { en: "Characteristic posture, gesture, movement, etc.", es: "Las posturas características de la cabeza, ademanes corporales, etc." },
                        { en: "The precise carriage, length of step, etc., in walking.", es: "El modo exacto de andar, la longitud del paso, etc., cuando pasea." },
                        { en: "The different colours worn in clothes.", es: "Los diferentes colores que utiliza en su ropa habitual." }
                    ]
                },
                {
                    prompt: { en: "Visualise a rising sun. Consider the picture that comes before your mind's eye.", es: "Piensa en un sol naciente. Considera la imagen que te viene a la cabeza." },
                    items: [
                        { en: "The sun rising above the horizon into a hazy sky.", es: "El sol está naciendo sobre el horizonte en el cielo nebuloso." },
                        { en: "The sky clears and surrounds the sun with blueness.", es: "El cielo está claro y rodea al sol con su azul." },
                        { en: "Clouds. A storm blows up with flashes of lightning.", es: "Nubes. Una tormenta hace explosión, con destellos de relámpago." },
                        { en: "A rainbow appears.", es: "Aparece un arco iris." }
                    ]
                },
                {
                    prompt: { en: "Think of the front of a shop which you often go to. Consider the picture that comes before your mind's eye.", es: "Piensa en la fachada de la tienda a la que tú vas a menudo. Considera la imagen que te viene a la cabeza." },
                    items: [
                        { en: "The overall appearance of the shop from the opposite side of the road.", es: "El aspecto total de la tienda desde la acera de enfrente." },
                        { en: "A window display including colours, shapes, and details of the items for sale.", es: "Un escaparate, con los colores, formas y detalles de los productos expuestos." },
                        { en: "You are near the entrance. The colour, shape, and details of the door.", es: "Tú estás cerca de la entrada. El color, forma y detalles de la puerta." },
                        { en: "You enter the shop and go to the counter. The assistant serves you.", es: "Tú entras en la tienda y vas al mostrador. El vendedor te sirve." }
                    ]
                },
                {
                    prompt: { en: "Think of a countryside scene which includes trees, mountains, and a lake. Consider the picture that comes before your mind's eye.", es: "Piensa en una escena de campo que tenga árboles, montañas y un lago. Considera la imagen que te viene a la cabeza." },
                    items: [
                        { en: "The contours of the landscape.", es: "Los contornos del paisaje." },
                        { en: "The colour and shape of the trees.", es: "El color y forma de los árboles." },
                        { en: "The colour and shape of the lake.", es: "El color y forma del lago." },
                        { en: "A strong wind blows through the trees and over the lake causing ripples.", es: "Un fuerte viento sopla sobre los árboles y el lago, causando ondulaciones." }
                    ]
                },
                {
                    prompt: { en: "Imagine that a friend or relative is driving you at great speed on a motorway. Consider the picture that comes before your mind's eye.", es: "Piensa que un familiar o amigo te está llevando en coche a gran velocidad por una autopista. Considera la imagen que te viene a la cabeza."},
                    items: [
                        { en: "The overall appearance of fast-moving traffic around your car.", es: "Observa el denso tráfico que circula a gran velocidad alrededor de vuestro coche."},
                        { en: "Your car overtakes and you see worried expressions on other drivers' faces.", es: "Vuestro coche adelanta. Ves preocupación en la cara del conductor y de la gente de otros vehículos."},
                        { en: "A large truck flashes headlights and your car pulls aside.", es: "Un gran camión te da las luces largas. Tu coche se echa a un lado."},
                        { en: "A broken-down car with flashing lights and a woman on the phone.", es: "Un vehículo averiado fuera de la carretera. Conductora preocupada llama por teléfono."}
                    ]
                },
                {
                    prompt: { en: "Visualise a beach on a hot summer day. Consider the picture that comes before your mind's eye.", es: "Piensa en una playa en un caluroso día de verano. Considera la imagen que te viene a la cabeza."},
                    items: [
                        { en: "The appearance and colour of the sea, waves, and sky.", es: "La apariencia global y el color del agua, el reventar de las olas y el cielo."},
                        { en: "Swimmers playing with a brightly coloured beach ball.", es: "Los bañistas nadan y chapotean. Algunos juegan con una pelota de playa de colores brillantes."},
                        { en: "An ocean liner on the horizon trailing smoke.", es: "Un transatlántico cruza el horizonte dejando una estela de humo."},
                        { en: "A colourful hot-air balloon floats overhead and passengers wave.", es: "Un bonito globo hinchable pasa por encima. Los pasajeros saludan."}
                    ]
                },
                {
                    prompt: { en: "Visualise a railway station. Consider the picture that comes before your mind's eye.", es: "Piensa en una estación de tren. Considera la imagen que te viene a la cabeza."},
                    items: [
                        { en: "The overall appearance of the station from the front entrance.", es: "La apariencia general de la estación mirando frente a la entrada principal."},
                        { en: "Walking through the hall: its colour, shape, and details.", es: "Caminas por la estación. Color, forma y detalles del hall de entrada."},
                        { en: "Approaching the ticket counter and buying a ticket.", es: "Te acercas a las taquillas, vas a la ventanilla libre y compras tu billete."},
                        { en: "On the platform: watching passengers and boarding the train.", es: "Caminas por el andén. Observas pasajeros y vías. Llega un tren y te subes."}
                    ]
                },
                {
                    prompt: { en: "Visualise a garden with lawns, trees, flowers, and shrubs. Consider the picture that comes before your mind's eye.", es: "Finalmente, piensa en un jardín con césped, árboles, flores y arbustos. Considera la imagen que te viene a la cabeza."},
                    items: [
                        { en: "The general layout and appearance of the garden.", es: "El aspecto general y la disposición del jardín."},
                        { en: "The colour and shape of trees and bushes.", es: "El color y la forma de los árboles y arbustos."},
                        { en: "The colour and appearance of the flowers.", es: "El color y aspecto de las flores."},
                        { en: "Birds on the lawn pecking for food.", es: "Algunos pájaros se posan en el césped y comienzan a picotear."}
                    ]
                }
            ]
        };

        let totalSteps = 0;
        let completedSteps = 0; 
        
        let parameterStartTime = null;
        
        const GOOGLE_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbwkcpn2kATIjVlfgGAT6um4sN2LOcTU6Qde2vj8mKzd19VtfVxHynh3KR-qMBuNeanSkQ/exec';
        const saveStatus = document.getElementById('saveStatus');

        let currentLanguage = 'en';
        const imageBaseFolder = "images"; 
        const imageExtension = ".jpg";
        const fineTuneRange = 3; 
        let currentSessionTrials = []; 
        let currentGlobalTrialIndex = 0; 
        let currentTrialData = null;     
        let currentTrialResponses = {};  
        let allCollectedResponses = [];  
        let currentTaskMode = null; 
        let sessionID = null;
        let currentParameterKey = null;
        let currentParameterConfig = null;
        let actualTaskOrder = []; 
        let currentParameterIndexInTask = 0; 
        let currentFocusableElements = [];
        let currentFocusedIndex = -1;      
        const KEYBOARD_FOCUS_CLASS = 'keyboard-focus';
        const isTouchDevice = (('ontouchstart' in window) || (navigator.maxTouchPoints > 0));

        // --- DOM Elements ---
        const coarseButtonContainer = document.getElementById('coarseStep'); // Or a more specific container if you have one (coarseStepDiv?)       
        const mainMenuDiv = document.getElementById('mainMenu');
        const parameterSelectorDiv = document.getElementById('parameterSelector');
        const paramButtonsContainer = document.getElementById('paramButtonsContainer');
        const vimTaskInterfaceDiv = document.getElementById('vimTaskInterface');
        const resultsDisplayDiv = document.getElementById('resultsDisplay');
        const downloadResultsBtn = document.getElementById('downloadResultsBtn');
        const conditionInstructionScreenDiv = document.getElementById('conditionInstructionScreen');
        const conditionInstructionTitleH2 = document.getElementById('conditionInstructionTitle');
        const conditionInstructionTextP = document.getElementById('conditionInstructionText');
        const startTrialFromInstructionsBtn = document.getElementById('startTrialFromInstructionsBtn');
        const preVimScreenContainerDiv = document.getElementById('preVimScreenContainer');
        const fixationScreenDiv = document.getElementById('fixationScreen');
        const preVimImageScreenDiv = document.getElementById('preVimImageScreenDiv');
        const originalImageDisplayImg = document.getElementById('originalImageDisplay');
        const holdImageInstructionScreenDiv = document.getElementById('holdImageInstructionScreen');
        const holdImagePromptP = document.getElementById('holdImagePrompt');
        const holdImageContinueBtn = document.getElementById('holdImageContinueBtn');
        const vimGeneralInstructionP = document.getElementById('vimGeneralInstruction');
        const currentParamDisplay = document.getElementById('currentParamDisplay').querySelector('span');
        const coarseStepDiv = document.getElementById('coarseStep');
        const coarseParamNameStrong = document.getElementById('coarseParamName');
        const coarseButtons = coarseStepDiv.querySelectorAll('button[data-level-key]');
        const coarsePreviewImg = document.getElementById('coarsePreviewImg');
        const coarseImageDisplayP = document.querySelector('#coarseImageDisplay p.preview-instruction');
        const paramNameInlineSpans = document.querySelectorAll('.param-name-inline');
        const fineTuneStepDiv = document.getElementById('fineTuneStep');
        const fineTuneParamNameStrong = document.getElementById('fineTuneParamName');
        const fineTuneImg = document.getElementById('fineTuneImg');
        const fineTuneSlider = document.getElementById('fineTuneSlider');
        const fineTuneLevelDisplay = document.getElementById('fineTuneLevelDisplay');
        const backToCoarseBtn = document.getElementById('backToCoarseBtn');
        const confirmSelectionBtn = document.getElementById('confirmSelectionBtn');
        const resultsListUl = document.getElementById('resultsList');
        const backToMenuFromTestSelectBtn = document.getElementById('backToMenuFromTestSelectBtn');
        const backToMenuFromTaskBtn = document.getElementById('backToMenuFromTaskBtn');
        const backToMenuFromResultsBtn = document.getElementById('backToMenuFromResultsBtn');

        let currentCoarseSelectionLevel = null;
        let sliderToActualLevelMap = [];

        const confidenceStepDiv = document.getElementById('confidenceStep');
        const likertButtons = document.querySelectorAll('.likert-button');
        const confirmConfidenceBtn = document.getElementById('confirmConfidenceBtn');
        let currentConfidenceSelection = null;

        const welcomeScreen = document.getElementById('welcomeScreen');
        const howToScreen = document.getElementById('howToScreen');

        // --- Utility Functions ---

        function updateProgressBar() {
            if (totalSteps === 0) return; // Don't do anything if we haven't set up the steps

            completedSteps++;
            const percent = (completedSteps / totalSteps) * 100;
            
            const bar = document.getElementById('globalProgressBar');
            if (bar) {
                bar.style.width = `${percent}%`;
            }
        }

        function getUrlParameter(name) {
            name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
            var regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
            var results = regex.exec(location.search);
            return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' ')).toUpperCase();
        }

        // --- Smart Preloader Module ---

        async function preloadTrialAssets(trialData) {
            // 1. Show the loading overlay and disable the continue button
            const continueBtn = document.getElementById('startTrialFromInstructionsBtn');
            if (continueBtn) continueBtn.disabled = true;
            loadingOverlay.classList.remove('hidden');
            progressBar.style.width = '0%';
            loadingText.textContent = "Loading...";

            // 2. Create the list of all image URLs needed for this trial
            let urlsToPreload = [];
            
            // For perceptual recall, the original image is the most important
            if (trialData.condition === 'perceptual_recall') {
                urlsToPreload.push(getOriginalImagePath(trialData.original_image_filename));
            }

            // Add all the VIM variant images needed
            const realParameters = Object.keys(PARAMETERS).filter(p => p !== 'attention_check');
            realParameters.forEach(paramKey => {
                const coarseLevels = Object.values(PARAMETERS[paramKey].coarse);
                const fineTuneCenter = coarseLevels[1];
                let levels = [...coarseLevels];
                for (let i = -3; i <= 3; i++) {
                    const level = fineTuneCenter + i;
                    if (level >= 1 && level <= 21) levels.push(level);
                }
                const uniqueLevels = [...new Set(levels)];
                uniqueLevels.forEach(level => {
                    urlsToPreload.push(getVariantImagePath(trialData.base_image_id, paramKey, level));
                });
            });

            // 3. Preload all images and update the progress bar
            let loadedCount = 0;
            const totalToLoad = urlsToPreload.length;

            for (const url of urlsToPreload) {
                try {
                    await preloadImage(url);
                    loadedCount++;
                    // Update progress bar
                    const percent = Math.round((loadedCount / totalToLoad) * 100);
                    progressBar.style.width = `${percent}%`;
                } catch (error) {
                    console.warn(`Could not preload image: ${url}`, error);
                    // Even if one image fails, we increment the count to not get stuck
                    loadedCount++;
                }
            }
            
            // 4. Hide overlay and re-enable the button
            loadingText.textContent = "Loading complete!";
            setTimeout(() => { // A brief delay to let the user see "complete"
                loadingOverlay.classList.add('hidden');
                if (continueBtn) continueBtn.disabled = false;
            }, 250);
        }

        // Helper function that returns a Promise which resolves when an image loads
        function preloadImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = src;
            });
        }

        // --- End Preloader Module ---

        function shuffleArray(array) { 
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        function getVariantImagePath(baseImageId, paramKey, level) { 
            // If the parameter is an attention check, we need to get an image from a REAL parameter's folder.
            // We can just default to using the 'brightness' folder for this purpose.
            const folderParam = paramKey === 'attention_check' ? 'brightness' : paramKey;

            const levelStr = level < 10 ? '0' + level : level.toString();
            
            // Construct the path using the corrected folder parameter.
            return `${imageBaseFolder}/${folderParam}/${baseImageId}_${folderParam}_${levelStr}${imageExtension}`;
        }

        function getOriginalImagePath(originalFilename) { 
            return `${imageBaseFolder}/originals/${originalFilename}`;
        }
        
        function resetFullTaskState() { 
            if (vviqScreen) vviqScreen.classList.add('hidden');
            document.getElementById('globalProgressContainer').classList.add('hidden');
            currentTrialData = null;
            currentTrialResponses = {};
            currentTaskMode = null;
            sessionID = null; 
            currentParameterKey = null;
            currentParameterConfig = null;
            actualTaskOrder = [];
            currentParameterIndexInTask = 0;
            currentSessionTrials = [];
            currentGlobalTrialIndex = 0;
            allCollectedResponses = []; 
            console.log("Full task state reset.");
        }

        function clearAllFocus() {
            // This function finds ANY element that currently has the focus class and removes it.
            const focusedEl = document.querySelector('.' + KEYBOARD_FOCUS_CLASS);
            if (focusedEl) {
                focusedEl.classList.remove(KEYBOARD_FOCUS_CLASS);
            }
            // It also resets the global tracking variables for safety.
            currentFocusableElements = [];
            currentFocusedIndex = -1;
        }

        function updateKeyboardFocus(newIndex) {
            if (currentFocusableElements && currentFocusableElements[currentFocusedIndex]) {
                currentFocusableElements[currentFocusedIndex].classList.remove(KEYBOARD_FOCUS_CLASS);
            }
            currentFocusedIndex = newIndex;
            if (currentFocusableElements && currentFocusableElements[currentFocusedIndex]) {
                currentFocusableElements[currentFocusedIndex].classList.add(KEYBOARD_FOCUS_CLASS);
                currentFocusableElements[currentFocusedIndex].focus(); // Also set browser focus
            }
        }

        function setupMainMenuFocus() {
            // This function now only sets the initial focus, it does not set global variables.
            const firstButton = document.getElementById('testParameterBtn');
            if (firstButton) {
                // Add the focus class directly
                firstButton.classList.add(KEYBOARD_FOCUS_CLASS);
                firstButton.focus();
            }
        }
        
        function setupParameterSelectorFocus() {
            currentFocusableElements = Array.from(paramButtonsContainer.querySelectorAll('button'));
            updateKeyboardFocus(currentFocusableElements.length > 0 ? 0 : -1);
        }
        
        function setupCoarseStepFocus() {
            // The list is now a simple list of 4 buttons
            currentFocusableElements = [
                document.getElementById('noInfoBtn'),
                ...coarseButtons
            ];
            updateKeyboardFocus(2); // Start focus on "Medium"
        }

        // REPLACE your existing showDiv function with this one

        function showDiv(divToShow) { 
            // This list now includes all possible screens that can be shown.
            [mainMenuDiv, welcomeScreen, howToScreen, document.getElementById('readyScreen'),
            parameterSelectorDiv, vimTaskInterfaceDiv, resultsDisplayDiv, 
            preVimScreenContainerDiv, conditionInstructionScreenDiv, vviqScreen].forEach(div => {
                if(div) div.classList.add('hidden');
            });

            if (currentFocusableElements && currentFocusableElements[currentFocusedIndex]) {
                currentFocusableElements[currentFocusedIndex].classList.remove(KEYBOARD_FOCUS_CLASS);
            }
            currentFocusableElements = []; currentFocusedIndex = -1;

            // --- THIS IS THE NEW LOGIC ---
            // Get a reference to the language selector
            const langSelector = document.getElementById('languageSelector');

            if (divToShow) {
                divToShow.classList.remove('hidden');

                // Check if the screen being shown is the main menu
                if (divToShow === mainMenuDiv) {
                    langSelector.classList.remove('hidden'); // Show language buttons
                    setupMainMenuFocus();
                } else {
                    langSelector.classList.add('hidden'); // Hide language buttons on all other screens
                }
                
                // The rest of the focus setup logic
                if (divToShow === parameterSelectorDiv) setupParameterSelectorFocus();
                else if (divToShow === conditionInstructionScreenDiv) { currentFocusableElements = [startTrialFromInstructionsBtn]; updateKeyboardFocus(0); } 
                else if (divToShow === vimTaskInterfaceDiv && !coarseStepDiv.classList.contains('hidden')) { setupCoarseStepFocus(); }
            } else {
                // If we are hiding everything (e.g., between trials), also hide the language selector
                langSelector.classList.add('hidden');
            }
        }

        // --- LANGUAGE SWITCHING ---
        function setLanguage(lang) {
            currentLanguage = lang;
            document.getElementById('htmlTag').lang = lang; 

            document.querySelectorAll('#languageSelector button').forEach(btn => {
                btn.classList.toggle('active-lang', btn.dataset.lang === lang);
            });

            document.querySelectorAll('[data-lang-key]').forEach(el => {
                const key = el.dataset.langKey;
                if (LANG_STRINGS[currentLanguage] && LANG_STRINGS[currentLanguage][key]) {
                    el.textContent = LANG_STRINGS[currentLanguage][key];
                }
            });

            if (!parameterSelectorDiv.classList.contains('hidden')) {
                populateParameterSelector();
            }

            document.getElementById('confidencePrompt').textContent = LANG_STRINGS[lang].confidencePrompt;
            document.getElementById('likertLabelLow').textContent = LANG_STRINGS[lang].likertLabelLow;
            document.getElementById('likertLabelHigh').textContent = LANG_STRINGS[lang].likertLabelHigh;
        }

        // --- Core Application Logic ---

        function showConditionInstructions(trialDataObject) {
            currentTrialData = trialDataObject; 
            if (!currentTrialData) {
                console.error("showConditionInstructions called with invalid trialData!");
                return;
            }

            // Start preloading the images for THIS trial in the background.
            //preloadTrialImages(currentTrialData.base_image_id);

            const conditionName = {
                en: currentTrialData.condition.replace(/_/g, ' '),
                es: currentTrialData.condition === "perceptual_recall" ? "Recuerdo Perceptual" : 
                    currentTrialData.condition === "episodic_recall" ? "Recuerdo Episódico" : "Imaginación de Escena"
            }[currentLanguage];

            let titlePrefix = currentTaskMode === 'test' ? "Test Mode" : `Trial ${currentGlobalTrialIndex + 1} of ${currentSessionTrials.length}`;
            conditionInstructionTitleH2.textContent = `${titlePrefix}: ${conditionName}`;
            conditionInstructionTextP.textContent = currentTrialData.condition_instruction[currentLanguage];
            showDiv(conditionInstructionScreenDiv);
            // Start preloading the assets for this specific trial
            preloadTrialAssets(currentTrialData);
            currentFocusableElements = [startTrialFromInstructionsBtn];
            updateKeyboardFocus(0);
        }

        startTrialFromInstructionsBtn.addEventListener('click', () => {
            if (!currentTrialData) return;
            if (currentTrialData.condition === "perceptual_recall") {
                startPreVimPhase(currentTrialData);
            } else { 
                currentTrialResponses = { 
                    trial_id: currentTrialData.trial_id, condition: currentTrialData.condition,
                    image_id: currentTrialData.base_image_id, parameter_responses: {}
                };
                beginVimRating();
            }
        });

        // --- Pre-VIM Task Flow ---
        function startPreVimPhase(trialData) {
            currentTrialResponses = { 
                trial_id: trialData.trial_id, 
                condition: trialData.condition,
                image_id: trialData.base_image_id, 
                parameter_responses: {}
            };
            
            showDiv(preVimScreenContainerDiv);
            
            fixationScreenDiv.classList.add('hidden');
            preVimImageScreenDiv.classList.add('hidden');
            holdImageInstructionScreenDiv.classList.add('hidden');

            fixationScreenDiv.classList.remove('hidden'); 
            
            setTimeout(() => { 
                fixationScreenDiv.classList.add('hidden');
                preVimImageScreenDiv.classList.remove('hidden');
                originalImageDisplayImg.src = getOriginalImagePath(trialData.original_image_filename);
                
                setTimeout(() => { 
                    preVimImageScreenDiv.classList.add('hidden');
                    originalImageDisplayImg.src = ""; 
                    
                    holdImagePromptP.textContent = LANG_STRINGS[currentLanguage].holdImagePrompt_recall;
                    holdImageInstructionScreenDiv.classList.remove('hidden');
                    
                    currentFocusableElements = [holdImageContinueBtn];
                    updateKeyboardFocus(0);

                }, 1000); // Image display duration: 4 seconds
            }, 2000); // Fixation duration: 1 second
        }

        holdImageContinueBtn.addEventListener('click', () => {
            beginVimRating();
        });

        // --- VIM Parameter Rating Functions ---

        function beginVimRating() {
            if (currentTaskMode === 'tutorial') {
                actualTaskOrder = ['brightness'];
            } else if (currentTaskMode === 'test') {
                actualTaskOrder = [currentParameterKey];
            } else { 
                const realParameters = Object.keys(PARAMETERS).filter(p => p !== 'attention_check');
                let parametersForThisTrial = shuffleArray(realParameters);
                
                // --- THIS IS THE NEW LOGIC ---
                // If the trial is tagged, simply add the attention check as the 7th and final parameter.
                if (currentTrialData.has_attention_check) {
                    parametersForThisTrial.push('attention_check');
                }
                actualTaskOrder = parametersForThisTrial;
            }

            // This part of the logic remains the same
            const sceneTypeKey = currentTrialData.condition === "perceptual_recall" ? "recalled photo" 
                : currentTrialData.condition === "Practice" ? "practice image" 
                : "mental scene";
            const sceneTypeString = {en: sceneTypeKey, es: sceneTypeKey.replace("photo", "foto").replace("image", "imagen").replace("scene", "escena")}[currentLanguage];
            vimGeneralInstructionP.textContent = LANG_STRINGS[currentLanguage].vimGeneralInstruction.replace('{sceneType}', sceneTypeString);
            
            showDiv(vimTaskInterfaceDiv);
            currentParameterIndexInTask = 0;
            loadNextParameterInVim();
        }

        function loadNextParameterInVim() { 
            if (currentParameterIndexInTask < actualTaskOrder.length) {
                // More parameters to rate for the current trial
                currentParameterKey = actualTaskOrder[currentParameterIndexInTask];
                currentParameterConfig = PARAMETERS[currentParameterKey];
                setupCoarseStepVim(); 
            } else {
                // --- All parameters for the current trial are FINISHED ---
                if (currentTaskMode === 'actual_task_full') {
                    allCollectedResponses.push({...currentTrialResponses}); 
                }
                
                if (currentTaskMode === 'tutorial') {
                    showReadyScreen();
                } else if (currentTaskMode === 'test') {
                    alert(`Test complete for ${PARAMETERS[currentParameterKey].name.en}`);
                    showDiv(parameterSelectorDiv);
                } else {
                    // This was a main trial. Just load the next one.
                    currentGlobalTrialIndex++;
                    if (currentGlobalTrialIndex < currentSessionTrials.length) {
                        showConditionInstructions(currentSessionTrials[currentGlobalTrialIndex]);
                    } else {
                        displayFullResults();
                    }
                }
            }
        }
        
        // This is your working function with the one necessary line added.
        function setupCoarseStepVim() { 
            clearAllFocus();
            // 1. Clear the image from the previous fine-tuning step.
            if (fineTuneImg) fineTuneImg.src = "";
            // 2. Clear the image from the coarse preview.
            if (coarsePreviewImg) coarsePreviewImg.src = "";
            const paramName = currentParameterConfig.name[currentLanguage];
            currentParamDisplay.textContent = paramName;
            coarseParamNameStrong.textContent = currentParameterConfig.parameter_specific_instruction[currentLanguage]; 
            fineTuneParamNameStrong.textContent = currentParameterConfig.parameter_specific_instruction[currentLanguage];
            coarseButtons.forEach(button => {
                const levelKey = button.dataset.levelKey;
                button.dataset.level = currentParameterConfig.coarse[levelKey];
            });

            // Show/hide controls in RIGHT panel
            coarseStepDiv.classList.remove('hidden');
            fineTuneStepDiv.classList.add('hidden');
            confidenceStepDiv.classList.add('hidden'); // Also hide confidence step

            // Clear highlighting from BOTH sets of buttons.
            likertButtons.forEach(btn => btn.classList.remove('selected'));
            coarseButtons.forEach(btn => btn.classList.remove('selected')); // THIS IS THE NEW, ADDED LINE

            // Show/hide images in LEFT panel
            document.getElementById('coarseImageDisplay').classList.remove('hidden');
            document.getElementById('fineTuneImageDisplay').classList.add('hidden');

            // Hide ALL action buttons at the bottom initially for the coarse step
            backToCoarseBtn.classList.add('hidden');
            confirmSelectionBtn.classList.add('hidden');
            confirmConfidenceBtn.classList.add('hidden');
          
            // Reset preview
            coarsePreviewImg.src = ""; 
            if (coarseImageDisplayP) coarseImageDisplayP.classList.remove('hidden');
            setupCoarseStepFocus();
            // Start the timer for this parameter rating.
            parameterStartTime = Date.now();
        }

        function setupFineTuneStepVim(coarseLevelValue) {
            clearAllFocus();
            currentCoarseSelectionLevel = coarseLevelValue;
            fineTuneParamNameStrong.textContent = currentParameterConfig.parameter_specific_instruction[currentLanguage]; 
            const totalParamLevels = currentParameterConfig.levels;
            
            // Determine the min and max levels for the slider range
            let minL, maxL;
            if (coarseLevelValue === PARAMETERS[currentParameterKey].coarse.low) {
                minL = 1;
                maxL = 7;
            } else if (coarseLevelValue === PARAMETERS[currentParameterKey].coarse.mid) {
                minL = 8;
                maxL = 14;
            } else { // High
                minL = 15;
                maxL = 21;
            }
            
            sliderToActualLevelMap = [];
            for (let i = minL; i <= maxL; i++) {
                sliderToActualLevelMap.push(i);
            }

            // --- LOGIC FOR RANDOMIZATION ---
            // Instead of centering on the coarse value, pick a random starting index for the slider.
            const randomSliderIndex = Math.floor(Math.random() * sliderToActualLevelMap.length); // Get a random index from 0 to length-1
            const initialSliderValue = randomSliderIndex + 1; // Slider values are 1-based

            fineTuneSlider.min = 1;
            fineTuneSlider.max = sliderToActualLevelMap.length;
            fineTuneSlider.value = initialSliderValue; // Set the slider to the random position

            updateFineTuneImageVim(fineTuneSlider.value);
            
            coarseStepDiv.classList.add('hidden');
            fineTuneStepDiv.classList.remove('hidden');
            document.getElementById('coarseImageDisplay').classList.add('hidden');
            document.getElementById('fineTuneImageDisplay').classList.remove('hidden');
            
            backToCoarseBtn.classList.remove('hidden');
            confirmSelectionBtn.classList.remove('hidden');
            
            fineTuneSlider.focus(); 
            currentFocusableElements = [fineTuneSlider, backToCoarseBtn, confirmSelectionBtn];
            updateKeyboardFocus(0); 
        }

        function updateFineTuneImageVim(sliderValStr) { 
            const sliderValue = parseInt(sliderValStr);
            const actualLevel = sliderToActualLevelMap[sliderValue - 1];
            if (actualLevel !== undefined && currentTrialData && currentParameterKey) { 
                fineTuneImg.src = getVariantImagePath(currentTrialData.base_image_id, currentParameterKey, actualLevel);
                fineTuneLevelDisplay.textContent = actualLevel;
            }
        }
       
        // --- Start/Setup Functions ---
        function populateParameterSelector() { 
            paramButtonsContainer.innerHTML = ''; 
            Object.keys(PARAMETERS).forEach(key => {
                const button = document.createElement('button');
                button.textContent = `${LANG_STRINGS[currentLanguage].testParamButton.split(' ')[0]} ${PARAMETERS[key].name[currentLanguage]}`;
                button.addEventListener('click', () => startParameterTest(key));
                paramButtonsContainer.appendChild(button);
            });
            setupParameterSelectorFocus(); 
        }

        function startParameterTest(paramKey) {  
            resetFullTaskState(); 
            currentTaskMode = 'test';
            currentParameterKey = paramKey; 
            currentParameterConfig = PARAMETERS[paramKey]; 
            currentTrialData = {
                trial_id: "TestRun",
                condition: "Parameter Test",
                base_image_id: IMAGE_DATA.length > 0 ? IMAGE_DATA[0].id : "image01"
            };
            // It now calls our single, unified function.
            beginVimRating();
        }

        function createTrialList(set = 'A') {
            const conditions = ["perceptual_recall", "episodic_recall", "scene_imagination"];
            const indoorImages = IMAGE_DATA.filter(img => img.type === 'indoor');
            const outdoorImages = IMAGE_DATA.filter(img => img.type === 'outdoor');
            
            const groupAssignments = { 'A': [0, 1, 2], 'B': [1, 2, 0], 'C': [2, 0, 1] };
            
            const effectiveSet = (groupAssignments[set.toUpperCase()]) ? set.toUpperCase() : 'A';
            const assignment = groupAssignments[effectiveSet];

            let trialList = [];
            let trialCounter = 1;
            conditions.forEach((condition, i) => {
                const groupIndex = assignment[i];
                const indoorGroup = indoorImages.slice(groupIndex * 2, groupIndex * 2 + 2);
                const outdoorGroup = outdoorImages.slice(groupIndex * 2, groupIndex * 2 + 2);

                [...indoorGroup, ...outdoorGroup].forEach(img => {
                    let instruction = (condition === 'perceptual_recall')
                        ? { en: "You will be shown an image...", es: "Se le mostrará una imagen..."} // Simplified for brevity
                        : img.prompts[condition];

                    trialList.push({
                        trial_id: `main_${trialCounter++}`,
                        condition: condition,
                        base_image_id: img.id,
                        original_image_filename: img.filename.replace('.png', '.jpg'), // Assuming optimization
                        condition_instruction: instruction,
                        has_attention_check: false
                    });
                });
            });

            // Return an object containing both the list and the set name used
            return { trials: trialList, usedSet: effectiveSet };
        }

        // --- Onboarding Flow Control ---

        // When user clicks "Continue" on welcome screen
        document.getElementById('startInstructionsBtn').addEventListener('click', () => {
            showDiv(howToScreen);
        });

        // When user clicks "Start Practice Round"
        document.getElementById('startTutorialBtn').addEventListener('click', () => {
            startTutorial();
        });

        function startTutorial() {
            currentTaskMode = 'tutorial';
            currentTrialData = {
                trial_id: "TutorialRun",
                condition: "Practice",
                base_image_id: "tutorial" 
            };
            beginVimRating();

            // --- NEW PROGRESS BAR LOGIC ---
            completedSteps = 0;
            totalSteps = 1; // The tutorial has only one parameter to rate
            document.getElementById('globalProgressContainer').classList.remove('hidden');
        }

        function showReadyScreen() {
            // This function now correctly uses the showDiv system.
            const readyScreenDiv = document.getElementById('readyScreen');
            
            // Populate the text content based on the current language
            readyScreenDiv.querySelector('[data-lang-key="readyTitle"]').textContent = LANG_STRINGS[currentLanguage].readyTitle;
            readyScreenDiv.querySelector('[data-lang-key="readyText"]').textContent = LANG_STRINGS[currentLanguage].readyText;
            readyScreenDiv.querySelector('[data-lang-key="startExperimentButton"]').textContent = LANG_STRINGS[currentLanguage].startExperimentButton;

            // Show the screen
            showDiv(readyScreenDiv);
        }
        
        function startActualTask() {
            resetFullTaskState(); 
            currentTaskMode = 'actual_task_full';
            sessionID = Date.now();

            const requestedSet = getUrlParameter('set') || 'A';
            
            const generated = createTrialList(requestedSet);
            currentSessionTrials = shuffleArray(generated.trials);
            const actualSetUsed = generated.usedSet; // Get the name of the set that was really used

            // Display the set info clearly on the main menu
            const setInfoP = document.getElementById('setInfo');
            if (setInfoP) {
                let infoText = `(Using trial set: ${actualSetUsed})`;
                if (requestedSet.toUpperCase() !== actualSetUsed) {
                    infoText += ` - Note: Requested set '${requestedSet}' was invalid, defaulted to 'A'`;
                }
                setInfoP.textContent = infoText;
                setInfoP.style.color = (requestedSet.toUpperCase() !== actualSetUsed) ? 'orange' : '#888';
            }
            
            const attentionCheckCount = 3;
            let indices = Array.from(Array(currentSessionTrials.length).keys());
            let shuffledIndices = shuffleArray(indices);
            let attentionCheckIndices = shuffledIndices.slice(0, attentionCheckCount);
            attentionCheckIndices.forEach(index => {
                currentSessionTrials[index].has_attention_check = true;
            });
            console.log("Trials with an attention check:", attentionCheckIndices);
            currentSessionTrials = shuffleArray(currentSessionTrials);
            
            // --- NEW PROGRESS BAR LOGIC ---
            completedSteps = 0;
            // Calculate total steps: 6 real params * 12 trials + 3 attention check params
            totalSteps = (6 * 12) + 3; 
            if (vviqEnabled) {
                totalSteps += 32; // Add the 32 VVIQ items
            }
            document.getElementById('globalProgressContainer').classList.remove('hidden');
            
            currentGlobalTrialIndex = 0;
            allCollectedResponses = []; 
            showConditionInstructions(currentSessionTrials[0]);
        }  

        document.getElementById('startExperimentBtn').addEventListener('click', startActualTask);

        function displayFullResults() {
            // This function's only job is to decide whether to show VVIQ or the end screen.
            // The data handling will happen at the very end.
            if (vviqEnabled) {
                startVVIQ();
            } else {
                // If no VVIQ, go straight to the final collection and saving step.
                collectAndFinish();
            }
        }

        function downloadResults() {
            const dataToDownload = window.finalDataForDownload || {
                sessionID: sessionID,
                vim_results: allCollectedResponses,
                vviq_scores: []
            };
            
            if (!dataToDownload.sessionID) {
                alert("No data to download.");
                return;
            }

            const jsonString = JSON.stringify(dataToDownload, null, 2);

            // 3. Create a Blob from the JSON string
            const blob = new Blob([jsonString], { type: "application/json" });

            // 4. Create a temporary URL for the Blob
            const url = URL.createObjectURL(blob);

            // 5. Create a temporary anchor element to trigger the download
            const a = document.createElement('a');
            a.href = url;
            a.download = `VIM_results_session_${sessionID}.json`; // Set the filename
            document.body.appendChild(a); // Append to body to ensure it's clickable
            a.click(); // Programmatically click the link

            // 6. Clean up by removing the temporary anchor and URL
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        async function sendDataToGoogleSheet(dataToPost) {
            if (!dataToPost) {
                console.error("No data provided to send.");
                backToMenuFromResultsBtn.classList.remove('hidden');
                return; 
            }

            saveStatus.textContent = LANG_STRINGS[currentLanguage].resultsTitle === "Trial Results" ? "Saving data..." : "Guardando datos...";
            
            // We convert the object to a string and then to a special format.
            const formData = new FormData();
            formData.append('data', JSON.stringify(dataToPost));

            try {
                await fetch(GOOGLE_SCRIPT_URL, {
                    method: 'POST',
                    body: formData,
                });

                saveStatus.textContent = LANG_STRINGS[currentLanguage].resultsTitle === "Trial Results" ? "Data saved successfully. Thank you!" : "Datos guardados con éxito. ¡Gracias!";
                saveStatus.style.color = 'green';
                console.log("Data submission successful.");

            } catch (error) {
                saveStatus.textContent = LANG_STRINGS[currentLanguage].resultsTitle === "Trial Results" ? "Error: Could not save data. Please use the download button." : "Error: No se pudieron guardar los datos. Por favor, use el botón de descarga.";
                saveStatus.style.color = 'red';
                console.error("Error sending data to Google Sheet:", error);
            } finally {
                backToMenuFromResultsBtn.classList.remove('hidden');
            }
        }

        document.getElementById('noInfoBtn').addEventListener('click', () => {
            if (!currentTrialData || !currentParameterKey) return;

            // Record the "no_info" response for the level
            if (!currentTrialResponses.parameter_responses) {
                currentTrialResponses.parameter_responses = {};
            }
            currentTrialResponses.parameter_responses[currentParameterKey] = {
                level: 'no_info',
                // Confidence will be collected in the next step
            };

            // First, explicitly hide the coarse selection controls.
            coarseStepDiv.classList.add('hidden');
            // Go DIRECTLY to the confidence step, skipping fine-tune.
            showConfidenceStep();
        });

        function handleConfirmSelection() {
            if (!currentTrialData || !currentParameterKey) return;
            
            // Get the selected level from the slider
            const finalLevel = sliderToActualLevelMap[parseInt(fineTuneSlider.value) - 1];
            
            if (!currentTrialResponses.parameter_responses) {
                currentTrialResponses.parameter_responses = {};
            }
            // Store the level response
            currentTrialResponses.parameter_responses[currentParameterKey] = { level: finalLevel };
            
            // Transition to the confidence rating step
            showConfidenceStep();
        }

        function handleConfirmConfidence() {
            if (currentConfidenceSelection === null) return;

            // Start the timer for this parameter rating
            const responseTime = Date.now() - parameterStartTime;

            // Save the confidence and response time to the existing parameter response
            if (currentTrialResponses.parameter_responses[currentParameterKey]) {
                currentTrialResponses.parameter_responses[currentParameterKey].confidence = currentConfidenceSelection;
                currentTrialResponses.parameter_responses[currentParameterKey].rt = responseTime;
            }
            
            updateProgressBar(); 

            // Advance to the next parameter
            currentParameterIndexInTask++;
            loadNextParameterInVim();
        }
        
        // --- VVIQ-2 Module (Corrected with Event Delegation) ---

        let vviqEnabled = true;
        const vviqScreen = document.getElementById('vviqScreen');
        let vviqItems = [];
        let vviqCurrentStep = 0;
        let vviqCurrentResponse = null;
        let vviqResponses = [];

        function startVVIQ() {
            vviqCurrentStep = 0;
            vviqItems = createVVIQItems();
            vviqResponses = []; 

            // Generate the static HTML shell for the VVIQ screen
            vviqScreen.innerHTML = generateVVIQ_BaseHTML();

            // Attach ONE smart event listener to the parent container. This is the key.
            vviqScreen.addEventListener('click', handleVVIQ_Clicks);

            // Display the first instruction screen
            displayVVIQStep();
        }

        // The single, smart click handler for the entire VVIQ screen
        function handleVVIQ_Clicks(event) {
            const target = event.target.closest('button');
            if (!target || target.disabled) return;

            if (target.id === 'vviqBackToMenuBtn') {
                if (confirm(LANG_STRINGS[currentLanguage].exitConfirmMessage)) {
                    resetFullTaskState();
                    showDiv(mainMenuDiv);
                }
                return;
            }

            if (target.id === 'vviqNextBtn') {
                advanceVVIQ();
            } 
            else if (target.id === 'vviqSubmitBtn') {
                // This now calls our new, unified function
                collectAndFinish(); 
            }
            else if (target.classList.contains('likert-button')) {
                handleLikertSelection(target);
            }
        }

        function handleLikertSelection(button) {
            vviqCurrentResponse = parseInt(button.dataset.value);
            // Highlight the selected button
            vviqScreen.querySelectorAll('.likert-button').forEach(btn => btn.classList.remove('selected'));
            button.classList.add('selected');
            vviqScreen.querySelector('#vviqNextBtn').disabled = false;
            
            // Update keyboard focus for arrow key navigation
            currentFocusableElements = Array.from(vviqScreen.querySelectorAll('.likert-button'));
            updateKeyboardFocus(currentFocusableElements.indexOf(button));
        }

        function createVVIQItems() {
            const shuffledPrompts = shuffleArray(VVIQ_DATA.prompts);
            const allItems = [];
            let itemCounter = 0;
            shuffledPrompts.forEach(prompt => {
                prompt.items.forEach(item => {
                    allItems.push({ id: ++itemCounter, prompt: prompt.prompt, item: item });
                });
            });
            return allItems;
        }

        // This function finds elements inside the vviqScreen
        function displayVVIQStep() {
            const lang = currentLanguage;
            const titleEl = vviqScreen.querySelector('#vviqTitle');
            const instructionEl = vviqScreen.querySelector('#vviqInstructionText');
            const scaleTableEl = vviqScreen.querySelector('#vviqScaleTableContainer');
            const itemScreenEl = vviqScreen.querySelector('#vviqItemScreen');
            const nextBtn = vviqScreen.querySelector('#vviqNextBtn');
            
            // Hide all optional components first
            instructionEl.style.display = 'none';
            scaleTableEl.style.display = 'none';
            itemScreenEl.style.display = 'none';
            
            titleEl.textContent = "Vividness of Visual Imagery Questionnaire";
            nextBtn.textContent = LANG_STRINGS[lang].continueButton;
            nextBtn.disabled = false;
            
            if (vviqCurrentStep === 0) {
                instructionEl.style.display = 'block';
                instructionEl.innerHTML = `<p>${VVIQ_DATA.instructions.inst_1[lang]}</p>`;
            } else if (vviqCurrentStep === 1) {
                instructionEl.style.display = 'block';
                scaleTableEl.style.display = 'block';
                instructionEl.innerHTML = `<p>${VVIQ_DATA.instructions.inst_2[lang]}</p><p>${VVIQ_DATA.instructions.inst_3[lang]}</p>`;
                scaleTableEl.innerHTML = generateVVIQScaleTableHTML();
            } else if (vviqCurrentStep === 2) {
                instructionEl.style.display = 'block';
                instructionEl.innerHTML = `<p><strong>${VVIQ_DATA.instructions.inst_4[lang]}</strong></p>`;
                nextBtn.textContent = LANG_STRINGS[lang].startPracticeButton.replace("Practice Round", "Questionnaire");
            } else {
                const itemIndex = vviqCurrentStep - 3;
                displayVVIQItem(vviqItems[itemIndex]);
            }
            showDiv(vviqScreen);
        }

        function displayVVIQItem(itemData) {
            const lang = currentLanguage;
            const itemScreen = vviqScreen.querySelector('#vviqItemScreen');
            
            // --- This part is the same: build the UI ---
            vviqScreen.querySelector('#vviqTitle').textContent = `Question ${itemData.id} of 32`;
            itemScreen.style.display = 'block';
            itemScreen.querySelector('#vviqItemPrompt').textContent = itemData.prompt[lang];
            itemScreen.querySelector('#vviqItemText').textContent = `${itemData.id}. ${itemData.item[lang]}`;
            vviqScreen.querySelector('#vviqLikertLabelLow').textContent = VVIQ_DATA.scale[4][lang];
            vviqScreen.querySelector('#vviqLikertLabelHigh').textContent = VVIQ_DATA.scale[0][lang];

            const scaleContainer = vviqScreen.querySelector('#vviqLikertScale');
            scaleContainer.innerHTML = ''; 
            VVIQ_DATA.scale.slice().reverse().forEach(scalePoint => {
                const button = document.createElement('button');
                button.className = 'likert-button';
                button.dataset.value = scalePoint.score;
                button.textContent = scalePoint.score;
                scaleContainer.appendChild(button);
            });
            
            vviqCurrentResponse = null;
            vviqScreen.querySelector('#vviqNextBtn').disabled = true;
            vviqScreen.querySelector('#vviqNextBtn').textContent = LANG_STRINGS[lang].confirmConfidenceButton.replace("Confidence", "Rating");

            // 1. Define the focusable elements for this screen every time.
            currentFocusableElements = Array.from(scaleContainer.children);
            
            // 2. Remove any old focus class from a previous trial to prevent visual artifacts.
            currentFocusableElements.forEach(el => el.classList.remove(KEYBOARD_FOCUS_CLASS));

            // 3. Set the initial focus state to the middle button (index 2 corresponds to button "3").
            const initialFocusIndex = 2;
            
            // 4. Call the single, reliable updateKeyboardFocus function to synchronize
            //    both the internal state (currentFocusedIndex) and the visual state (.keyboard-focus class).
            updateKeyboardFocus(initialFocusIndex); 
        }

        function advanceVVIQ() {
            // Only save the response if we are actually on an item screen
            if (vviqCurrentStep >= 3 && vviqCurrentStep - 3 < vviqItems.length) {
                if (vviqCurrentResponse !== null) {
                    vviqResponses.push({ id: vviqItems[vviqCurrentStep - 3].id, response: vviqCurrentResponse });
                    updateProgressBar();
                }
            }
            
            vviqCurrentStep++;
            const itemIndex = vviqCurrentStep - 3;
            
            if (itemIndex < vviqItems.length) {
                displayVVIQStep();
            } else {
                // Finished last item, show the final submit screen
                vviqScreen.querySelector('#vviqItemScreen').style.display = 'none';
                vviqScreen.querySelector('#vviqInstructionText').style.display = 'block';
                vviqScreen.querySelector('#vviqInstructionText').innerHTML = `<p>You have completed the questionnaire. Click Submit to finish the experiment.</p>`;
                vviqScreen.querySelector('#vviqNextBtn').style.display = 'none';
                const submitBtn = vviqScreen.querySelector('#vviqSubmitBtn');
                submitBtn.style.display = 'block';
                submitBtn.textContent = "Submit VVIQ";
                submitBtn.disabled = false;
                
                currentFocusableElements = [submitBtn];
                updateKeyboardFocus(0);
            }
        }

        function collectAndFinish() {
            let finalScores = [];
            // If the VVIQ was run, get the scores.
            if (vviqEnabled && vviqResponses.length > 0) {
                vviqResponses.sort((a, b) => a.id - b.id);
                finalScores = vviqResponses.map(r => r.response);
            }

            // Create the final data payload, combining VIM and VVIQ (if any)
            const finalDataObject = {
                sessionID: sessionID,
                vim_results: allCollectedResponses,
                vviq_scores: finalScores 
            };

            // Make the data available for download
            window.finalDataForDownload = finalDataObject;

            // Hide the VVIQ screen just in case it was visible
            vviqScreen.classList.add('hidden');
            // Show the final saving screen
            showDiv(resultsDisplayDiv);

            // Send the complete, final data object to Google
            sendDataToGoogleSheet(finalDataObject);
        }

        function generateVVIQ_BaseHTML() {
            // Get the correct button text from our language object
            const backButtonText = LANG_STRINGS[currentLanguage].exitTaskButton;

            return `
                <h2 id="vviqTitle"></h2>
                <div id="vviqInstructionText" class="vviq-instructions"></div>
                <div id="vviqScaleTableContainer"></div>
                <div id="vviqItemScreen" style="display:none;">
                    <p id="vviqItemPrompt" class="vviq-prompt-header"></p>
                    <div class="vviq-item">
                        <span id="vviqItemText" class="vviq-item-text"></span>
                        <div class="likert-container">
                            <span id="vviqLikertLabelLow" class="likert-label-end"></span>
                            <div id="vviqLikertScale" class="likert-scale"></div>
                            <span id="vviqLikertLabelHigh" class="likert-label-end"></span>
                        </div>
                    </div>
                </div>
                <div class="flex-spacer"></div>
                <button id="vviqNextBtn"></button>
                <button id="vviqSubmitBtn" style="display:none;"></button>
                
                <!-- The button now gets its text content immediately upon creation -->
                <button id="vviqBackToMenuBtn" class="back-button">${backButtonText}</button>
            `;
        }

        function generateVVIQScaleTableHTML() {
            const lang = currentLanguage;
            let table = `<table class="vviq-rating-scale-table"><tr><th>Rating</th><th>Description</th></tr>`;
            VVIQ_DATA.scale.forEach(item => { table += `<tr><td><strong>${item.score}</strong></td><td>${item[lang]}</td></tr>`; });
            return table + `</table>`;
        }

        // --- End VVIQ-2 Module ---

        // --- EVENT LISTENERS ---

        document.getElementById('testVVIQBtn').addEventListener('click', () => {
            // --- NEW PROGRESS BAR LOGIC ---
            completedSteps = 0;
            totalSteps = 32; // The VVIQ test has 32 items
            document.getElementById('globalProgressContainer').classList.remove('hidden');
            
            // We just need to call the function that starts the VVIQ
            startVVIQ();
        });

        document.getElementById('vviqCheckbox').addEventListener('change', (event) => {
            vviqEnabled = event.target.checked;
        });

        document.addEventListener('DOMContentLoaded', () => {
            resetFullTaskState(); 
            setLanguage('en'); 
            showDiv(mainMenuDiv);
            if(isTouchDevice) document.body.classList.add('touch-device');
        });

        // Language Buttons
        document.querySelectorAll('#languageSelector button').forEach(button => {
            button.addEventListener('click', () => setLanguage(button.dataset.lang));
        });

        // Main Menu Buttons
        document.getElementById('testParameterBtn').addEventListener('click', () => {
            resetFullTaskState(); 
            populateParameterSelector();
            showDiv(parameterSelectorDiv);
        });
        
        document.getElementById('startActualTaskBtn').addEventListener('click', () => {
            // Now, this button simply shows the first welcome screen
            showDiv(welcomeScreen);
        });
        
        // Back Buttons
        backToMenuFromTestSelectBtn.addEventListener('click', () => { resetFullTaskState(); showDiv(mainMenuDiv); });
        backToMenuFromTaskBtn.addEventListener('click', () => {
            let confirmExit = currentTaskMode === 'test' ? true : confirm(LANG_STRINGS[currentLanguage].exitConfirmMessage);
            if (confirmExit) {
                resetFullTaskState();
                showDiv(mainMenuDiv);
            }
        }); 
        backToMenuFromResultsBtn.addEventListener('click', () => { resetFullTaskState(); showDiv(mainMenuDiv); });

        // Download Button
        downloadResultsBtn.addEventListener('click', downloadResults);

        coarseButtons.forEach(button => {
            button.addEventListener('mouseover', () => {
                if (!currentParameterConfig || coarseStepDiv.classList.contains('hidden') || !currentTrialData) return;
                
                // This is the working preview logic
                const level = parseInt(button.dataset.level);
                coarsePreviewImg.src = getVariantImagePath(currentTrialData.base_image_id, currentParameterKey, level);
                
                // Safety check before using the variable
                if(coarseImageDisplayP) coarseImageDisplayP.classList.add('hidden');
            });
            button.addEventListener('click', () => {
                if (!currentParameterConfig) return;
                const realLevel = PARAMETERS[currentParameterKey].coarse[button.dataset.levelKey];
                setupFineTuneStepVim(realLevel); 
            });
        });
        
        fineTuneSlider.addEventListener('input', (event) => { 
            if (currentTrialData && currentParameterKey) updateFineTuneImageVim(event.target.value); 
        });

        backToCoarseBtn.addEventListener('click', setupCoarseStepVim); 

        confirmSelectionBtn.addEventListener('click', handleConfirmSelection);

        function showConfidenceStep() {
            clearAllFocus();
            // Hide the fine-tune UI elements
            fineTuneStepDiv.classList.add('hidden');
            // Hide the individual buttons from the previous step
            backToCoarseBtn.classList.add('hidden');
            confirmSelectionBtn.classList.add('hidden');

            // Show the confidence UI elements
            confidenceStepDiv.classList.remove('hidden');
            confirmConfidenceBtn.classList.remove('hidden'); 
            confirmConfidenceBtn.disabled = true; 

            // Reset previous selection
            currentConfidenceSelection = null;
            likertButtons.forEach(btn => btn.classList.remove('selected'));

            // Set up keyboard focus
            currentFocusableElements = Array.from(likertButtons).concat(confirmConfidenceBtn);
            updateKeyboardFocus(3); // Start focus on button '4'
        }

        confirmConfidenceBtn.addEventListener('click', handleConfirmConfidence);

        // Event listener block for the Likert scale

        likertButtons.forEach(button => {
            button.addEventListener('click', () => {
                // Remove 'selected' from all buttons
                likertButtons.forEach(btn => btn.classList.remove('selected'));
                // Add 'selected' to the clicked button
                button.classList.add('selected');
                // Store the value
                currentConfidenceSelection = parseInt(button.dataset.value);
                // Enable the confirm button
                confirmConfidenceBtn.disabled = false;
                
                // Update keyboard focus to the clicked button
                const buttonIndex = Array.from(likertButtons).indexOf(button);
                if (buttonIndex !== -1) {
                    updateKeyboardFocus(buttonIndex);
                }
            });
        });

        // --- UNIFIED KEYBOARD INPUT HANDLING ---

        document.addEventListener('keydown', (event) => {
            // Ignore key presses if a user is typing in a text box
            if (document.activeElement.tagName === 'INPUT' && document.activeElement.type !== 'range') return;

            // Global Escape Key
            if (event.key === "Escape") {
                event.preventDefault();
                const visibleScreen = document.querySelector('.main-container:not(.hidden), .split-container:not(.hidden)');
                if (visibleScreen) {
                    const backButton = visibleScreen.querySelector('.back-button, #vviqBackToMenuBtn');
                    if (backButton) backButton.click();
                }
                return;
            }

            // --- Main Router (Corrected Order) ---
            // We check for the most specific screens first.
            
            if (!vviqScreen.classList.contains('hidden')) {
                // If VVIQ is visible, it takes priority.
                handleVVIQ_Keys(event);
            }
            else if (!vimTaskInterfaceDiv.classList.contains('hidden')) {
                // Only if VVIQ is NOT visible, do we check for the VIM task.
                handleVimTaskKeys(event);
            }
            else if (!welcomeScreen.classList.contains('hidden')) {
                if (event.key === "Enter") { event.preventDefault(); document.getElementById('startInstructionsBtn').click(); }
            } 
            else if (!howToScreen.classList.contains('hidden')) {
                if (event.key === "Enter") { event.preventDefault(); document.getElementById('startTutorialBtn').click(); }
            } 
            else if (!document.getElementById('readyScreen').classList.contains('hidden')) {
                if (event.key === "Enter") { event.preventDefault(); document.getElementById('startExperimentBtn').click(); }
            } 
            else if (!mainMenuDiv.classList.contains('hidden')) {
                handleMainMenuKeys(event);
            } 
            else if (!parameterSelectorDiv.classList.contains('hidden')) {
                handleParameterSelectorKeys(event);
            } 
            else if (!conditionInstructionScreenDiv.classList.contains('hidden')) {
                if (event.key === "Enter") { event.preventDefault(); startTrialFromInstructionsBtn.click(); }
            } 
            else if (!preVimScreenContainerDiv.classList.contains('hidden') && !holdImageInstructionScreenDiv.classList.contains('hidden')) {
                if (event.key === "Enter") { event.preventDefault(); beginVimRating(); }
            } 
        });

        // Generic handler for simple screens with one "continue" button
        function handleInstructionKeys(event, buttonId) {
            if (event.key === "Enter") {
                event.preventDefault();
                document.getElementById(buttonId).click();
            }
        }

        function handleMainMenuKeys(event) {
            let handled = false;
            // This function now manages its own list of elements.
            const menuButtons = [
                document.getElementById('testParameterBtn'),
                document.getElementById('testVVIQBtn'),
                document.getElementById('startActualTaskBtn')
            ];
            const currentFocused = document.querySelector('.main-container:not(.hidden) .keyboard-focus');
            let currentIndex = currentFocused ? menuButtons.indexOf(currentFocused) : 0;

            if (event.key === "ArrowUp") {
                if (currentIndex > 0) {
                    currentIndex--;
                } else {
                    currentIndex = menuButtons.length - 1; // Loop to bottom
                }
                handled = true;
            } else if (event.key === "ArrowDown") {
                if (currentIndex < menuButtons.length - 1) {
                    currentIndex++;
                } else {
                    currentIndex = 0; // Loop to top
                }
                handled = true;
            } else if (event.key === "Enter") {
                if (currentFocused) {
                    currentFocused.click();
                }
                handled = true;
            }

            if (handled) {
                event.preventDefault();
                // Remove old focus and apply new focus manually
                if (currentFocused) currentFocused.classList.remove(KEYBOARD_FOCUS_CLASS);
                const newFocusedButton = menuButtons[currentIndex];
                if (newFocusedButton) {
                    newFocusedButton.classList.add(KEYBOARD_FOCUS_CLASS);
                    newFocusedButton.focus();
                }
            }
        }

        function handleParameterSelectorKeys(event) {
            let handled = false;
            let newIndex = currentFocusedIndex;
            if (event.key === "ArrowUp") { newIndex = currentFocusedIndex > 0 ? currentFocusedIndex - 1 : currentFocusableElements.length - 1; handled = true; } 
            else if (event.key === "ArrowDown") { newIndex = currentFocusedIndex < currentFocusableElements.length - 1 ? currentFocusedIndex + 1 : 0; handled = true; } 
            else if (event.key === "Enter") { if (currentFocusedIndex > -1) currentFocusableElements[currentFocusedIndex].click(); handled = true; }
            
            if (newIndex !== currentFocusedIndex) updateKeyboardFocus(newIndex);
            if (handled) event.preventDefault();
        }

        function handleVimTaskKeys(event) {
            let handled = false;
            // --- Coarse Step ---
            if (!coarseStepDiv.classList.contains('hidden')) {
                let handled = false;
                let newIndex = currentFocusedIndex;

                if (event.key === "ArrowLeft") {
                    newIndex = (currentFocusedIndex > 0) ? newIndex - 1 : currentFocusableElements.length - 1;
                    handled = true;
                } else if (event.key === "ArrowRight") {
                    newIndex = (currentFocusedIndex < currentFocusableElements.length - 1) ? newIndex + 1 : 0;
                    handled = true;
                }
                
                if (newIndex !== currentFocusedIndex) {
                    updateKeyboardFocus(newIndex);
                    // Manually trigger the mouseover event on the newly focused element.
                    // Our updated mouseover handler will correctly handle both types of buttons.
                    currentFocusableElements[newIndex].dispatchEvent(new Event('mouseover'));
                }
                
                if (event.key === 'Enter' && currentFocusedIndex > -1) {
                    const focusedElement = currentFocusableElements[currentFocusedIndex];

                    // Manually trigger the 'click' event on the focused element.
                    // This will now correctly call either the coarseButton listener OR our new noInfoBtn listener.
                    focusedElement.click();
                    
                    handled = true;
                }

                if (handled) event.preventDefault();
            }
            // --- Fine-Tune Step ---
            else if (!fineTuneStepDiv.classList.contains('hidden')) {
                const slider = document.getElementById('fineTuneSlider');
                if (document.activeElement === slider) {
                    if (event.key === "ArrowLeft" || event.key === "ArrowRight") return; // Allow default slider behavior
                }
                if (event.key === "Enter") { document.getElementById('confirmSelectionBtn').click(); handled = true; }
                if (event.key === "Backspace") { document.getElementById('backToCoarseBtn').click(); handled = true; }
            }
            // --- Confidence Step ---
            else if (!confidenceStepDiv.classList.contains('hidden')) {
                let newIndex = currentFocusedIndex;
                if (event.key === "ArrowLeft") { if (newIndex > 0) newIndex--; handled = true; } 
                else if (event.key === "ArrowRight") { if (newIndex < currentFocusableElements.length - 1) newIndex++; handled = true; }
                if (newIndex !== currentFocusedIndex) updateKeyboardFocus(newIndex);
                
                if (event.key === 'Enter' && currentFocusedIndex > -1) {
                    currentFocusableElements[currentFocusedIndex].click();
                    if (!document.getElementById('confirmConfidenceBtn').disabled) {
                        document.getElementById('confirmConfidenceBtn').click();
                    }
                    handled = true;
                }
            }
            if (handled) event.preventDefault();
        }

        function handleVVIQ_Keys(event) {
            if (event.key === "Escape") {
                event.preventDefault();
                const backButton = vviqScreen.querySelector('#vviqBackToMenuBtn');
                if (backButton) { backButton.click(); }
                return;
            }
            
            let handled = false;
            const itemScreenVisible = !vviqScreen.querySelector('#vviqItemScreen').classList.contains('hidden');
            const submitBtn = vviqScreen.querySelector('#vviqSubmitBtn');

            // --- Part 1: Your Correct State Handling ---
            // Check for the final submit screen FIRST.
            if (submitBtn && submitBtn.style.display !== 'none') {
                if (event.key === 'Enter') {
                    submitBtn.click();
                    handled = true;
                }
            }
            // Then, handle the item rating screen.
            else if (itemScreenVisible) {
                // --- Part 2: My "brute-force" synchronization logic for arrow keys ---
                currentFocusableElements = Array.from(vviqScreen.querySelectorAll('.likert-button'));
                const visuallyFocusedEl = vviqScreen.querySelector('.keyboard-focus');
                currentFocusedIndex = visuallyFocusedEl ? currentFocusableElements.indexOf(visuallyFocusedEl) : -1;
                
                let newIndex = currentFocusedIndex;

                if (event.key === "ArrowLeft") { 
                    if (newIndex === -1) newIndex = 2; // If nothing focused, start from middle
                    else if (newIndex > 0) newIndex--; 
                    handled = true; 
                } 
                else if (event.key === "ArrowRight") { 
                    if (newIndex === -1) newIndex = 2; // If nothing focused, start from middle
                    else if (newIndex < currentFocusableElements.length - 1) newIndex++; 
                    handled = true; 
                }
                
                if (newIndex !== currentFocusedIndex) {
                    updateKeyboardFocus(newIndex);
                }

                // --- Part 3: The rest of the working logic for the item screen ---
                if (["1", "2", "3", "4", "5"].includes(event.key)) {
                    const buttonToClick = vviqScreen.querySelector(`.likert-button[data-value="${event.key}"]`);
                    if (buttonToClick) buttonToClick.click();
                    handled = true;
                } else if (event.key === 'Enter') {
                    const nextBtn = document.getElementById('vviqNextBtn');
                    if (currentFocusedIndex > -1) {
                        currentFocusableElements[currentFocusedIndex].click();
                    }
                    if (nextBtn && !nextBtn.disabled) {
                        nextBtn.click();
                    }
                    handled = true;
                }
            } 
            // Finally, handle the instruction screens.
            else { 
                if (event.key === 'Enter') {
                    const nextBtn = document.getElementById('vviqNextBtn');
                    if (nextBtn && nextBtn.style.display !== 'none') {
                        nextBtn.click();
                    }
                    handled = true;
                }
            }
            if (handled) event.preventDefault();
        }
        
    </script>
</body>
</html>