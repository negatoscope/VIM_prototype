<!DOCTYPE html>
<html lang="en" id="htmlTag">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VIM Prototype - Final Corrected</title>
    <style>
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; min-height: 100vh; margin: 0; padding: 10px; box-sizing: border-box; background-color: #f4f4f4; }
        .main-container { border: 1px solid #ccc; padding: 20px; text-align: center; background-color: white; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); width: 90%; max-width: 800px; margin-top: 20px; }
        .image-display { margin-bottom: 20px; display: flex; align-items: center; justify-content: center; background-color: #eee; min-height: 30vh; max-height:60vh; width: 100%;}
        .image-display img { max-width: 100%; max-height: 58vh; border: 1px solid black; object-fit: contain; }
        .image-display p.preview-instruction { padding: 20px; color: #555; }
        button { margin: 5px; padding: 10px 15px; font-size: 16px; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 4px; }
        button:hover { background-color: #0056b3; }
        .control-group { margin-bottom: 15px; }
        .coarse-selection button { background-color: #6c757d;}
        .coarse-selection button:hover { background-color: #5a6268;}
        .fine-tuning input[type="range"] { width: 80%; max-width: 400px; margin-top: 10px;}
        .hidden { display: none !important; }
        #mainMenu button, #parameterSelector button { margin-bottom:10px; width: 200px;}
        #resultsDisplay ul { list-style-type: none; padding: 0;}
        #resultsDisplay li { margin-bottom: 5px; text-align: left; }
        #resultsDisplay li strong { display: block; margin-top: 10px; }
        .back-button { background-color: #6c757d; margin-top: 20px; }
        .back-button:hover { background-color: #545b62; }
        #fixationScreen, #preVimImageScreenDiv, #holdImageInstructionScreen, #conditionInstructionScreen { 
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            width: 100%; min-height: 60vh; font-size: 18px; line-height: 1.6;
        }
        #conditionInstructionScreen p { max-width: 80%; margin-bottom: 20px; }
        #fixationCross { font-size: 48px; }
        #preVimImageScreenDiv img { max-width: 90%; max-height: 50vh; border: 1px solid #ddd; margin-bottom: 15px; }
        .keyboard-focus { outline: 3px solid dodgerblue; box-shadow: 0 0 8px dodgerblue; }
        #paramButtonsContainer { display: flex; flex-direction: column; align-items: center; }
        #paramButtonsContainer button { width: 80%; margin-bottom: 10px; }
        #languageSelector { position: absolute; top: 10px; right: 10px; z-index: 100; }
        #languageSelector button { font-size: 14px; padding: 5px 10px; width: auto; background-color: #f8f9fa; color: #333; border: 1px solid #ddd; }
        #languageSelector button.active-lang { background-color: #007bff; color: white; border-color: #007bff;}
    </style>
</head>
<body id="htmlTag" lang="en">

    <div id="languageSelector">
        <button data-lang="en">English</button>
        <button data-lang="es">Español</button>
    </div>

    <div id="mainMenu" class="main-container">
        <h1 data-lang-key="mainMenuTitle"></h1>
        <p data-lang-key="mainMenuWelcome"></p>
        <button id="testParameterBtn" data-lang-key="testParamButton"></button><br>
        <button id="startActualTaskBtn" data-lang-key="startTaskButton"></button>
    </div>

    <div id="parameterSelector" class="main-container hidden">
        <h2 data-lang-key="paramSelectorTitle"></h2>
        <div id="paramButtonsContainer"></div>
        <button id="backToMenuFromTestSelectBtn" class="back-button" data-lang-key="backToMenuButton"></button>
    </div>

    <div id="conditionInstructionScreen" class="main-container hidden">
        <h2 id="conditionInstructionTitle"></h2>
        <p id="conditionInstructionText"></p>
        <button id="startTrialFromInstructionsBtn" data-lang-key="trialContinueButton"></button>
    </div>

    <div id="preVimScreenContainer" class="main-container hidden"> 
        <div id="fixationScreen" class="hidden"><div id="fixationCross">+</div></div>
        <div id="preVimImageScreenDiv" class="hidden"><img id="originalImageDisplay" src="" alt="Original Image"></div>
        <div id="holdImageInstructionScreen" class="hidden">
             <p id="holdImagePrompt"></p>
             <button id="holdImageContinueBtn" data-lang-key="trialContinueButton"></button>
        </div>
    </div>
    
    <div id="vimTaskInterface" class="main-container hidden">
        <h2 id="currentParamDisplay">Parameter: <span></span></h2>
        <p id="vimGeneralInstruction"></p> 
        <div id="coarseStep" class="coarse-selection control-group">
            <p><span data-lang-key="vimCoarsePrompt"></span> <strong id="coarseParamName"></strong>:</p>
            <button data-level-key="low"><span data-lang-key="coarseButtonLow"></span></button>
            <button data-level-key="mid"><span data-lang-key="coarseButtonMid"></span></button>
            <button data-level-key="high"><span data-lang-key="coarseButtonHigh"></span></button>
            <div class="image-display" id="coarseImageDisplay">
                <p class="preview-instruction" data-lang-key="coarsePreviewText"></p> 
                <img id="coarsePreviewImg" src="" alt="Press Arrow/Hover Mouse">
            </div>
        </div>
        <div id="fineTuneStep" class="fine-tuning control-group hidden">
            <p><span data-lang-key="fineTunePrompt"></span> <strong id="fineTuneParamName"></strong>:</p>
            <div class="image-display"><img id="fineTuneImg" src="" alt="Fine-tuned image"></div>
            <input type="range" id="fineTuneSlider" min="1" max="7" value="4">
            <p><span data-lang-key="selectedLevelLabel"></span> <span id="fineTuneLevelDisplay"></span></p>
            <button id="backToCoarseBtn" data-lang-key="backToCoarseButton"></button>
            <button id="confirmSelectionBtn" data-lang-key="confirmLevelButton"></button>
        </div>
        <button id="backToMenuFromTaskBtn" class="back-button" data-lang-key="exitTaskButton"></button>
    </div>

    <div id="resultsDisplay" class="main-container hidden">
        <h2 data-lang-key="resultsTitle"></h2>
        <ul id="resultsList"></ul>
        <button id="backToMenuFromResultsBtn" class="back-button" data-lang-key="backToMenuButton"></button>
    </div>

    <script>
        // --- CONFIGURATION AND STATE MANAGEMENT ---
        const LANG_STRINGS = {
            "en": {
                mainMenuTitle: "Visual Quality Rating Task", mainMenuWelcome: "Welcome! Please read the general instructions before starting.", testParamButton: "Test Single Parameter", startTaskButton: "Start Full Task (9 Trials)", paramSelectorTitle: "Select Parameter to Test", conditionInstructionTitle: "Instructions: {condition} Task", trialContinueButton: "Continue", holdImagePrompt_recall: "Please keep the image you just saw in your mind. Press Continue when ready.", holdImagePrompt_imagine: "Once you have formed a clear mental image of the scene as instructed, press Continue.", vimGeneralInstruction: "Please keep the image of your {sceneType} in your mind.", vimCoarsePrompt: "Select the image that best represents the overall level for", coarseButtonLow: "Low", coarseButtonMid: "Medium", coarseButtonHigh: "High", coarsePreviewText: "Hover over buttons to preview, click to select.", fineTunePrompt: "Now, fine-tune your selection for", selectedLevelLabel: "Selected Level:", backToCoarseButton: "Back to Coarse Selection", confirmLevelButton: "Confirm This Level", backToMenuButton: "Back to Main Menu", exitTaskButton: "Back to Main Menu (Exit Task)", exitConfirmMessage: "Are you sure you want to exit the current task and return to the main menu? Progress will be lost.", resultsTitle: "Trial Results"
            },
            "es": {
                mainMenuTitle: "Tarea de Calificación de Calidad Visual", mainMenuWelcome: "¡Bienvenido/a! Por favor, lea las instrucciones generales antes de comenzar.", testParamButton: "Probar un Parámetro", startTaskButton: "Comenzar Tarea Completa (9 Ensayos)", paramSelectorTitle: "Seleccione el Parámetro a Probar", conditionInstructionTitle: "Instrucciones: Tarea de {condition}", trialContinueButton: "Continuar", holdImagePrompt_recall: "Por favor, mantenga la imagen que acaba de ver en su mente. Presione Continuar cuando esté listo/a.", holdImagePrompt_imagine: "Una vez que haya formado una imagen mental clara de la escena como se le indicó, presione Continuar.", vimGeneralInstruction: "Por favor, mantenga la imagen de su {sceneType} en su mente.", vimCoarsePrompt: "Seleccione la imagen que mejor represente el nivel general para", coarseButtonLow: "Bajo", coarseButtonMid: "Medio", coarseButtonHigh: "Alto", coarsePreviewText: "Pase el cursor sobre los botones para previsualizar, haga clic para seleccionar.", fineTunePrompt: "Ahora, ajuste su selección para", selectedLevelLabel: "Nivel Seleccionado:", backToCoarseButton: "Volver a Selección General", confirmLevelButton: "Confirmar este Nivel", backToMenuButton: "Volver al Menú Principal", exitTaskButton: "Volver al Menú Principal (Salir de la Tarea)", exitConfirmMessage: "¿Está seguro/a de que desea salir de la tarea actual y volver al menú principal? El progreso se perderá.", resultsTitle: "Resultados de los Ensayos"
            }
        };
        const PARAMETERS = {
            saturation:   { name: {en: "Saturation", es: "Saturación"}, levels: 21, coarse: { low: 4, mid: 11, high: 18 }, parameter_specific_instruction: {en: "how colorful or saturated it was.", es: "qué tan colorido o saturado era."}},
            brightness:   { name: {en: "Brightness", es: "Brillo"}, levels: 21, coarse: { low: 4, mid: 11, high: 18 }, parameter_specific_instruction: {en: "how bright or dim it appeared.", es: "qué tan brillante u oscuro parecía."}},
            contrast:     { name: {en: "Contrast", es: "Contraste"}, levels: 21, coarse: { low: 4, mid: 11, high: 18 }, parameter_specific_instruction: {en: "the difference between light and dark areas.", es: "la diferencia entre áreas claras y oscuras."}},
            blurriness:   { name: {en: "Blurriness", es: "Desenfoque"}, levels: 21, coarse: { low: 4, mid: 11, high: 18 }, parameter_specific_instruction: {en: "how sharp or out-of-focus it was.", es: "qué tan nítido o desenfocado estaba."}},
            detailedness: { name: {en: "Detailedness", es: "Nivel de Detalle"}, levels: 21, coarse: { low: 4, mid: 11, high: 18 }, parameter_specific_instruction: {en: "how rich in fine features and textures it was.", es: "qué tan rico en detalles finos y texturas era."}},
            precision:    { name: {en: "Color Precision", es: "Precisión de Color"}, levels: 21, coarse: { low: 4, mid: 11, high: 18 }, parameter_specific_instruction: {en: "how specific or ambiguous the colors were.", es: "qué tan específicos o ambiguos eran los colores."}}
        };
        const allTrialsMasterList = [
            { trial_id: 1, condition: "perceptual_recall", base_image_id: "image01", original_image_filename: "image01.png", condition_instruction: {en: "You will be shown an image for a few seconds. Please observe it carefully. After it disappears, try to keep a vivid mental picture of that image in your mind.", es: "Se le mostrará una imagen por unos segundos. Por favor, obsérvela con atención. Cuando desaparezca, intente mantener una imagen mental vívida de esa imagen en su mente."}},
            { trial_id: 2, condition: "episodic_recall",   base_image_id: "image02", original_image_filename: "image02.png", condition_instruction: {en: "Please recall a recent, vivid memory of being in a LIVING ROOM with other people present. Form a clear mental image of this scene, then press Continue.", es: "Por favor, recuerde una memoria reciente y vívida de estar en una SALA DE ESTAR con otras personas presentes. Forme una imagen mental clara de esta escena, y luego presione Continuar."}},
            { trial_id: 3, condition: "scene_imagination", base_image_id: "image03", original_image_filename: "image03.png", condition_instruction: {en: "Please imagine a CLASSROOM with desks and empty chairs, with no people present. Form a clear mental image of this scene, then press Continue.", es: "Por favor, imagine un AULA con escritorios y sillas vacías, sin gente. Forme una imagen mental clara de esta escena, y luego presione Continuar."}},
            { trial_id: 4, condition: "perceptual_recall", base_image_id: "image04", original_image_filename: "image04.png", condition_instruction: {en: "You will be shown an image for a few seconds. Please observe it carefully. After it disappears, try to keep a vivid mental picture of that image in your mind.", es: "Se le mostrará una imagen por unos segundos. Por favor, obsérvela con atención. Cuando desaparezca, intente mantener una imagen mental vívida de esa imagen en su mente."}},
            { trial_id: 5, condition: "episodic_recall",   base_image_id: "image05", original_image_filename: "image05.png", condition_instruction: {en: "Please recall a recent and vivid memory of being in an empty SUPERMARKET AISLE. Form a clear mental image of this scene, then press Continue.", es: "Por favor, recuerde una memoria reciente y vívida de estar en un PASILLO DE SUPERMERCADO vacío. Forme una imagen mental clara de esta escena, y luego presione Continuar."}},
            { trial_id: 6, condition: "scene_imagination", base_image_id: "image06", original_image_filename: "image06.png", condition_instruction: {en: "Please imagine a PARK with green grass, where people are present. Form a clear mental image of this scene, then press Continue.", es: "Por favor, imagine un PARQUE con césped verde, donde hay gente presente. Forme una imagen mental clara de esta escena, y luego presione Continuar."}},
            { trial_id: 7, condition: "perceptual_recall", base_image_id: "image07", original_image_filename: "image07.png", condition_instruction: {en: "You will be shown an image for a few seconds. Please observe it carefully. After it disappears, try to keep a vivid mental picture of that image in your mind.", es: "Se le mostrará una imagen por unos segundos. Por favor, obsérvela con atención. Cuando desaparezca, intente mantener una imagen mental vívida de esa imagen en su mente."}},
            { trial_id: 8, condition: "episodic_recall",   base_image_id: "image08", original_image_filename: "image08.png", condition_instruction: {en: "Please recall a recent and vivid memory of being in a quiet LIVING ROOM with no other people present. Form a clear mental image of this scene, then press Continue.", es: "Por favor, recuerde una memoria reciente y vívida de estar en una SALA DE ESTAR tranquila sin otras personas presentes. Forme una imagen mental clara de esta escena, y luego presione Continuar."}},
            { trial_id: 9, condition: "scene_imagination", base_image_id: "image09", original_image_filename: "image09.png", condition_instruction: {en: "Please imagine a FARM scene with trees, animals, and people. Form a clear mental image of this scene, then press Continue.", es: "Por favor, imagine una escena de GRANJA con árboles, animales y personas. Forme una imagen mental clara de esta escena, y luego presione Continuar."}}
        ];
        
        let currentLanguage = 'en';
        const imageBaseFolder = "images"; 
        const imageExtension = ".png";
        const fineTuneRange = 3; 
        let currentSessionTrials = []; 
        let currentGlobalTrialIndex = 0; 
        let currentTrialData = null;     
        let currentTrialResponses = {};  
        let allCollectedResponses = [];  
        let currentTaskMode = null; 
        let currentParameterKey = null;
        let currentParameterConfig = null;
        let actualTaskOrder = []; 
        let currentParameterIndexInTask = 0; 
        let currentFocusableElements = [];
        let currentFocusedIndex = -1;      
        const KEYBOARD_FOCUS_CLASS = 'keyboard-focus';
        const isTouchDevice = (('ontouchstart' in window) || (navigator.maxTouchPoints > 0));

        // --- DOM Elements ---
        const mainMenuDiv = document.getElementById('mainMenu');
        const parameterSelectorDiv = document.getElementById('parameterSelector');
        const paramButtonsContainer = document.getElementById('paramButtonsContainer');
        const vimTaskInterfaceDiv = document.getElementById('vimTaskInterface');
        const resultsDisplayDiv = document.getElementById('resultsDisplay');
        const conditionInstructionScreenDiv = document.getElementById('conditionInstructionScreen');
        const conditionInstructionTitleH2 = document.getElementById('conditionInstructionTitle');
        const conditionInstructionTextP = document.getElementById('conditionInstructionText');
        const startTrialFromInstructionsBtn = document.getElementById('startTrialFromInstructionsBtn');
        const preVimScreenContainerDiv = document.getElementById('preVimScreenContainer');
        const fixationScreenDiv = document.getElementById('fixationScreen');
        const preVimImageScreenDiv = document.getElementById('preVimImageScreenDiv');
        const originalImageDisplayImg = document.getElementById('originalImageDisplay');
        const holdImageInstructionScreenDiv = document.getElementById('holdImageInstructionScreen');
        const holdImagePromptP = document.getElementById('holdImagePrompt');
        const holdImageContinueBtn = document.getElementById('holdImageContinueBtn');
        const vimGeneralInstructionP = document.getElementById('vimGeneralInstruction');
        const currentParamDisplay = document.getElementById('currentParamDisplay').querySelector('span');
        const coarseStepDiv = document.getElementById('coarseStep');
        const coarseParamNameStrong = document.getElementById('coarseParamName');
        const coarseButtons = coarseStepDiv.querySelectorAll('button');
        const coarsePreviewImg = document.getElementById('coarsePreviewImg');
        const coarseImageDisplayP = coarseStepDiv.querySelector('#coarseImageDisplay p.preview-instruction'); 
        const paramNameInlineSpans = document.querySelectorAll('.param-name-inline');
        const fineTuneStepDiv = document.getElementById('fineTuneStep');
        const fineTuneParamNameStrong = document.getElementById('fineTuneParamName');
        const fineTuneImg = document.getElementById('fineTuneImg');
        const fineTuneSlider = document.getElementById('fineTuneSlider');
        const fineTuneLevelDisplay = document.getElementById('fineTuneLevelDisplay');
        const backToCoarseBtn = document.getElementById('backToCoarseBtn');
        const confirmSelectionBtn = document.getElementById('confirmSelectionBtn');
        const resultsListUl = document.getElementById('resultsList');
        const backToMenuFromTestSelectBtn = document.getElementById('backToMenuFromTestSelectBtn');
        const backToMenuFromTaskBtn = document.getElementById('backToMenuFromTaskBtn');
        const backToMenuFromResultsBtn = document.getElementById('backToMenuFromResultsBtn');

        let currentCoarseSelectionLevel = null;
        let sliderToActualLevelMap = [];

        // --- Utility Functions ---
        function shuffleArray(array) { 
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        function getVariantImagePath(baseImageId, paramKey, level) { 
            const levelStr = level < 10 ? '0' + level : level.toString();
            return `${imageBaseFolder}/${paramKey}/${baseImageId}_${paramKey}_${levelStr}${imageExtension}`;
        }

        function getOriginalImagePath(originalFilename) { 
            return `${imageBaseFolder}/originals/${originalFilename}`;
         }
        
        function resetFullTaskState() { 
            currentTrialData = null;
            currentTrialResponses = {};
            currentTaskMode = null;
            currentParameterKey = null;
            currentParameterConfig = null;
            actualTaskOrder = [];
            currentParameterIndexInTask = 0;
            currentSessionTrials = [];
            currentGlobalTrialIndex = 0;
            allCollectedResponses = []; 
            console.log("Full task state reset.");
        }

        function updateKeyboardFocus(newIndex) {
            if (currentFocusableElements && currentFocusableElements[currentFocusedIndex]) {
                currentFocusableElements[currentFocusedIndex].classList.remove(KEYBOARD_FOCUS_CLASS);
            }
            currentFocusedIndex = newIndex;
            if (currentFocusableElements && currentFocusableElements[currentFocusedIndex]) {
                currentFocusableElements[currentFocusedIndex].classList.add(KEYBOARD_FOCUS_CLASS);
                currentFocusableElements[currentFocusedIndex].focus(); // Also set browser focus
            }
        }

        function setupMainMenuFocus() {
            currentFocusableElements = [document.getElementById('testParameterBtn'), document.getElementById('startActualTaskBtn')];
            updateKeyboardFocus(0);
        }
        
        function setupParameterSelectorFocus() {
            currentFocusableElements = Array.from(paramButtonsContainer.querySelectorAll('button'));
            updateKeyboardFocus(currentFocusableElements.length > 0 ? 0 : -1);
        }
        
        function setupCoarseStepFocus() {
            currentFocusableElements = Array.from(coarseStepDiv.querySelectorAll('button[data-level-key]'));
            let initialFocus = currentFocusableElements.length > 1 ? 1 : (currentFocusableElements.length === 1 ? 0 : -1);
            updateKeyboardFocus(initialFocus);
            if (initialFocus !== -1 && !isTouchDevice) {
                currentFocusableElements[initialFocus].dispatchEvent(new Event('mouseover'));
            }
        }

        
        function showDiv(divToShow) { 
            [mainMenuDiv, parameterSelectorDiv, vimTaskInterfaceDiv, resultsDisplayDiv, 
            preVimScreenContainerDiv, conditionInstructionScreenDiv].forEach(div => {
                if(div) div.classList.add('hidden');
            });

            if (currentFocusableElements && currentFocusableElements[currentFocusedIndex]) {
                currentFocusableElements[currentFocusedIndex].classList.remove(KEYBOARD_FOCUS_CLASS);
            }
            currentFocusableElements = []; currentFocusedIndex = -1;

            if (divToShow) {
                divToShow.classList.remove('hidden');
                if (divToShow === mainMenuDiv) setupMainMenuFocus();
                else if (divToShow === parameterSelectorDiv) setupParameterSelectorFocus();
                else if (divToShow === conditionInstructionScreenDiv) {
                    currentFocusableElements = [startTrialFromInstructionsBtn];
                    updateKeyboardFocus(0);
                } else if (divToShow === vimTaskInterfaceDiv && !coarseStepDiv.classList.contains('hidden')) {
                    setupCoarseStepFocus();
                }
            }
        }
        
        // --- LANGUAGE SWITCHING ---
        function setLanguage(lang) {
            currentLanguage = lang;
            document.getElementById('htmlTag').lang = lang; 

            document.querySelectorAll('#languageSelector button').forEach(btn => {
                btn.classList.toggle('active-lang', btn.dataset.lang === lang);
            });

            document.querySelectorAll('[data-lang-key]').forEach(el => {
                const key = el.dataset.langKey;
                if (LANG_STRINGS[currentLanguage] && LANG_STRINGS[currentLanguage][key]) {
                    el.textContent = LANG_STRINGS[currentLanguage][key];
                }
            });

            if (!parameterSelectorDiv.classList.contains('hidden')) {
                populateParameterSelector();
            }
        }

        // --- Core Application Logic ---

        function showConditionInstructions(trialDataObject) {
            currentTrialData = trialDataObject; 
            if (!currentTrialData) {
                console.error("showConditionInstructions called with invalid trialData!");
                return;
            }

            const conditionName = {
                en: currentTrialData.condition.replace(/_/g, ' '),
                es: currentTrialData.condition === "perceptual_recall" ? "Recuerdo Perceptual" : 
                    currentTrialData.condition === "episodic_recall" ? "Recuerdo Episódico" : "Imaginación de Escena"
            }[currentLanguage];

            let titlePrefix = currentTaskMode === 'test' ? "Test Mode" : `Trial ${currentGlobalTrialIndex + 1} of ${currentSessionTrials.length}`;
            conditionInstructionTitleH2.textContent = `${titlePrefix}: ${conditionName}`;
            conditionInstructionTextP.textContent = currentTrialData.condition_instruction[currentLanguage];
            showDiv(conditionInstructionScreenDiv);
            currentFocusableElements = [startTrialFromInstructionsBtn];
            updateKeyboardFocus(0);
        }

        startTrialFromInstructionsBtn.addEventListener('click', () => {
            if (!currentTrialData) return;
            if (currentTaskMode === 'test') {
                 showDiv(null); 
                 startVimParameterRating(); 
            } else if (currentTaskMode === 'actual_task_full') {
                if (currentTrialData.condition === "perceptual_recall") {
                    startPreVimPhase(currentTrialData);
                } else { 
                    currentTrialResponses = { 
                        trial_id: currentTrialData.trial_id, condition: currentTrialData.condition,
                        image_id: currentTrialData.base_image_id, parameter_responses: {}
                    };
                    showDiv(null);
                    startVimParameterRating();
                }
            }
        });

        // --- Pre-VIM Task Flow ---
        // ** FIXED startPreVimPhase **
        function startPreVimPhase(trialData) {
            currentTrialResponses = { 
                trial_id: trialData.trial_id, condition: trialData.condition,
                image_id: trialData.base_image_id, parameter_responses: {}
            };
            showDiv(preVimScreenContainerDiv);
            holdImageInstructionScreenDiv.classList.add('hidden');
            preVimImageScreenDiv.classList.add('hidden');
            fixationScreenDiv.classList.remove('hidden'); 
            
            setTimeout(() => { 
                fixationScreenDiv.classList.add('hidden');
                preVimImageScreenDiv.classList.remove('hidden');
                originalImageDisplayImg.src = getOriginalImagePath(trialData.original_image_filename);
                
                setTimeout(() => { 
                    preVimImageScreenDiv.classList.add('hidden');
                    originalImageDisplayImg.src = ""; 
                    holdImageInstructionScreenDiv.classList.remove('hidden');
                    holdImagePromptP.textContent = LANG_STRINGS[currentLanguage].holdImagePrompt_recall;
                    holdImageContinueBtn.classList.remove('hidden');
                }, 4000); // Image display duration
            }, 1000); // Initial fixation duration
        }

        holdImageContinueBtn.addEventListener('click', () => {
            showDiv(null); 
            startVimParameterRating(); 
        });

        // --- VIM Parameter Rating Functions ---
        function startVimParameterRating() { 
            if(currentTaskMode === 'test' && currentParameterKey){ 
                 actualTaskOrder = [currentParameterKey]; 
            } else if (currentTaskMode && currentTaskMode.startsWith('actual')) { 
                 actualTaskOrder = shuffleArray(Object.keys(PARAMETERS)); 
            } else {
                resetFullTaskState(); showDiv(mainMenuDiv); return;
            }
            const sceneTypeString = {
                en: currentTrialData.condition === "perceptual_recall" ? "recalled photo" : "mental scene",
                es: currentTrialData.condition === "perceptual_recall" ? "foto recordada" : "escena mental"
            }[currentLanguage];
            vimGeneralInstructionP.textContent = LANG_STRINGS[currentLanguage].vimGeneralInstruction.replace('{sceneType}', sceneTypeString);
            currentParameterIndexInTask = 0;
            loadNextParameterInVim();
        }

        function loadNextParameterInVim() { 
             if (currentParameterIndexInTask < actualTaskOrder.length) {
                currentParameterKey = actualTaskOrder[currentParameterIndexInTask];
                currentParameterConfig = PARAMETERS[currentParameterKey];
                showDiv(vimTaskInterfaceDiv); 
                setupCoarseStepVim(); 
            } else {
                if (currentTaskMode === 'test') {
                    alert(`Test complete for ${PARAMETERS[currentParameterKey].name[currentLanguage]}`);
                    showDiv(parameterSelectorDiv);
                } else if (currentTaskMode === 'actual_task_full') { 
                    allCollectedResponses.push({...currentTrialResponses}); 
                    currentGlobalTrialIndex++;
                    if (currentGlobalTrialIndex < currentSessionTrials.length) {
                        showConditionInstructions(currentSessionTrials[currentGlobalTrialIndex]); 
                    } else {
                        displayFullResults(); 
                    }
                }
            }
        }
        
        function setupCoarseStepVim() { 
            const paramName = currentParameterConfig.name[currentLanguage];
            currentParamDisplay.textContent = paramName;
            coarseParamNameStrong.textContent = currentParameterConfig.parameter_specific_instruction[currentLanguage]; 
            fineTuneParamNameStrong.textContent = currentParameterConfig.parameter_specific_instruction[currentLanguage];
            paramNameInlineSpans.forEach(span => span.textContent = ""); // Clear old param names
            coarseButtons.forEach(button => {
                const span = button.querySelector('.param-name-inline');
                if(span) span.textContent = paramName.toLowerCase();
            });
            coarseButtons.forEach(button => {
                const levelKey = button.dataset.levelKey;
                button.dataset.level = currentParameterConfig.coarse[levelKey];
            });
            coarsePreviewImg.src = ""; // Clear preview
            coarseImageDisplayP.classList.remove('hidden');
            coarseStepDiv.classList.remove('hidden');
            fineTuneStepDiv.classList.add('hidden');
            setupCoarseStepFocus();
        }

        function setupFineTuneStepVim(coarseLevelValue) {
            currentCoarseSelectionLevel = coarseLevelValue;
            fineTuneParamNameStrong.textContent = currentParameterConfig.parameter_specific_instruction[currentLanguage]; 
            const totalParamLevels = currentParameterConfig.levels;
            let minL = Math.max(1, coarseLevelValue - fineTuneRange);
            let maxL = Math.min(totalParamLevels, coarseLevelValue + fineTuneRange);
            sliderToActualLevelMap = [];
            for (let i = minL; i <= maxL; i++) { sliderToActualLevelMap.push(i); }
            fineTuneSlider.min = 1;
            fineTuneSlider.max = sliderToActualLevelMap.length;
            const initialSliderIndex = sliderToActualLevelMap.indexOf(coarseLevelValue);
            fineTuneSlider.value = initialSliderIndex !== -1 ? initialSliderIndex + 1 : Math.ceil(sliderToActualLevelMap.length / 2);
            updateFineTuneImageVim(fineTuneSlider.value);
            coarseStepDiv.classList.add('hidden');
            fineTuneStepDiv.classList.remove('hidden');
            fineTuneSlider.focus(); 
            currentFocusableElements = [fineTuneSlider, backToCoarseBtn, confirmSelectionBtn];
            updateKeyboardFocus(0); 
         }

        function updateFineTuneImageVim(sliderValStr) { /* ... same ... */ 
            const sliderValue = parseInt(sliderValStr);
            const actualLevel = sliderToActualLevelMap[sliderValue - 1];
            if (actualLevel !== undefined && currentTrialData && currentParameterKey) { 
                fineTuneImg.src = getVariantImagePath(currentTrialData.base_image_id, currentParameterKey, actualLevel);
                fineTuneLevelDisplay.textContent = actualLevel;
            }
        }
       
        // --- Start/Setup Functions ---
        function populateParameterSelector() { 
            paramButtonsContainer.innerHTML = ''; 
            Object.keys(PARAMETERS).forEach(key => {
                const button = document.createElement('button');
                button.textContent = `${LANG_STRINGS[currentLanguage].testParamButton.split(' ')[0]} ${PARAMETERS[key].name[currentLanguage]}`;
                button.addEventListener('click', () => startParameterTest(key));
                paramButtonsContainer.appendChild(button);
            });
            setupParameterSelectorFocus(); 
        }

        // ** FIXED startParameterTest **
        function startParameterTest(paramKey) {  
            resetFullTaskState(); 
            currentTaskMode = 'test';
            currentParameterKey = paramKey; 
            currentParameterConfig = PARAMETERS[paramKey]; 
            
            // Set a valid trial context for the test.
            currentTrialData = {
                trial_id: "TestRun",
                condition: "Parameter Test",
                base_image_id: allTrialsMasterList.length > 0 ? allTrialsMasterList[0].base_image_id : "image01"
            };
            
            // Set the general instruction text for the VIM interface
            const sceneTypeString = "test scene";
            vimGeneralInstructionP.textContent = LANG_STRINGS[currentLanguage].vimGeneralInstruction.replace('{sceneType}', sceneTypeString);

            // Directly show and set up the VIM interface at the coarse step
            showDiv(vimTaskInterfaceDiv);
            setupCoarseStepVim();
        }

        function startActualTask() {
            resetFullTaskState(); 
            currentTaskMode = 'actual_task_full';
            currentSessionTrials = shuffleArray(allTrialsMasterList); 
            currentGlobalTrialIndex = 0;
            allCollectedResponses = []; 
            if (currentSessionTrials.length > 0) {
                showConditionInstructions(currentSessionTrials[0]); 
            } else { alert("No trials defined in master list."); }
        }

        function displayFullResults() { /* ... same ... */
            resultsListUl.innerHTML = ''; 
            allCollectedResponses.forEach(trialResp => {
                const trialHeader = document.createElement('li');
                trialHeader.innerHTML = `<strong>Trial ${trialResp.trial_id} (${trialResp.condition}, Image: ${trialResp.image_id})</strong>`;
                resultsListUl.appendChild(trialHeader);

                for (const paramKeyInResp in trialResp.parameter_responses) { // Iterate over keys in parameter_responses
                    const listItem = document.createElement('li');
                    listItem.style.paddingLeft = "20px";
                    listItem.textContent = `${PARAMETERS[paramKeyInResp].name}: Level ${trialResp.parameter_responses[paramKeyInResp]}`;
                    resultsListUl.appendChild(listItem);
                }
                resultsListUl.appendChild(document.createElement('hr')); 
            });
            showDiv(resultsDisplayDiv);
            console.log("All Collected Responses:", JSON.stringify(allCollectedResponses, null, 2));
         }


        // --- EVENT LISTENERS ---
        document.addEventListener('DOMContentLoaded', () => {
            resetFullTaskState(); 
            setLanguage('en'); 
            showDiv(mainMenuDiv);
            if(isTouchDevice) document.body.classList.add('touch-device');
        });

        // Language Buttons
        document.querySelectorAll('#languageSelector button').forEach(button => {
            button.addEventListener('click', () => setLanguage(button.dataset.lang));
        });

        // Main Menu Buttons
        document.getElementById('testParameterBtn').addEventListener('click', () => {
            resetFullTaskState(); 
            populateParameterSelector();
            showDiv(parameterSelectorDiv);
        });
        document.getElementById('startActualTaskBtn').addEventListener('click', startActualTask);
        
        // Back Buttons
        backToMenuFromTestSelectBtn.addEventListener('click', () => { resetFullTaskState(); showDiv(mainMenuDiv); });
        backToMenuFromTaskBtn.addEventListener('click', () => {
            let confirmExit = currentTaskMode === 'test' ? true : confirm(LANG_STRINGS[currentLanguage].exitConfirmMessage);
            if (confirmExit) {
                resetFullTaskState();
                showDiv(mainMenuDiv);
            }
        }); 
        backToMenuFromResultsBtn.addEventListener('click', () => { resetFullTaskState(); showDiv(mainMenuDiv); });

        coarseButtons.forEach(button => {
            button.addEventListener('mouseover', () => {
                if (!currentParameterConfig || coarseStepDiv.classList.contains('hidden') || !currentTrialData) return;
                const buttonIndex = Array.from(coarseButtons).indexOf(button);
                if (buttonIndex !== currentFocusedIndex) updateKeyboardFocus(buttonIndex);
                const level = parseInt(button.dataset.level);
                coarsePreviewImg.src = getVariantImagePath(currentTrialData.base_image_id, currentParameterKey, level);
                if(coarseImageDisplayP) coarseImageDisplayP.classList.add('hidden');
            });
            button.addEventListener('click', () => {
                if (!currentParameterConfig) return;
                setupFineTuneStepVim(parseInt(button.dataset.level)); 
            });
        });

        // --- This is the new, self-contained keyboard handler ---
        document.addEventListener('keydown', (event) => {
            if (document.activeElement.tagName === 'INPUT' && document.activeElement.type !== 'range') return;
            
            if (event.key === "Escape") {
                event.preventDefault();
                const visibleBackButton = document.querySelector('.main-container:not(.hidden) .back-button');
                if (visibleBackButton) visibleBackButton.click();
                return;
            }

            // Route to specific handlers based on which screen is active
            if (!mainMenuDiv.classList.contains('hidden')) handleMainMenuKeys(event);
            else if (!parameterSelectorDiv.classList.contains('hidden')) handleParameterSelectorKeys(event);
            else if (!conditionInstructionScreenDiv.classList.contains('hidden') && event.key === "Enter") { event.preventDefault(); startTrialFromInstructionsBtn.click(); }
            else if (!holdImageInstructionScreenDiv.classList.contains('hidden') && event.key === "Enter") { event.preventDefault(); holdImageContinueBtn.click(); }
            else if (!vimTaskInterfaceDiv.classList.contains('hidden')) handleVimTaskInterfaceKeys(event);
        });

        // --- All other specific button clicks ---
        coarseButtons.forEach(button => {
            button.addEventListener('mouseover', () => {
                if(isTouchDevice) return;
                const buttonIndex = Array.from(coarseButtons).indexOf(button);
                if (buttonIndex !== currentFocusedIndex) updateKeyboardFocus(buttonIndex);
                triggerCoarsePreview(button);
            });
            button.addEventListener('click', () => {
                if (!currentParameterConfig) return;
                setupFineTuneStepVim(parseInt(button.dataset.level)); 
            });
        });
        
        fineTuneSlider.addEventListener('input', (event) => { 
            if (currentTrialData && currentParameterKey) updateFineTuneImageVim(event.target.value); 
        });

        // --- EVENT LISTENERS ---

        // --- Language Selector Buttons ---
        document.querySelectorAll('#languageSelector button').forEach(button => {
            button.addEventListener('click', () => {
                setLanguage(button.dataset.lang);
            });
        });

        backToCoarseBtn.addEventListener('click', setupCoarseStepVim); 

        confirmSelectionBtn.addEventListener('click', () => {  
            if (!currentTrialData || !currentParameterKey) {
                console.error("Confirm button clicked with no trial/param context.");
                return;
            }
            const currentSliderValue = parseInt(fineTuneSlider.value);
            const finalLevel = sliderToActualLevelMap[currentSliderValue - 1];
            
            if (!currentTrialResponses.parameter_responses) {
                currentTrialResponses.parameter_responses = {};
            }
            currentTrialResponses.parameter_responses[currentParameterKey] = finalLevel;
            
            currentParameterIndexInTask++;
            loadNextParameterInVim(); 
        });

        function handleMainMenuKeys(event) {
            if (currentFocusableElements.length === 0) return;
            let handled = false;
            switch (event.key) {
                case "ArrowUp": case "ArrowDown":
                    updateKeyboardFocus(currentFocusedIndex === 0 ? 1 : 0);
                    handled = true;
                    break;
                case "Enter":
                    if (currentFocusedIndex >= 0) currentFocusableElements[currentFocusedIndex].click();
                    handled = true;
                    break;
            }
            if (handled) event.preventDefault();
        }

        function handleParameterSelectorKeys(event) {
            if (currentFocusableElements.length === 0) return;
            let handled = false;
            switch (event.key) {
                case "ArrowUp":
                    updateKeyboardFocus(currentFocusedIndex > 0 ? currentFocusedIndex - 1 : currentFocusableElements.length - 1);
                    handled = true;
                    break;
                case "ArrowDown":
                    updateKeyboardFocus(currentFocusedIndex < currentFocusableElements.length - 1 ? currentFocusedIndex + 1 : 0);
                    handled = true;
                    break;
                case "Enter":
                    if (currentFocusedIndex >= 0) currentFocusableElements[currentFocusedIndex].click();
                    handled = true;
                    break;
                case "Backspace": 
                    backToMenuFromTestSelectBtn.click();
                    handled = true;
                    break;
            }
            if (handled) event.preventDefault();
        }

        function handleVimTaskInterfaceKeys(event) {
            let handled = false;
            if (!coarseStepDiv.classList.contains('hidden')) { 
                if (!currentFocusableElements || currentFocusableElements.length === 0) { 
                    return; 
                }
                
                let newFocusIndex = currentFocusedIndex;
                let arrowPressed = false;

                if (event.key === "ArrowLeft") {
                    newFocusIndex = currentFocusedIndex > 0 ? currentFocusedIndex - 1 : currentFocusableElements.length - 1;
                    arrowPressed = true; handled = true;
                } else if (event.key === "ArrowRight") {
                    newFocusIndex = currentFocusedIndex < currentFocusableElements.length - 1 ? currentFocusedIndex + 1 : 0;
                    arrowPressed = true; handled = true;
                }

                if (arrowPressed) {
                    // Update the visual focus on the button
                    updateKeyboardFocus(newFocusIndex); 

                    // --- DIRECT PREVIEW LOGIC ---
                    const focusedButton = currentFocusableElements[currentFocusedIndex]; 
                    if (focusedButton) { // Ensure the button exists
                        // This logic is copied directly from the working 'mouseover' listener
                        if (!currentParameterConfig || coarseStepDiv.classList.contains('hidden') || !currentTrialData) {
                            console.error("Context missing for keyboard preview.");
                            return; // Abort if context is not ready
                        }

                        const level = parseInt(focusedButton.dataset.level);
                        const baseImgToUse = currentTrialData.base_image_id;

                        // Check if all necessary variables have values before creating the path
                        if (baseImgToUse && currentParameterKey && !isNaN(level)) {
                             console.log("Keyboard Preview Trigger:", {base: baseImgToUse, param: currentParameterKey, level: level});
                             const imagePath = getVariantImagePath(baseImgToUse, currentParameterKey, level);
                             coarsePreviewImg.src = imagePath;
                             if(coarseImageDisplayP) coarseImageDisplayP.classList.add('hidden');
                        } else {
                            console.error("Could not generate image path for keyboard preview. Missing data:", {base: baseImgToUse, param: currentParameterKey, level: level});
                        }
                    }
                } else if (event.key === "Enter") { 
                    if (currentFocusedIndex >= 0 && currentFocusableElements[currentFocusedIndex]) {
                        currentFocusableElements[currentFocusedIndex].click(); 
                        handled = true;
                    }
                }
            } else if (!fineTuneStepDiv.classList.contains('hidden')) { 
                const sliderStep = 1; 
                const sliderIsActiveFocus = document.activeElement === fineTuneSlider;
                switch (event.key) {
                    case "ArrowLeft":
                        if (sliderIsActiveFocus) {
                            fineTuneSlider.value = parseInt(fineTuneSlider.value) - sliderStep;
                            fineTuneSlider.dispatchEvent(new Event('input')); 
                            handled = true;
                        }
                        break;
                    case "ArrowRight":
                         if (sliderIsActiveFocus) {
                            fineTuneSlider.value = parseInt(fineTuneSlider.value) + sliderStep;
                            fineTuneSlider.dispatchEvent(new Event('input')); 
                            handled = true;
                        }
                        break;
                    case "Enter":
                        confirmSelectionBtn.click();
                        handled = true;
                        break;
                    case "Backspace":
                        backToCoarseBtn.click();
                        handled = true;
                        break;
                }
            }
            if (handled) event.preventDefault();
        }

        function triggerCoarsePreview(buttonElement) {
            if (isTouchDevice) return; // Don't show previews on touch devices

            if (!currentParameterConfig || !currentTrialData) {
                console.warn("Cannot trigger coarse preview: Missing trial context.");
                return;
            }
            
            const level = parseInt(buttonElement.dataset.level);
            if(isNaN(level)) return;

            const baseImgToUse = currentTrialData.base_image_id;
            
            console.log("Triggering Preview: Base:", baseImgToUse, "Param:", currentParameterKey, "Level:", level);
            
            coarsePreviewImg.src = getVariantImagePath(baseImgToUse, currentParameterKey, level);
            if(coarseImageDisplayP) coarseImageDisplayP.classList.add('hidden');
        }

        // --- INITIAL STATE ---
        document.addEventListener('DOMContentLoaded', () => {
            resetFullTaskState(); 
            setLanguage('en'); 
            showDiv(mainMenuDiv);
            if(isTouchDevice) document.body.classList.add('touch-device');
        });
    </script>
</body>
</html>