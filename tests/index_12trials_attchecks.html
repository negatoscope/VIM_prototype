<!DOCTYPE html>
<html lang="en" id="htmlTag">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VIM Prototype - Final Corrected</title>
    <style>
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; min-height: 100vh; margin: 0; padding: 10px; box-sizing: border-box; background-color: #f4f4f4; }
        .main-container { border: 1px solid #ccc; padding: 20px; text-align: center; background-color: white; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); width: 90%; max-width: 800px; margin-top: 20px; }
        /* This is the new top-level wrapper for our split-screen view */
        /* REPLACEMENT CSS RULES */

        .split-container {
            display: flex;
            flex-direction: row;
            align-items: stretch; /* Make panels equal height */
            justify-content: center;
            gap: 20px;
            width: 100%; /* Use the full browser width */
            height: calc(100vh - 40px); /* Fill the full screen height, minus some padding */
            padding: 20px;
            box-sizing: border-box; /* Include padding in the width/height calculation */
        }

        /* We also need to remove the fixed height from the image panel to let it be flexible */
        /*.image-panel {
            flex: 1; /* This is the key: it will grow to fill all available horizontal space */
            /*display: flex;
            align-items: center;
            justify-content: center;
            background-color: #eee;
            border-radius: 8px;
            /* The explicit height is removed. It will now be controlled by the parent. */
        /*}

        /* This is the new LEFT panel, which will hold the image */
        .image-panel {
            flex: 1; 
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: #eee;
            height: 90vh; /* Increased from 85vh */
            border-radius: 8px;
            /* padding: 10px;  <-- REMOVED to maximize space */
        }

        /* This is the new RIGHT panel, for all our text and buttons */
        .controls-panel {
            /* --- Your existing properties --- */
            flex: 0 0 400px; 
            border: 1px solid #ccc;
            padding: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            height: 85vh; 
            overflow-y: auto; 
            text-align: center;
            
            /* --- The new properties to add --- */
            display: flex;
            flex-direction: column;
        }

        /* This is the generic "spacer" that will push content apart.
        This is the most important missing piece. */
        .flex-spacer {
            flex-grow: 1; /* This makes the element take up all available empty vertical space */
        }

        /* This styles the container for the buttons at the bottom */
        .controls-bottom {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* We need to update the existing .image-display rules to work inside the new panels */
        /*.image-display {
            width: 100%;
            height: 100%; 
            margin-bottom: 0; /* No longer need margin */
        /* }

        .image-display img {
            max-width: 100%;
            max-height: 100%; 
            border: 1px solid black;
            object-fit: contain;
        /*} */

        .confidence-rating {
            margin-top: 20px;
        }

        .likert-scale {
            display: flex;
            justify-content: center;
            margin: 15px 0 5px 0;
        }

        .likert-button {
            padding: 10px;
            min-width: 40px; /* Give buttons a consistent width */
            background-color: #f0f0f0;
            color: #333;
            border: 1px solid #ccc;
        }

        .likert-button:hover {
            background-color: #e0e0e0;
        }

        /* Style for the selected confidence button */
        .likert-button.selected {
            background-color: #007bff;
            color: white;
            border-color: #007bff;
        }

        .likert-labels {
            display: flex;
            justify-content: space-between;
            max-width: 350px;
            margin: 0 auto;
            font-size: 14px;
            color: #555;
        }
        .image-display { display: flex; align-items: center; justify-content: center; background-color: #eee; min-height: 30vh; max-height:100%; width: 100%;}
        .image-display img { max-width: 100%; max-height: 100%; border: 1px solid black; object-fit: contain; }
        .slider-value-display {
            display: none;
        }
        .image-display p.preview-instruction { padding: 20px; color: #555; }
        button { margin: 5px; padding: 10px 15px; font-size: 16px; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 4px; }
        button:hover { background-color: #0056b3; }
        .control-group { margin-bottom: 15px; }
        .coarse-selection button { background-color: #6c757d;}
        .coarse-selection button:hover { background-color: #5a6268;}
        .fine-tuning input[type="range"] { width: 80%; max-width: 400px; margin-top: 10px;}
        .hidden { display: none !important; }
        #mainMenu button, #parameterSelector button { margin-bottom:10px; width: 200px;}
        #resultsDisplay ul { list-style-type: none; padding: 0;}
        #resultsDisplay li { margin-bottom: 5px; text-align: left; }
        #resultsDisplay li strong { display: block; margin-top: 10px; }
        .back-button { background-color: #6c757d; margin-top: 20px; }
        .back-button:hover { background-color: #545b62; }
        #fixationScreen, #preVimImageScreenDiv, #holdImageInstructionScreen, #conditionInstructionScreen { 
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            width: 100%; min-height: 60vh; font-size: 18px; line-height: 1.6;
        }
        #conditionInstructionScreen p { max-width: 80%; margin-bottom: 20px; }
        #fixationCross { font-size: 48px; }
        #preVimImageScreenDiv img { 
            max-width: 100%; 
            max-height: 100%; /* Allows image to fill the panel's height */
            border: 1px solid #ddd; 
            object-fit: contain; /* Ensures aspect ratio is maintained */
        }
        .keyboard-focus { outline: 3px solid dodgerblue; box-shadow: 0 0 8px dodgerblue; }
        #paramButtonsContainer { display: flex; flex-direction: column; align-items: center; }
        #paramButtonsContainer button { width: 80%; margin-bottom: 10px; }
        #languageSelector { position: absolute; bottom: 10px; right: 10px; z-index: 100; }
        #languageSelector button { font-size: 14px; padding: 5px 10px; width: auto; background-color: #f8f9fa; color: #333; border: 1px solid #ddd; }
        #languageSelector button.active-lang { background-color: #007bff; color: white; border-color: #007bff;}
        /* --- NEW --- */
        #downloadResultsBtn { background-color: #28a745; margin-top: 20px; }
        #downloadResultsBtn:hover { background-color: #218838; }
        /* ADD THIS NEW RULE */
        #fineTuneActionButtons {
            display: flex;
            flex-direction: row;
            justify-content: center;
        }
    </style>
</head>
<body id="htmlTag" lang="en">

    <div id="languageSelector">
        <button data-lang="en">English</button>
        <button data-lang="es">Espa√±ol</button>
    </div>

    <div id="mainMenu" class="main-container">
        <h1 data-lang-key="mainMenuTitle"></h1>
        <p data-lang-key="mainMenuWelcome"></p>
        <button id="testParameterBtn" data-lang-key="testParamButton"></button><br>
        <button id="startActualTaskBtn" data-lang-key="startTaskButton"></button>
        <p id="setInfo" style="margin-top: 20px; font-size: 12px; color: #888;"></p>
    </div>

    <!-- ADD THIS FIRST NEW BLOCK: The Welcome Screen -->
    <div id="welcomeScreen" class="main-container hidden">
        <h1 data-lang-key="welcomeTitle">Welcome!</h1>
        <p data-lang-key="welcomeInstructions"></p>
        <button id="startInstructionsBtn" data-lang-key="continueButton">Continue</button>
    </div>

    <!-- ADD THIS SECOND NEW BLOCK: The How-To Explanation Screen -->
    <div id="howToScreen" class="main-container hidden">
        <h2 data-lang-key="howToTitle">How the Task Works</h2>
        <div style="text-align: left; max-width: 600px; margin: 20px auto;">
            <p data-lang-key="howToStep1"></p>
            <p data-lang-key="howToStep2"></p>
            <p data-lang-key="howToStep3"></p>
        </div>
        <button id="startTutorialBtn" data-lang-key="startPracticeButton">Start Practice Round</button>
    </div>

    <div id="readyScreen" class="main-container hidden">
        <h2 data-lang-key="readyTitle"></h2>
        <p data-lang-key="readyText"></p>
        <button id="startExperimentBtn" data-lang-key="startExperimentButton"></button>
    </div>

    <div id="parameterSelector" class="main-container hidden">
        <h2 data-lang-key="paramSelectorTitle"></h2>
        <div id="paramButtonsContainer"></div>
        <button id="backToMenuFromTestSelectBtn" class="back-button" data-lang-key="backToMenuButton"></button>
    </div>

    <div id="conditionInstructionScreen" class="main-container hidden">
        <h2 id="conditionInstructionTitle"></h2>
        <p id="conditionInstructionText"></p>
        <button id="startTrialFromInstructionsBtn" data-lang-key="trialContinueButton"></button>
    </div>

    <!-- This container now uses the 'split-container' class for the two-panel layout -->
    <div id="preVimScreenContainer" class="split-container hidden">

        <!-- The LEFT panel will hold the visual stimuli (fixation and image) -->
        <div class="image-panel">
            <div id="fixationScreen" class="hidden"><div id="fixationCross">+</div></div>
            <div id="preVimImageScreenDiv" class="hidden"><img id="originalImageDisplay" src="" alt="Original Image"></div>
        </div>

        <!-- The RIGHT panel will hold the text prompt and button -->
        <div class="controls-panel">
            <div id="holdImageInstructionScreen" class="hidden">
                <p id="holdImagePrompt" style="margin-top: 20vh;"></p> <!-- Added style to vertically center the prompt a bit -->
                <button id="holdImageContinueBtn" data-lang-key="trialContinueButton"></button>
            </div>
        </div>

    </div>
    
    <div id="vimTaskInterface" class="split-container hidden">

        <!-- 1. The new LEFT panel for the image -->
        <div class="image-panel">
            
            <!-- MOVE THE COARSE IMAGE DISPLAY HERE -->
            <div class="image-display" id="coarseImageDisplay">
                <p class="preview-instruction" data-lang-key="coarsePreviewText"></p> 
                <img id="coarsePreviewImg" src="" alt="Press Arrow/Hover Mouse">
            </div>

            <!-- MOVE THE FINE-TUNE IMAGE DISPLAY HERE (and hide it) -->
            <div class="image-display hidden" id="fineTuneImageDisplay">
                <img id="fineTuneImg" src="" alt="Fine-tuned image">
            </div>

        </div>

        <!-- 2. The new RIGHT panel for the controls -->
        <div class="controls-panel">
            <!-- TOP SECTION -->
            <h2 id="currentParamDisplay">Parameter: <span></span></h2>
            <p id="vimGeneralInstruction"></p> 

            <!-- ADD THIS FIRST SPACER to push the middle section down -->
            <div class="flex-spacer"></div>

            <!-- MIDDLE SECTION (Interactive Elements) -->
            <div id="coarseStep" class="coarse-selection control-group">
                <p><span data-lang-key="vimCoarsePrompt"></span> <strong id="coarseParamName"></strong>:</p>
                <button data-level-key="low"><span data-lang-key="coarseButtonLow"></span></button>
                <button data-level-key="mid"><span data-lang-key="coarseButtonMid"></span></button>
                <button data-level-key="high"><span data-lang-key="coarseButtonHigh"></span></button>
            </div>

            <div id="fineTuneStep" class="fine-tuning control-group hidden">
                <p><span data-lang-key="fineTunePrompt"></span> <strong id="fineTuneParamName"></strong>:</p>
                <input type="range" id="fineTuneSlider" min="1" max="7" value="4">
                <!-- This is the line you correctly fixed -->
                <p class="slider-value-display"><span id="fineTuneLevelDisplay"></span></p>
                <!-- NOTE: The two buttons that were here have been moved to the bottom -->
            </div>

            <!-- ADD THIS ENTIRE NEW BLOCK -->
            <div id="confidenceStep" class="confidence-rating control-group hidden">
                <p id="confidencePrompt"></p>
                <div class="likert-scale">
                    <button class="likert-button" data-value="1">1</button>
                    <button class="likert-button" data-value="2">2</button>
                    <button class="likert-button" data-value="3">3</button>
                    <button class="likert-button" data-value="4">4</button>
                    <button class="likert-button" data-value="5">5</button>
                    <button class="likert-button" data-value="6">6</button>
                    <button class="likert-button" data-value="7">7</button>
                </div>
                <div class="likert-labels">
                    <span id="likertLabelLow"></span>
                    <span id="likertLabelHigh"></span>
                </div>
            </div>

            <!-- This new spacer element pushes everything below it to the bottom -->
            <div class="flex-spacer"></div>

            <!-- BOTTOM SECTION (Action Buttons) -->
            <div class="controls-bottom">
                <!-- This new wrapper will hold the side-by-side buttons -->
                <div id="fineTuneActionButtons">
                    <button id="backToCoarseBtn" data-lang-key="backToCoarseButton"></button>
                    <button id="confirmSelectionBtn" data-lang-key="confirmLevelButton"></button>
                    <button id="confirmConfidenceBtn" data-lang-key="confirmConfidenceButton" class="hidden"></button>
                </div>
                <button id="backToMenuFromTaskBtn" class="back-button" data-lang-key="exitTaskButton"></button>
            </div>
        </div>

    </div>

    <div id="resultsDisplay" class="main-container hidden">
        <h2 data-lang-key="resultsTitle"></h2>
        <ul id="resultsList"></ul>
        <!-- --- NEW --- -->
        <p id="saveStatus" style="font-style: italic; color: #555;"></p>
        <button id="downloadResultsBtn" data-lang-key="downloadResultsButton">Download Results</button>
        <button id="backToMenuFromResultsBtn" class="back-button hidden" data-lang-key="backToMenuButton"></button>
    </div>

    <script>

        // --- CONFIGURATION AND STATE MANAGEMENT ---
        const DEBUG_SHOW_RESULTS = false; // Set to true to show results for debugging
        
        // REPLACE your existing LANG_STRINGS object

        const LANG_STRINGS = {
            "en": {
                // --- Existing Strings ---
                mainMenuTitle: "Visual Quality Rating Task", mainMenuWelcome: "Welcome! Please read the general instructions before starting.", testParamButton: "Test Single Parameter", startTaskButton: "Start Full Task (12 Trials)", paramSelectorTitle: "Select Parameter to Test", conditionInstructionTitle: "Instructions: {condition} Task", trialContinueButton: "Continue", holdImagePrompt_recall: "Please keep the image you just saw in your mind. Press Continue when ready.", holdImagePrompt_imagine: "Once you have formed a clear mental image of the scene as instructed, press Continue.", vimGeneralInstruction: "Please keep the image of your {sceneType} in your mind.", vimCoarsePrompt: "Select the image that best represents the overall level for", coarseButtonLow: "Low", coarseButtonMid: "Medium", coarseButtonHigh: "High", coarsePreviewText: "Hover over buttons to preview, click to select.", fineTunePrompt: "Now, fine-tune your selection for", selectedLevelLabel: "Selected Level:", backToCoarseButton: "Back to Coarse Selection", confirmLevelButton: "Confirm This Level", backToMenuButton: "Back to Main Menu", exitTaskButton: "Back to Main Menu (Exit Task)", exitConfirmMessage: "Are you sure you want to exit the current task and return to the main menu? Progress will be lost.", resultsTitle: "Trial Results", downloadResultsButton: "Download Results", confidencePrompt: "How confident are you in your selection?", likertLabelLow: "Not at all confident", likertLabelHigh: "Completely confident", confirmConfidenceButton: "Confirm Confidence",
                // --- New Onboarding Strings ---
                welcomeTitle: "Welcome!",
                welcomeInstructions: "Thank you for participating. This experiment investigates the nature of mental imagery. It will take approximately 15-20 minutes. You will first complete a short, interactive practice round, followed by the 12 main trials.",
                continueButton: "Continue",
                howToTitle: "How the Task Works",
                howToStep1: "1. You will be asked to remember or imagine a scene. Please try to form as clear a mental image as you can.",
                howToStep2: "2. You will then adjust an image on the screen to match the qualities of your mental image (e.g., its brightness, blurriness, etc.).",
                howToStep3: "3. After each adjustment, you will rate how confident you are in your choice.",
                startPracticeButton: "Start Practice Round",
                readyTitle: "Practice Complete",
                readyText: "You have completed the practice round. The main experiment will now begin. Remember to take your time and answer as accurately as possible.",
                startExperimentButton: "Start Experiment"
            },
            "es": {
                // --- Existing Strings ---
                mainMenuTitle: "Tarea de Calificaci√≥n de Calidad Visual", mainMenuWelcome: "¬°Bienvenido/a! Por favor, lea las instrucciones generales antes de comenzar.", testParamButton: "Probar un Par√°metro", startTaskButton: "Comenzar Tarea Completa (12 Ensayos)", paramSelectorTitle: "Seleccione el Par√°metro a Probar", conditionInstructionTitle: "Instrucciones: Tarea de {condition}", trialContinueButton: "Continuar", holdImagePrompt_recall: "Por favor, mantenga la imagen que acaba de ver en su mente. Presione Continuar cuando est√© listo/a.", holdImagePrompt_imagine: "Una vez que haya formado una imagen mental clara de la escena como se le indic√≥, presione Continuar.", vimGeneralInstruction: "Por favor, mantenga la imagen de su {sceneType} en su mente.", vimCoarsePrompt: "Seleccione la imagen que mejor represente el nivel general para", coarseButtonLow: "Bajo", coarseButtonMid: "Medio", coarseButtonHigh: "Alto", coarsePreviewText: "Pase el cursor sobre los botones para previsualizar, haga clic para seleccionar.", fineTunePrompt: "Ahora, ajuste su selecci√≥n para", selectedLevelLabel: "Nivel Seleccionado:", backToCoarseButton: "Volver a Selecci√≥n General", confirmLevelButton: "Confirmar este Nivel", backToMenuButton: "Volver al Men√∫ Principal", exitTaskButton: "Volver al Men√∫ Principal (Salir de la Tarea)", exitConfirmMessage: "¬øEst√° seguro/a de que desea salir de la tarea actual y volver al men√∫ principal? El progreso se perder√°.", resultsTitle: "Resultados de los Ensayos", downloadResultsButton: "Descargar Resultados", confidencePrompt: "¬øQu√© tan seguro/a est√° de su selecci√≥n?", likertLabelLow: "Nada seguro/a", likertLabelHigh: "Completamente seguro/a", confirmConfidenceButton: "Confirmar Confianza",
                // --- New Onboarding Strings ---
                welcomeTitle: "¬°Bienvenido/a!",
                welcomeInstructions: "Gracias por participar. Este experimento investiga la naturaleza de las im√°genes mentales. Tomar√° aproximadamente 15-20 minutos. Primero completar√° una breve ronda de pr√°ctica interactiva, seguida de los 12 ensayos principales.",
                continueButton: "Continuar",
                howToTitle: "C√≥mo Funciona la Tarea",
                howToStep1: "1. Se le pedir√° que recuerde o imagine una escena. Por favor, intente formar la imagen mental m√°s clara posible.",
                howToStep2: "2. Luego, ajustar√° una imagen en la pantalla para que coincida con las cualidades de su imagen mental (por ejemplo, su brillo, desenfoque, etc.).",
                howToStep3: "3. Despu√©s de cada ajuste, calificar√° qu√© tan seguro/a est√° de su elecci√≥n.",
                startPracticeButton: "Comenzar Ronda de Pr√°ctica",
                readyTitle: "Pr√°ctica Completada",
                readyText: "Ha completado la ronda de pr√°ctica. El experimento principal comenzar√° ahora. Recuerde tomarse su tiempo y responder con la mayor precisi√≥n posible.",
                startExperimentButton: "Comenzar Experimento"
            }
        };

        // REPLACE your existing PARAMETERS object

        const PARAMETERS = {
            saturation:   { name: {en: "Saturation", es: "Saturaci√≥n"}, levels: 21, coarse: { low: 4, mid: 11, high: 18 }, parameter_specific_instruction: {en: "how colorful or saturated it was.", es: "qu√© tan colorido o saturado era."}},
            brightness:   { name: {en: "Brightness", es: "Brillo"}, levels: 21, coarse: { low: 4, mid: 11, high: 18 }, parameter_specific_instruction: {en: "how bright or dim it appeared.", es: "qu√© tan brillante u oscuro parec√≠a."}},
            contrast:     { name: {en: "Contrast", es: "Contraste"}, levels: 21, coarse: { low: 4, mid: 11, high: 18 }, parameter_specific_instruction: {en: "the difference between light and dark areas.", es: "la diferencia entre √°reas claras y oscuras."}},
            blurriness:   { name: {en: "Blurriness", es: "Desenfoque"}, levels: 21, coarse: { low: 4, mid: 11, high: 18 }, parameter_specific_instruction: {en: "how sharp or out-of-focus it was.", es: "qu√© tan n√≠tido o desenfocado estaba."}},
            detailedness: { name: {en: "Detailedness", es: "Nivel de Detalle"}, levels: 21, coarse: { low: 4, mid: 11, high: 18 }, parameter_specific_instruction: {en: "how rich in fine features and textures it was.", es: "qu√© tan rico en detalles finos y texturas era."}},
            precision:    { name: {en: "Color Precision", es: "Precisi√≥n de Color"}, levels: 21, coarse: { low: 4, mid: 11, high: 18 }, parameter_specific_instruction: {en: "how specific or ambiguous the colors were.", es: "qu√© tan espec√≠ficos o ambiguos eran los colores."}},
            // --- THIS IS THE NEW ATTENTION CHECK PARAMETER ---
            attention_check: { name: {en: "Attention Check", es: "Prueba de Atenci√≥n"}, levels: 21, coarse: { low: 4, mid: 11, high: 18 }, 
                parameter_specific_instruction: {
                    en: "For this check, please select the 'Medium' button, then move the slider to level 11.", 
                    es: "Para esta prueba, por favor seleccione el bot√≥n 'Medio', y luego mueva el deslizador al nivel 11."
                },
                is_attention_check: true // Flag to identify this special parameter
            }
        };
        
        // ADD THIS NEW DATA OBJECT (replaces the old allTrialsMasterList)

        const IMAGE_DATA = [
            // --- INDOOR IMAGES (6) ---
            { id: 'image01', type: 'indoor', filename: 'image01.png', prompts: {
                episodic_recall:   {en: "Please recall a recent, vivid memory of relaxing in a LIVING ROOM with friends or family present. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria reciente y v√≠vida de estar relaj√°ndose en una SALA DE ESTAR con amigos o familiares. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine a quiet, empty LIVING ROOM in the middle of the day, with sunlight coming through a window. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine una SALA DE ESTAR tranquila y vac√≠a a mediod√≠a, con la luz del sol entrando por una ventana. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image03', type: 'indoor', filename: 'image03.png', prompts: {
                episodic_recall:   {en: "Please recall a specific, vivid memory of being in a CLASSROOM, listening to a lesson. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria espec√≠fica y v√≠vida de estar en un AULA, escuchando una lecci√≥n. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine an old, empty CLASSROOM after school, with chalk dust on the blackboard. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine un AULA vieja y vac√≠a despu√©s de clases, con polvo de tiza en la pizarra. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image04', type: 'indoor', filename: 'image04.png', prompts: {
                episodic_recall:   {en: "Please recall a recent, vivid memory of pushing a shopping cart through a busy SUPERMARKET. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria reciente y v√≠vida de estar empujando un carrito de compras en un SUPERMERCADO concurrido. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine standing in a SUPERMARKET aisle late at night, with almost no one else around. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine que est√° en el pasillo de un SUPERMERCADO por la noche, casi sin nadie m√°s alrededor. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image08', type: 'indoor', filename: 'image08.png', prompts: {
                episodic_recall:   {en: "Please recall a vivid memory of looking for a specific item in a SUPERMARKET AISLE. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria v√≠vida de estar buscando un art√≠culo espec√≠fico en un PASILLO DE SUPERMERCADO. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine a brightly lit and perfectly organized SUPERMARKET AISLE that is completely empty. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine un PASILLO DE SUPERMERCADO perfectamente ordenado y muy iluminado, que est√° completamente vac√≠o. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image09', type: 'indoor', filename: 'image09.png', prompts: {
                episodic_recall:   {en: "Please recall a vivid memory of having a conversation in a comfortable LIVING ROOM. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria v√≠vida de tener una conversaci√≥n en una SALA DE ESTAR c√≥moda. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine a minimalist LIVING ROOM with modern furniture and no personal items. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine una SALA DE ESTAR minimalista con muebles modernos y sin objetos personales. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image12', type: 'indoor', filename: 'image12.png', prompts: {
                episodic_recall:   {en: "Please recall a vivid memory of working on a group project with other students in a CLASSROOM. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria v√≠vida de trabajar en un proyecto grupal con otros estudiantes en un AULA. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine the first day of school, in a CLASSROOM filled with students finding their seats. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine el primer d√≠a de clases, en un AULA llena de estudiantes buscando sus asientos. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los los ojos y presione Continuar."}
            }},
            // --- OUTDOOR IMAGES (6) ---
            { id: 'image02', type: 'outdoor', filename: 'image02.png', prompts: {
                episodic_recall:   {en: "Please recall a vivid memory of walking down an empty CITY STREET early in the morning. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria v√≠vida de caminar por una CALLE de una CIUDAD vac√≠a temprano en la ma√±ana. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine a wide CITY STREET in a futuristic city, with sleek, silent vehicles. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine una CALLE ancha en una CIUDAD futurista, con veh√≠culos elegantes y silenciosos. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image05', type: 'outdoor', filename: 'image05.png', prompts: {
                episodic_recall:   {en: "Please recall a vivid memory of standing on a BEACH, feeling the spray from the waves. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria v√≠vida de estar en una PLAYA, sintiendo la brisa de las olas. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine a secret BEACH on a tropical island, with a hidden waterfall and no footprints in the sand. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine una PLAYA secreta en una isla tropical, con una cascada escondida y sin huellas en la arena. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image06', type: 'outdoor', filename: 'image06.png', prompts: {
                episodic_recall:   {en: "Please recall a vivid memory of having a picnic or relaxing in a lush, green PARK. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria v√≠vida de tener un picnic o relajarse en un PARQUE verde y frondoso. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine a vast botanical PARK with many strange and colorful exotic plants you've never seen before. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine un vasto PARQUE bot√°nico con muchas plantas ex√≥ticas, extra√±as y coloridas que nunca ha visto. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image07', type: 'outdoor', filename: 'image07.png', prompts: {
                episodic_recall:   {en: "Please recall a vivid memory of a pleasant walk through a PARK on a cool autumn day. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria v√≠vida de un paseo agradable por un PARQUE en un d√≠a fresco de oto√±o. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine a PARK in the middle of winter, with bare trees and a light dusting of snow on the ground. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine un PARQUE en pleno invierno, con √°rboles sin hojas y una fina capa de nieve en el suelo. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image10', type: 'outdoor', filename: 'image10.png', prompts: {
                episodic_recall:   {en: "Please recall a vivid memory of being in a crowd on a BUSY CITY STREET. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria v√≠vida de estar entre una multitud en una CALLE CONCURRIDA de una CIUDAD. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine a BUSY CITY STREET during a parade, with confetti in the air and music playing. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine una CALLE CONCURRIDA de una CIUDAD durante un desfile, con confeti en el aire y m√∫sica sonando. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image11', type: 'outdoor', filename: 'image11.png', prompts: {
                episodic_recall:   {en: "Please recall a vivid memory of playing or building a sandcastle on a sunny BEACH. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria v√≠vida de jugar o construir un castillo de arena en una PLAYA soleada. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine a BEACH at sunset, with the sky full of orange and purple colors. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine una PLAYA al atardecer, con el cielo lleno de colores naranjas y morados. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }}
        ];

        const GOOGLE_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbwkcpn2kATIjVlfgGAT6um4sN2LOcTU6Qde2vj8mKzd19VtfVxHynh3KR-qMBuNeanSkQ/exec';
        const saveStatus = document.getElementById('saveStatus');

        let currentLanguage = 'en';
        const imageBaseFolder = "images"; 
        const imageExtension = ".png";
        const fineTuneRange = 3; 
        let currentSessionTrials = []; 
        let currentGlobalTrialIndex = 0; 
        let currentTrialData = null;     
        let currentTrialResponses = {};  
        let allCollectedResponses = [];  
        let currentTaskMode = null; 
        // --- NEW ---
        let sessionID = null;
        let currentParameterKey = null;
        let currentParameterConfig = null;
        let actualTaskOrder = []; 
        let currentParameterIndexInTask = 0; 
        let currentFocusableElements = [];
        let currentFocusedIndex = -1;      
        const KEYBOARD_FOCUS_CLASS = 'keyboard-focus';
        const isTouchDevice = (('ontouchstart' in window) || (navigator.maxTouchPoints > 0));

        // --- DOM Elements ---
        const mainMenuDiv = document.getElementById('mainMenu');
        const parameterSelectorDiv = document.getElementById('parameterSelector');
        const paramButtonsContainer = document.getElementById('paramButtonsContainer');
        const vimTaskInterfaceDiv = document.getElementById('vimTaskInterface');
        const resultsDisplayDiv = document.getElementById('resultsDisplay');
        // --- NEW ---
        const downloadResultsBtn = document.getElementById('downloadResultsBtn');
        const conditionInstructionScreenDiv = document.getElementById('conditionInstructionScreen');
        const conditionInstructionTitleH2 = document.getElementById('conditionInstructionTitle');
        const conditionInstructionTextP = document.getElementById('conditionInstructionText');
        const startTrialFromInstructionsBtn = document.getElementById('startTrialFromInstructionsBtn');
        const preVimScreenContainerDiv = document.getElementById('preVimScreenContainer');
        const fixationScreenDiv = document.getElementById('fixationScreen');
        const preVimImageScreenDiv = document.getElementById('preVimImageScreenDiv');
        const originalImageDisplayImg = document.getElementById('originalImageDisplay');
        const holdImageInstructionScreenDiv = document.getElementById('holdImageInstructionScreen');
        const holdImagePromptP = document.getElementById('holdImagePrompt');
        const holdImageContinueBtn = document.getElementById('holdImageContinueBtn');
        const vimGeneralInstructionP = document.getElementById('vimGeneralInstruction');
        const currentParamDisplay = document.getElementById('currentParamDisplay').querySelector('span');
        const coarseStepDiv = document.getElementById('coarseStep');
        const coarseParamNameStrong = document.getElementById('coarseParamName');
        const coarseButtons = coarseStepDiv.querySelectorAll('button');
        const coarsePreviewImg = document.getElementById('coarsePreviewImg');
        const coarseImageDisplayP = document.querySelector('#coarseImageDisplay p.preview-instruction');
        const paramNameInlineSpans = document.querySelectorAll('.param-name-inline');
        const fineTuneStepDiv = document.getElementById('fineTuneStep');
        const fineTuneParamNameStrong = document.getElementById('fineTuneParamName');
        const fineTuneImg = document.getElementById('fineTuneImg');
        const fineTuneSlider = document.getElementById('fineTuneSlider');
        const fineTuneLevelDisplay = document.getElementById('fineTuneLevelDisplay');
        const backToCoarseBtn = document.getElementById('backToCoarseBtn');
        const confirmSelectionBtn = document.getElementById('confirmSelectionBtn');
        const resultsListUl = document.getElementById('resultsList');
        const backToMenuFromTestSelectBtn = document.getElementById('backToMenuFromTestSelectBtn');
        const backToMenuFromTaskBtn = document.getElementById('backToMenuFromTaskBtn');
        const backToMenuFromResultsBtn = document.getElementById('backToMenuFromResultsBtn');

        let currentCoarseSelectionLevel = null;
        let sliderToActualLevelMap = [];

        // ADD these new variable definitions at the top of the script
        const confidenceStepDiv = document.getElementById('confidenceStep');
        const likertButtons = document.querySelectorAll('.likert-button');
        const confirmConfidenceBtn = document.getElementById('confirmConfidenceBtn');
        let currentConfidenceSelection = null;

        const welcomeScreen = document.getElementById('welcomeScreen');
        const howToScreen = document.getElementById('howToScreen');

        // --- Utility Functions ---
        function shuffleArray(array) { 
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        // REPLACE your existing getVariantImagePath function with this one

        function getVariantImagePath(baseImageId, paramKey, level) { 
            // --- THIS IS THE FIX ---
            // If the parameter is an attention check, we need to get an image from a REAL parameter's folder.
            // We can just default to using the 'brightness' folder for this purpose.
            const folderParam = paramKey === 'attention_check' ? 'brightness' : paramKey;

            const levelStr = level < 10 ? '0' + level : level.toString();
            
            // Construct the path using the corrected folder parameter.
            return `${imageBaseFolder}/${folderParam}/${baseImageId}_${folderParam}_${levelStr}${imageExtension}`;
        }

        function getOriginalImagePath(originalFilename) { 
            return `${imageBaseFolder}/originals/${originalFilename}`;
        }
        
        function resetFullTaskState() { 
            currentTrialData = null;
            currentTrialResponses = {};
            currentTaskMode = null;
            // --- MODIFIED ---
            sessionID = null; 
            currentParameterKey = null;
            currentParameterConfig = null;
            actualTaskOrder = [];
            currentParameterIndexInTask = 0;
            currentSessionTrials = [];
            currentGlobalTrialIndex = 0;
            allCollectedResponses = []; 
            console.log("Full task state reset.");
        }

        // ADD THIS NEW HELPER FUNCTION
        function clearAllFocus() {
            // This function finds ANY element that currently has the focus class and removes it.
            const focusedEl = document.querySelector('.' + KEYBOARD_FOCUS_CLASS);
            if (focusedEl) {
                focusedEl.classList.remove(KEYBOARD_FOCUS_CLASS);
            }
            // It also resets the global tracking variables for safety.
            currentFocusableElements = [];
            currentFocusedIndex = -1;
        }

        function updateKeyboardFocus(newIndex) {
            if (currentFocusableElements && currentFocusableElements[currentFocusedIndex]) {
                currentFocusableElements[currentFocusedIndex].classList.remove(KEYBOARD_FOCUS_CLASS);
            }
            currentFocusedIndex = newIndex;
            if (currentFocusableElements && currentFocusableElements[currentFocusedIndex]) {
                currentFocusableElements[currentFocusedIndex].classList.add(KEYBOARD_FOCUS_CLASS);
                currentFocusableElements[currentFocusedIndex].focus(); // Also set browser focus
            }
        }

        function setupMainMenuFocus() {
            currentFocusableElements = [document.getElementById('testParameterBtn'), document.getElementById('startActualTaskBtn')];
            updateKeyboardFocus(0);
        }
        
        function setupParameterSelectorFocus() {
            currentFocusableElements = Array.from(paramButtonsContainer.querySelectorAll('button'));
            updateKeyboardFocus(currentFocusableElements.length > 0 ? 0 : -1);
        }
        
        function setupCoarseStepFocus() {
            currentFocusableElements = Array.from(coarseStepDiv.querySelectorAll('button[data-level-key]'));
            let initialFocus = currentFocusableElements.length > 1 ? 1 : (currentFocusableElements.length === 1 ? 0 : -1);
            updateKeyboardFocus(initialFocus);
            if (initialFocus !== -1 && !isTouchDevice) {
                currentFocusableElements[initialFocus].dispatchEvent(new Event('mouseover'));
            }
        }

        
        // REPLACE your existing showDiv function with this one

        function showDiv(divToShow) { 
            // This list now includes all possible screens that can be shown.
            [mainMenuDiv, welcomeScreen, howToScreen, document.getElementById('readyScreen'),
            parameterSelectorDiv, vimTaskInterfaceDiv, resultsDisplayDiv, 
            preVimScreenContainerDiv, conditionInstructionScreenDiv].forEach(div => {
                if(div) div.classList.add('hidden');
            });

            if (currentFocusableElements && currentFocusableElements[currentFocusedIndex]) {
                currentFocusableElements[currentFocusedIndex].classList.remove(KEYBOARD_FOCUS_CLASS);
            }
            currentFocusableElements = []; currentFocusedIndex = -1;

            if (divToShow) {
                divToShow.classList.remove('hidden');
                if (divToShow === mainMenuDiv) setupMainMenuFocus();
                else if (divToShow === parameterSelectorDiv) setupParameterSelectorFocus();
                else if (divToShow === conditionInstructionScreenDiv) {
                    currentFocusableElements = [startTrialFromInstructionsBtn];
                    updateKeyboardFocus(0);
                } else if (divToShow === vimTaskInterfaceDiv && !coarseStepDiv.classList.contains('hidden')) {
                    setupCoarseStepFocus();
                }
            }
        }
        // --- LANGUAGE SWITCHING ---
        function setLanguage(lang) {
            currentLanguage = lang;
            document.getElementById('htmlTag').lang = lang; 

            document.querySelectorAll('#languageSelector button').forEach(btn => {
                btn.classList.toggle('active-lang', btn.dataset.lang === lang);
            });

            document.querySelectorAll('[data-lang-key]').forEach(el => {
                const key = el.dataset.langKey;
                if (LANG_STRINGS[currentLanguage] && LANG_STRINGS[currentLanguage][key]) {
                    el.textContent = LANG_STRINGS[currentLanguage][key];
                }
            });

            if (!parameterSelectorDiv.classList.contains('hidden')) {
                populateParameterSelector();
            }

            document.getElementById('confidencePrompt').textContent = LANG_STRINGS[lang].confidencePrompt;
            document.getElementById('likertLabelLow').textContent = LANG_STRINGS[lang].likertLabelLow;
            document.getElementById('likertLabelHigh').textContent = LANG_STRINGS[lang].likertLabelHigh;
        }

        // --- Core Application Logic ---

        function showConditionInstructions(trialDataObject) {
            currentTrialData = trialDataObject; 
            if (!currentTrialData) {
                console.error("showConditionInstructions called with invalid trialData!");
                return;
            }

            const conditionName = {
                en: currentTrialData.condition.replace(/_/g, ' '),
                es: currentTrialData.condition === "perceptual_recall" ? "Recuerdo Perceptual" : 
                    currentTrialData.condition === "episodic_recall" ? "Recuerdo Epis√≥dico" : "Imaginaci√≥n de Escena"
            }[currentLanguage];

            let titlePrefix = currentTaskMode === 'test' ? "Test Mode" : `Trial ${currentGlobalTrialIndex + 1} of ${currentSessionTrials.length}`;
            conditionInstructionTitleH2.textContent = `${titlePrefix}: ${conditionName}`;
            conditionInstructionTextP.textContent = currentTrialData.condition_instruction[currentLanguage];
            showDiv(conditionInstructionScreenDiv);
            currentFocusableElements = [startTrialFromInstructionsBtn];
            updateKeyboardFocus(0);
        }

        // REPLACE this event listener
        startTrialFromInstructionsBtn.addEventListener('click', () => {
            if (!currentTrialData) return;
            if (currentTrialData.condition === "perceptual_recall") {
                startPreVimPhase(currentTrialData);
            } else { 
                currentTrialResponses = { 
                    trial_id: currentTrialData.trial_id, condition: currentTrialData.condition,
                    image_id: currentTrialData.base_image_id, parameter_responses: {}
                };
                // It now calls our single, unified function.
                beginVimRating();
            }
        });

        // --- Pre-VIM Task Flow ---
        // REPLACE this function
        function startPreVimPhase(trialData) {
            currentTrialResponses = { 
                trial_id: trialData.trial_id, 
                condition: trialData.condition,
                image_id: trialData.base_image_id, 
                parameter_responses: {}
            };
            
            showDiv(preVimScreenContainerDiv);
            
            fixationScreenDiv.classList.add('hidden');
            preVimImageScreenDiv.classList.add('hidden');
            holdImageInstructionScreenDiv.classList.add('hidden');

            fixationScreenDiv.classList.remove('hidden'); 
            
            setTimeout(() => { 
                fixationScreenDiv.classList.add('hidden');
                preVimImageScreenDiv.classList.remove('hidden');
                originalImageDisplayImg.src = getOriginalImagePath(trialData.original_image_filename);
                
                setTimeout(() => { 
                    preVimImageScreenDiv.classList.add('hidden');
                    originalImageDisplayImg.src = ""; 
                    
                    holdImagePromptP.textContent = LANG_STRINGS[currentLanguage].holdImagePrompt_recall;
                    holdImageInstructionScreenDiv.classList.remove('hidden');
                    
                    currentFocusableElements = [holdImageContinueBtn];
                    updateKeyboardFocus(0);

                }, 1000); // Image display duration: 4 seconds
            }, 2000); // Fixation duration: 1 second
        }

        // REPLACE these two items
        holdImageContinueBtn.addEventListener('click', () => {
            // It now calls our single, unified function.
            beginVimRating();
        });

        // The advanceFromHoldScreen function is no longer needed and can be deleted.

        // --- VIM Parameter Rating Functions ---

        // REPLACE your existing beginVimRating function with this one

        function beginVimRating() {
            if (currentTaskMode === 'tutorial') {
                actualTaskOrder = ['brightness'];
            } else if (currentTaskMode === 'test') {
                actualTaskOrder = [currentParameterKey];
            } else { 
                const realParameters = Object.keys(PARAMETERS).filter(p => p !== 'attention_check');
                let parametersForThisTrial = shuffleArray(realParameters);
                
                // --- THIS IS THE NEW LOGIC ---
                // If the trial is tagged, simply add the attention check as the 7th and final parameter.
                if (currentTrialData.has_attention_check) {
                    parametersForThisTrial.push('attention_check');
                }
                actualTaskOrder = parametersForThisTrial;
            }

            // This part of the logic remains the same
            const sceneTypeKey = currentTrialData.condition === "perceptual_recall" ? "recalled photo" 
                : currentTrialData.condition === "Practice" ? "practice image" 
                : "mental scene";
            const sceneTypeString = {en: sceneTypeKey, es: sceneTypeKey.replace("photo", "foto").replace("image", "imagen").replace("scene", "escena")}[currentLanguage];
            vimGeneralInstructionP.textContent = LANG_STRINGS[currentLanguage].vimGeneralInstruction.replace('{sceneType}', sceneTypeString);
            
            showDiv(vimTaskInterfaceDiv);
            currentParameterIndexInTask = 0;
            loadNextParameterInVim();
        }

        // REPLACE this function
        function loadNextParameterInVim() { 
            if (currentParameterIndexInTask < actualTaskOrder.length) {
                // More parameters to rate for the current trial
                currentParameterKey = actualTaskOrder[currentParameterIndexInTask];
                currentParameterConfig = PARAMETERS[currentParameterKey];
                setupCoarseStepVim(); 
            } else {
                // --- All parameters for the current trial are FINISHED ---
                if (currentTaskMode === 'actual_task_full') {
                    allCollectedResponses.push({...currentTrialResponses}); 
                }
                
                if (currentTaskMode === 'tutorial') {
                    showReadyScreen();
                } else if (currentTaskMode === 'test') {
                    alert(`Test complete for ${PARAMETERS[currentParameterKey].name.en}`);
                    showDiv(parameterSelectorDiv);
                } else {
                    // This was a main trial. Just load the next one.
                    currentGlobalTrialIndex++;
                    if (currentGlobalTrialIndex < currentSessionTrials.length) {
                        showConditionInstructions(currentSessionTrials[currentGlobalTrialIndex]);
                    } else {
                        displayFullResults();
                    }
                }
            }
        }
        
        // REPLACE this function
        // This is your working function with the one necessary line added.
        function setupCoarseStepVim() { 
            clearAllFocus();
            const paramName = currentParameterConfig.name[currentLanguage];
            currentParamDisplay.textContent = paramName;
            coarseParamNameStrong.textContent = currentParameterConfig.parameter_specific_instruction[currentLanguage]; 
            fineTuneParamNameStrong.textContent = currentParameterConfig.parameter_specific_instruction[currentLanguage];
            coarseButtons.forEach(button => {
                const levelKey = button.dataset.levelKey;
                button.dataset.level = currentParameterConfig.coarse[levelKey];
            });

            // Show/hide controls in RIGHT panel
            coarseStepDiv.classList.remove('hidden');
            fineTuneStepDiv.classList.add('hidden');
            confidenceStepDiv.classList.add('hidden'); // Also hide confidence step

            // --- THIS IS THE FIX ---
            // Clear highlighting from BOTH sets of buttons.
            likertButtons.forEach(btn => btn.classList.remove('selected'));
            coarseButtons.forEach(btn => btn.classList.remove('selected')); // THIS IS THE NEW, ADDED LINE

            // Show/hide images in LEFT panel
            document.getElementById('coarseImageDisplay').classList.remove('hidden');
            document.getElementById('fineTuneImageDisplay').classList.add('hidden');

            // Hide ALL action buttons at the bottom initially for the coarse step
            backToCoarseBtn.classList.add('hidden');
            confirmSelectionBtn.classList.add('hidden');
            confirmConfidenceBtn.classList.add('hidden');
            
            // Reset preview
            coarsePreviewImg.src = ""; 
            if (coarseImageDisplayP) coarseImageDisplayP.classList.remove('hidden');
            setupCoarseStepFocus();
        }

        // REPLACE your existing setupFineTuneStepVim function with this one

        function setupFineTuneStepVim(coarseLevelValue) {
            clearAllFocus();
            currentCoarseSelectionLevel = coarseLevelValue;
            fineTuneParamNameStrong.textContent = currentParameterConfig.parameter_specific_instruction[currentLanguage]; 
            const totalParamLevels = currentParameterConfig.levels;
            
            // --- THIS LOGIC IS UNCHANGED ---
            // Determine the min and max levels for the slider range
            let minL, maxL;
            if (coarseLevelValue === PARAMETERS[currentParameterKey].coarse.low) {
                minL = 1;
                maxL = 7;
            } else if (coarseLevelValue === PARAMETERS[currentParameterKey].coarse.mid) {
                minL = 8;
                maxL = 14;
            } else { // High
                minL = 15;
                maxL = 21;
            }
            
            sliderToActualLevelMap = [];
            for (let i = minL; i <= maxL; i++) {
                sliderToActualLevelMap.push(i);
            }

            // --- THIS LOGIC IS NEW (FOR RANDOMIZATION) ---
            // Instead of centering on the coarse value, pick a random starting index for the slider.
            const randomSliderIndex = Math.floor(Math.random() * sliderToActualLevelMap.length); // Get a random index from 0 to length-1
            const initialSliderValue = randomSliderIndex + 1; // Slider values are 1-based

            // --- THIS LOGIC IS NOW UPDATED TO USE THE RANDOM VALUE ---
            fineTuneSlider.min = 1;
            fineTuneSlider.max = sliderToActualLevelMap.length;
            fineTuneSlider.value = initialSliderValue; // Set the slider to the random position

            updateFineTuneImageVim(fineTuneSlider.value);
            
            // --- THIS LOGIC IS UNCHANGED ---
            coarseStepDiv.classList.add('hidden');
            fineTuneStepDiv.classList.remove('hidden');
            document.getElementById('coarseImageDisplay').classList.add('hidden');
            document.getElementById('fineTuneImageDisplay').classList.remove('hidden');
            
            backToCoarseBtn.classList.remove('hidden');
            confirmSelectionBtn.classList.remove('hidden');
            
            fineTuneSlider.focus(); 
            currentFocusableElements = [fineTuneSlider, backToCoarseBtn, confirmSelectionBtn];
            updateKeyboardFocus(0); 
        }

        function updateFineTuneImageVim(sliderValStr) { 
            const sliderValue = parseInt(sliderValStr);
            const actualLevel = sliderToActualLevelMap[sliderValue - 1];
            if (actualLevel !== undefined && currentTrialData && currentParameterKey) { 
                fineTuneImg.src = getVariantImagePath(currentTrialData.base_image_id, currentParameterKey, actualLevel);
                fineTuneLevelDisplay.textContent = actualLevel;
            }
        }
       
        // --- Start/Setup Functions ---
        function populateParameterSelector() { 
            paramButtonsContainer.innerHTML = ''; 
            Object.keys(PARAMETERS).forEach(key => {
                const button = document.createElement('button');
                button.textContent = `${LANG_STRINGS[currentLanguage].testParamButton.split(' ')[0]} ${PARAMETERS[key].name[currentLanguage]}`;
                button.addEventListener('click', () => startParameterTest(key));
                paramButtonsContainer.appendChild(button);
            });
            setupParameterSelectorFocus(); 
        }

        // REPLACE this function
        function startParameterTest(paramKey) {  
            resetFullTaskState(); 
            currentTaskMode = 'test';
            currentParameterKey = paramKey; 
            currentParameterConfig = PARAMETERS[paramKey]; 
            currentTrialData = {
                trial_id: "TestRun",
                condition: "Parameter Test",
                base_image_id: IMAGE_DATA.length > 0 ? IMAGE_DATA[0].id : "image01"
            };
            // It now calls our single, unified function.
            beginVimRating();
        }

        // ADD THESE THREE NEW FUNCTIONS

        // function getUrlParameter(name) {
        //     name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
        //     var regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
        //     var results = regex.exec(location.search);
        //     return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
        // }

        // REPLACE your existing createTrialList function

        function createTrialList(set = 'A') {
            // This function now ONLY creates the 12 main experimental trials.
            const conditions = ["perceptual_recall", "episodic_recall", "scene_imagination"];
            const indoorImages = IMAGE_DATA.filter(img => img.type === 'indoor');
            const outdoorImages = IMAGE_DATA.filter(img => img.type === 'outdoor');
            
            const groupAssignments = {
                'A': [0, 1, 2], 'B': [1, 2, 0], 'C': [2, 0, 1]
            };
            const assignment = groupAssignments[set.toUpperCase()] || groupAssignments['A'];

            let mainTrials = [];
            let trialCounter = 1;

            conditions.forEach((condition, i) => {
                const groupIndex = assignment[i];
                const indoorGroup = indoorImages.slice(groupIndex * 2, groupIndex * 2 + 2);
                const outdoorGroup = outdoorImages.slice(groupIndex * 2, groupIndex * 2 + 2);

                [...indoorGroup, ...outdoorGroup].forEach(img => {
                    let instruction = (condition === 'perceptual_recall')
                        ? { en: "You will be shown an image for a few seconds...", es: "Se le mostrar√° una imagen por unos segundos..."}
                        : img.prompts[condition];

                    mainTrials.push({
                        trial_id: `main_${trialCounter++}`,
                        is_attention_check: false,
                        condition: condition,
                        base_image_id: img.id,
                        original_image_filename: img.filename,
                        condition_instruction: instruction
                    });
                });
            });
            return mainTrials;
        }

        // ADD THIS ENTIRE NEW BLOCK OF ONBOARDING LOGIC

        // --- Onboarding Flow Control ---

        // When user clicks "Continue" on welcome screen
        document.getElementById('startInstructionsBtn').addEventListener('click', () => {
            showDiv(howToScreen);
        });

        // When user clicks "Start Practice Round"
        document.getElementById('startTutorialBtn').addEventListener('click', () => {
            startTutorial();
        });

        // REPLACE this function
        function startTutorial() {
            currentTaskMode = 'tutorial';
            currentTrialData = {
                trial_id: "TutorialRun",
                condition: "Practice",
                base_image_id: "tutorial" 
            };
            // It now calls our single, unified function.
            beginVimRating();
        }

        // function showReadyScreen() {
        //     // This screen appears after the tutorial is complete
        //     const readyScreen = document.createElement('div');
        //     readyScreen.className = 'main-container';
        //     readyScreen.innerHTML = `
        //         <h2 data-lang-key="readyTitle">${LANG_STRINGS[currentLanguage].readyTitle}</h2>
        //         <p data-lang-key="readyText">${LANG_STRINGS[currentLanguage].readyText}</p>
        //         <button id="startExperimentBtn" data-lang-key="startExperimentButton">${LANG_STRINGS[currentLanguage].startExperimentButton}</button>
        //     `;
            
        //     // Temporarily replace the body content with this screen
        //     document.body.innerHTML = ''; // Clear everything
        //     document.body.appendChild(readyScreen);
            
        //     // The only button on this screen now starts the real task
        //     document.getElementById('startExperimentBtn').addEventListener('click', () => {
        //         // Reload the page to reset all states cleanly, then start the task
        //         // We add a URL parameter to skip the intro on the next load.
        //         window.location.replace(window.location.pathname + '?run=true');
        //     });
        // }

        // ADD THIS ENTIRE FUNCTION BACK INTO YOUR SCRIPT

        function showReadyScreen() {
            // This function now correctly uses the showDiv system.
            const readyScreenDiv = document.getElementById('readyScreen');
            
            // Populate the text content based on the current language
            readyScreenDiv.querySelector('[data-lang-key="readyTitle"]').textContent = LANG_STRINGS[currentLanguage].readyTitle;
            readyScreenDiv.querySelector('[data-lang-key="readyText"]').textContent = LANG_STRINGS[currentLanguage].readyText;
            readyScreenDiv.querySelector('[data-lang-key="startExperimentButton"]').textContent = LANG_STRINGS[currentLanguage].startExperimentButton;

            // Show the screen
            showDiv(readyScreenDiv);
        }
        
        // REPLACE this function
        function startActualTask() {
            resetFullTaskState(); 
            currentTaskMode = 'actual_task_full';
            sessionID = Date.now();
            const set = 'A'; // This can be changed later with getUrlParameter if needed

            // 1. Create the list of 12 main trials
            currentSessionTrials = createTrialList(set);

            // --- NEW ATTENTION CHECK LOGIC ---
            // 2. Randomly select 3 trials to insert an attention check into
            const attentionCheckCount = 3;
            let indices = Array.from(Array(currentSessionTrials.length).keys()); // [0, 1, 2, ..., 11]
            let shuffledIndices = shuffleArray(indices);
            let attentionCheckIndices = shuffledIndices.slice(0, attentionCheckCount); // Pick the first 3
            
            // 3. "Tag" those trials
            attentionCheckIndices.forEach(index => {
                currentSessionTrials[index].has_attention_check = true;
            });
            console.log("Trials with an attention check:", attentionCheckIndices);

            // 4. Shuffle the final list of 12 trials so their order is random
            currentSessionTrials = shuffleArray(currentSessionTrials);

            // Start the experiment
            currentGlobalTrialIndex = 0;
            allCollectedResponses = []; 
            showConditionInstructions(currentSessionTrials[0]);
        }   

        document.getElementById('startExperimentBtn').addEventListener('click', startActualTask);

        // REPLACE your existing displayFullResults function with this one

        function displayFullResults() {
            // --- This section is now conditional ---
            if (DEBUG_SHOW_RESULTS) {
                resultsListUl.innerHTML = ''; 
                allCollectedResponses.forEach(trialResp => {
                    const trialHeader = document.createElement('li');
                    trialHeader.innerHTML = `<strong>Trial ${trialResp.trial_id} (${trialResp.condition}, Image: ${trialResp.image_id})</strong>`;
                    resultsListUl.appendChild(trialHeader);

                    for (const paramKeyInResp in trialResp.parameter_responses) {
                        const listItem = document.createElement('li');
                        listItem.style.paddingLeft = "20px";
                        listItem.textContent = `${PARAMETERS[paramKeyInResp].name[currentLanguage]}: Level ${trialResp.parameter_responses[paramKeyInResp]}`;
                        resultsListUl.appendChild(listItem);
                    }
                    resultsListUl.appendChild(document.createElement('hr')); 
                });
            } else {
                // If not debugging, ensure the list and title are hidden
                resultsListUl.style.display = 'none';
                document.querySelector('[data-lang-key="resultsTitle"]').style.display = 'none';
            }
            
            showDiv(resultsDisplayDiv);
            console.log("All Collected Responses:", JSON.stringify({ sessionID, results: allCollectedResponses }, null, 2));

            sendDataToGoogleSheet();
        }

        // --- NEW ---
        function downloadResults() {
            if (!sessionID || allCollectedResponses.length === 0) {
                alert("No data to download.");
                return;
            }

            // 1. Structure the data with the session ID
            const dataToDownload = {
                sessionID: sessionID,
                results: allCollectedResponses
            };

            // 2. Convert the data object to a JSON string
            const jsonString = JSON.stringify(dataToDownload, null, 2);

            // 3. Create a Blob from the JSON string
            const blob = new Blob([jsonString], { type: "application/json" });

            // 4. Create a temporary URL for the Blob
            const url = URL.createObjectURL(blob);

            // 5. Create a temporary anchor element to trigger the download
            const a = document.createElement('a');
            a.href = url;
            a.download = `VIM_results_session_${sessionID}.json`; // Set the filename
            document.body.appendChild(a); // Append to body to ensure it's clickable
            a.click(); // Programmatically click the link

            // 6. Clean up by removing the temporary anchor and URL
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Add this entire new function to your script

        // REPLACE your existing sendDataToGoogleSheet function with this one:

        async function sendDataToGoogleSheet() {
            if (!sessionID || allCollectedResponses.length === 0) {
                // If there's no data, just show the button immediately.
                backToMenuFromResultsBtn.classList.remove('hidden');
                return; 
            }

            saveStatus.textContent = LANG_STRINGS[currentLanguage].resultsTitle === "Trial Results" ? "Saving data..." : "Guardando datos...";
            
            try {
                const dataToPost = {
                    sessionID: sessionID,
                    results: allCollectedResponses
                };

                await fetch(GOOGLE_SCRIPT_URL, {
                    method: 'POST',
                    mode: 'no-cors',
                    cache: 'no-cache',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    redirect: 'follow',
                    body: JSON.stringify(dataToPost)
                });

                saveStatus.textContent = LANG_STRINGS[currentLanguage].resultsTitle === "Trial Results" ? "Data saved successfully. Thank you!" : "Datos guardados con √©xito. ¬°Gracias!";
                saveStatus.style.color = 'green';
                console.log("Data submission successful (assumed).");

            } catch (error) {
                saveStatus.textContent = LANG_STRINGS[currentLanguage].resultsTitle === "Trial Results" ? "Error: Could not save data. Please use the download button." : "Error: No se pudieron guardar los datos. Por favor, use el bot√≥n de descarga.";
                saveStatus.style.color = 'red';
                console.error("Error sending data to Google Sheet:", error);
            } finally {
                // --- THIS IS THE NEW PART ---
                // This code will run after the 'try' or 'catch' block finishes.
                // It ensures the user always gets a way to leave the screen.
                backToMenuFromResultsBtn.classList.remove('hidden');
            }
        }

        // --- EVENT LISTENERS ---
        // REPLACE this entire block
        document.addEventListener('DOMContentLoaded', () => {
            resetFullTaskState(); 
            setLanguage('en'); 
            showDiv(mainMenuDiv);
            if(isTouchDevice) document.body.classList.add('touch-device');
        });

        // Language Buttons
        document.querySelectorAll('#languageSelector button').forEach(button => {
            button.addEventListener('click', () => setLanguage(button.dataset.lang));
        });

        // Main Menu Buttons
        document.getElementById('testParameterBtn').addEventListener('click', () => {
            resetFullTaskState(); 
            populateParameterSelector();
            showDiv(parameterSelectorDiv);
        });
        
        document.getElementById('startActualTaskBtn').addEventListener('click', () => {
            // Now, this button simply shows the first welcome screen
            showDiv(welcomeScreen);
        });
        
        // Back Buttons
        backToMenuFromTestSelectBtn.addEventListener('click', () => { resetFullTaskState(); showDiv(mainMenuDiv); });
        backToMenuFromTaskBtn.addEventListener('click', () => {
            let confirmExit = currentTaskMode === 'test' ? true : confirm(LANG_STRINGS[currentLanguage].exitConfirmMessage);
            if (confirmExit) {
                resetFullTaskState();
                showDiv(mainMenuDiv);
            }
        }); 
        backToMenuFromResultsBtn.addEventListener('click', () => { resetFullTaskState(); showDiv(mainMenuDiv); });

        // --- NEW --- Download Button
        downloadResultsBtn.addEventListener('click', downloadResults);

        // REPLACE this entire block to make it more robust

        coarseButtons.forEach(button => {
            button.addEventListener('mouseover', () => {
                if (!currentParameterConfig || coarseStepDiv.classList.contains('hidden') || !currentTrialData) return;
                
                // This is the working preview logic
                const level = parseInt(button.dataset.level);
                coarsePreviewImg.src = getVariantImagePath(currentTrialData.base_image_id, currentParameterKey, level);
                
                // Safety check before using the variable
                if(coarseImageDisplayP) coarseImageDisplayP.classList.add('hidden');
            });
            button.addEventListener('click', () => {
                if (!currentParameterConfig) return;
                setupFineTuneStepVim(parseInt(button.dataset.level)); 
            });
        });
        
        // ... (The rest of the JS code for keyboard handling, etc., remains unchanged) ...
        // REPLACE this event listener block
        document.addEventListener('keydown', (event) => {
            if (document.activeElement.tagName === 'INPUT' && document.activeElement.type !== 'range') return;
            
            if (event.key === "Escape") {
                event.preventDefault();
                const visibleBackButton = document.querySelector('.main-container:not(.hidden) .back-button, .split-container:not(.hidden) .back-button');
                if (visibleBackButton) visibleBackButton.click();
                return;
            }

            // Route to specific handlers based on which screen is active
            if (!welcomeScreen.classList.contains('hidden') && event.key === "Enter") {
                event.preventDefault(); document.getElementById('startInstructionsBtn').click();
            } else if (!howToScreen.classList.contains('hidden') && event.key === "Enter") {
                event.preventDefault(); document.getElementById('startTutorialBtn').click();
            } else if (!document.getElementById('readyScreen').classList.contains('hidden') && event.key === "Enter") {
                event.preventDefault(); document.getElementById('startExperimentBtn').click();
            } else if (!mainMenuDiv.classList.contains('hidden')) {
                handleMainMenuKeys(event);
            } else if (!parameterSelectorDiv.classList.contains('hidden')) {
                handleParameterSelectorKeys(event);
            } else if (!conditionInstructionScreenDiv.classList.contains('hidden') && event.key === "Enter") {
                event.preventDefault(); startTrialFromInstructionsBtn.click();
            } else if (!preVimScreenContainerDiv.classList.contains('hidden') && !holdImageInstructionScreenDiv.classList.contains('hidden') && event.key === "Enter") {
                event.preventDefault(); 
                // It should now call beginVimRating(), just like the mouse click does.
                beginVimRating(); 
            } else if (!vimTaskInterfaceDiv.classList.contains('hidden')) {
                handleVimTaskInterfaceKeys(event);
            }
        });
        
        fineTuneSlider.addEventListener('input', (event) => { 
            if (currentTrialData && currentParameterKey) updateFineTuneImageVim(event.target.value); 
        });

        backToCoarseBtn.addEventListener('click', setupCoarseStepVim); 

        confirmSelectionBtn.addEventListener('click', () => {  
            if (!currentTrialData || !currentParameterKey) {
                console.error("Confirm button clicked with no trial/param context.");
                return;
            }
            // Store the fine-tuned level
            const currentSliderValue = parseInt(fineTuneSlider.value);
            const finalLevel = sliderToActualLevelMap[currentSliderValue - 1];
            
            if (!currentTrialResponses.parameter_responses) {
                currentTrialResponses.parameter_responses = {};
            }
            // We now store the response temporarily in a sub-object
            currentTrialResponses.parameter_responses[currentParameterKey] = {
                level: finalLevel
            };
            
            // Now, transition to the confidence rating step
            showConfidenceStep();
        });

        // ADD this new function to your script

        // REPLACE this function
        function showConfidenceStep() {
            clearAllFocus();
            // Hide the fine-tune UI elements
            fineTuneStepDiv.classList.add('hidden');
            // --- THIS IS THE FIX ---
            // Hide the individual buttons from the previous step
            backToCoarseBtn.classList.add('hidden');
            confirmSelectionBtn.classList.add('hidden');

            // Show the confidence UI elements
            confidenceStepDiv.classList.remove('hidden');
            confirmConfidenceBtn.classList.remove('hidden'); 
            confirmConfidenceBtn.disabled = true; 

            // Reset previous selection
            currentConfidenceSelection = null;
            likertButtons.forEach(btn => btn.classList.remove('selected'));

            // Set up keyboard focus
            currentFocusableElements = Array.from(likertButtons).concat(confirmConfidenceBtn);
            updateKeyboardFocus(3); // Start focus on button '4'
        }

        // ADD this new click handler to your script

        // REPLACE this entire event listener block

        confirmConfidenceBtn.addEventListener('click', () => {
            if (currentConfidenceSelection === null) return;

            // 1. Save the confidence rating to our data object
            if (currentTrialResponses.parameter_responses[currentParameterKey]) {
                currentTrialResponses.parameter_responses[currentParameterKey].confidence = currentConfidenceSelection;
            }

            // 2. Increment the parameter index
            currentParameterIndexInTask++;
            
            // 3. Let the main logic function decide what to do next
            loadNextParameterInVim();
        });

        // ADD this new event listener block for the Likert scale

        likertButtons.forEach(button => {
            button.addEventListener('click', () => {
                // Remove 'selected' from all buttons
                likertButtons.forEach(btn => btn.classList.remove('selected'));
                // Add 'selected' to the clicked button
                button.classList.add('selected');
                // Store the value
                currentConfidenceSelection = parseInt(button.dataset.value);
                // Enable the confirm button
                confirmConfidenceBtn.disabled = false;
                
                // Update keyboard focus to the clicked button
                const buttonIndex = Array.from(likertButtons).indexOf(button);
                if (buttonIndex !== -1) {
                    updateKeyboardFocus(buttonIndex);
                }
            });
        });

        function handleMainMenuKeys(event) {
            if (currentFocusableElements.length === 0) return;
            let handled = false;
            switch (event.key) {
                case "ArrowUp": case "ArrowDown":
                    updateKeyboardFocus(currentFocusedIndex === 0 ? 1 : 0);
                    handled = true;
                    break;
                case "Enter":
                    if (currentFocusedIndex >= 0) currentFocusableElements[currentFocusedIndex].click();
                    handled = true;
                    break;
            }
            if (handled) event.preventDefault();
        }

        function handleParameterSelectorKeys(event) {
            if (currentFocusableElements.length === 0) return;
            let handled = false;
            switch (event.key) {
                case "ArrowUp":
                    updateKeyboardFocus(currentFocusedIndex > 0 ? currentFocusedIndex - 1 : currentFocusableElements.length - 1);
                    handled = true;
                    break;
                case "ArrowDown":
                    updateKeyboardFocus(currentFocusedIndex < currentFocusableElements.length - 1 ? currentFocusedIndex + 1 : 0);
                    handled = true;
                    break;
                case "Enter":
                    if (currentFocusedIndex >= 0) currentFocusableElements[currentFocusedIndex].click();
                    handled = true;
                    break;
                case "Backspace": 
                    backToMenuFromTestSelectBtn.click();
                    handled = true;
                    break;
            }
            if (handled) event.preventDefault();
        }

        // REPLACE the existing handleVimTaskInterfaceKeys function with this one:
        function handleVimTaskInterfaceKeys(event) {
            let handled = false;
            // Logic for Coarse Selection Step
            if (!coarseStepDiv.classList.contains('hidden')) {
                // ... (This part remains exactly the same as your working version) ...
                if (!currentFocusableElements || currentFocusableElements.length === 0) return;
                let newFocusIndex = currentFocusedIndex;
                let arrowPressed = false;
                if (event.key === "ArrowLeft") { newFocusIndex = currentFocusedIndex > 0 ? currentFocusedIndex - 1 : currentFocusableElements.length - 1; arrowPressed = true; handled = true; } 
                else if (event.key === "ArrowRight") { newFocusIndex = currentFocusedIndex < currentFocusableElements.length - 1 ? currentFocusedIndex + 1 : 0; arrowPressed = true; handled = true; }
                if (arrowPressed) {
                    updateKeyboardFocus(newFocusIndex); 
                    const focusedButton = currentFocusableElements[currentFocusedIndex]; 
                    if (focusedButton) {
                        const level = parseInt(focusedButton.dataset.level);
                        if (!isNaN(level) && currentTrialData && currentParameterKey) {
                            coarsePreviewImg.src = getVariantImagePath(currentTrialData.base_image_id, currentParameterKey, level);
                            if (coarseImageDisplayP) coarseImageDisplayP.classList.add('hidden');
                        }
                    }
                } else if (event.key === "Enter") { 
                    if (currentFocusedIndex >= 0 && currentFocusableElements[currentFocusedIndex]) {
                        currentFocusableElements[currentFocusedIndex].click(); 
                        handled = true;
                    }
                }
                if (handled) event.preventDefault();
                return;
            } 
            // Logic for Fine-Tuning Step
            else if (!fineTuneStepDiv.classList.contains('hidden')) {
                // ... (This part remains exactly the same as your working version) ...
                const sliderStep = 1; 
                const sliderIsActiveFocus = document.activeElement === fineTuneSlider;
                switch (event.key) {
                    case "ArrowLeft": if (sliderIsActiveFocus) { fineTuneSlider.value = parseInt(fineTuneSlider.value) - sliderStep; fineTuneSlider.dispatchEvent(new Event('input')); handled = true; } break;
                    case "ArrowRight": if (sliderIsActiveFocus) { fineTuneSlider.value = parseInt(fineTuneSlider.value) + sliderStep; fineTuneSlider.dispatchEvent(new Event('input')); handled = true; } break;
                    case "Enter": confirmSelectionBtn.click(); handled = true; break;
                    case "Backspace": backToCoarseBtn.click(); handled = true; break;
                }
                if (handled) event.preventDefault();
            }
            // --- NEW LOGIC for Confidence Step ---
            else if (!confidenceStepDiv.classList.contains('hidden')) {
                let newFocusIndex = currentFocusedIndex;
                if (event.key === "ArrowLeft") {
                    if (currentFocusedIndex > 0) newFocusIndex = currentFocusedIndex - 1;
                    handled = true;
                } else if (event.key === "ArrowRight") {
                    if (currentFocusedIndex < currentFocusableElements.length - 1) newFocusIndex = currentFocusedIndex + 1;
                    handled = true;
                } else if (event.key === "Enter") {
                    if (currentFocusedIndex >= 0) {
                        currentFocusableElements[currentFocusedIndex].click(); // Select the button
                        if (!confirmConfidenceBtn.disabled) {
                            confirmConfidenceBtn.click(); // If a selection was made, also confirm
                        }
                    }
                    handled = true;
                }
                if (newFocusIndex !== currentFocusedIndex) {
                    updateKeyboardFocus(newFocusIndex);
                }
                if (handled) event.preventDefault();
            }
        }

    </script>
</body>
</html>