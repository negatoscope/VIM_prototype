<!DOCTYPE html>
<html lang="en" id="htmlTag">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VIM Prototype - Final Corrected</title>
    <style>
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; min-height: 100vh; margin: 0; padding: 10px; box-sizing: border-box; background-color: #f4f4f4; }
        .main-container { border: 1px solid #ccc; padding: 20px; text-align: center; background-color: white; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); width: 90%; max-width: 800px; margin-top: 20px; }
        /* This is the new top-level wrapper for our split-screen view */
        /* REPLACEMENT CSS RULES */

        .split-container {
            display: flex;
            flex-direction: row;
            align-items: stretch; /* Make panels equal height */
            justify-content: center;
            gap: 20px;
            width: 100%; /* Use the full browser width */
            height: calc(100vh - 40px); /* Fill the full screen height, minus some padding */
            padding: 20px;
            box-sizing: border-box; /* Include padding in the width/height calculation */
        }

        /* We also need to remove the fixed height from the image panel to let it be flexible */
        /*.image-panel {
            flex: 1; /* This is the key: it will grow to fill all available horizontal space */
            /*display: flex;
            align-items: center;
            justify-content: center;
            background-color: #eee;
            border-radius: 8px;
            /* The explicit height is removed. It will now be controlled by the parent. */
        /*}

        /* This is the new LEFT panel, which will hold the image */
        .image-panel {
            flex: 1; 
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: #eee;
            height: 90vh; /* Increased from 85vh */
            border-radius: 8px;
            /* padding: 10px;  <-- REMOVED to maximize space */
        }

        /* This is the new RIGHT panel, for all our text and buttons */
        .controls-panel {
            /* --- Your existing properties --- */
            flex: 0 0 400px; 
            border: 1px solid #ccc;
            padding: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            height: 85vh; 
            overflow-y: auto; 
            text-align: center;
            
            /* --- The new properties to add --- */
            display: flex;
            flex-direction: column;
        }

        /* This is the generic "spacer" that will push content apart.
        This is the most important missing piece. */
        .flex-spacer {
            flex-grow: 1; /* This makes the element take up all available empty vertical space */
        }

        /* This styles the container for the buttons at the bottom */
        .controls-bottom {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* We need to update the existing .image-display rules to work inside the new panels */
        /*.image-display {
            width: 100%;
            height: 100%; 
            margin-bottom: 0; /* No longer need margin */
        /* }

        .image-display img {
            max-width: 100%;
            max-height: 100%; 
            border: 1px solid black;
            object-fit: contain;
        /*} */

        .confidence-rating {
            margin-top: 20px;
        }

        .likert-scale {
            display: flex;
            justify-content: center;
            margin: 15px 0 5px 0;
        }

        .likert-button {
            padding: 10px;
            min-width: 40px; /* Give buttons a consistent width */
            background-color: #f0f0f0;
            color: #333;
            border: 1px solid #ccc;
        }

        .likert-button:hover {
            background-color: #e0e0e0;
        }

        /* Style for the selected confidence button */
        .likert-button.selected {
            background-color: #007bff;
            color: white;
            border-color: #007bff;
        }

        .likert-labels {
            display: flex;
            justify-content: space-between;
            max-width: 350px;
            margin: 0 auto;
            font-size: 14px;
            color: #555;
        }
        .image-display { display: flex; align-items: center; justify-content: center; background-color: #eee; min-height: 30vh; max-height:100%; width: 100%;}
        .image-display img { max-width: 100%; max-height: 100%; border: 1px solid black; object-fit: contain; }
        .slider-value-display {
            display: none;
        }
        .image-display p.preview-instruction { padding: 20px; color: #555; }
        button { margin: 5px; padding: 10px 15px; font-size: 16px; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 4px; }
        button:hover { background-color: #0056b3; }
        .control-group { margin-bottom: 15px; }
        .coarse-selection button { background-color: #6c757d;}
        .coarse-selection button:hover { background-color: #5a6268;}
        .fine-tuning input[type="range"] { width: 80%; max-width: 400px; margin-top: 10px;}
        .hidden { display: none !important; }
        #mainMenu button, #parameterSelector button { margin-bottom:10px; width: 200px;}
        #resultsDisplay ul { list-style-type: none; padding: 0;}
        #resultsDisplay li { margin-bottom: 5px; text-align: left; }
        #resultsDisplay li strong { display: block; margin-top: 10px; }
        .back-button { background-color: #6c757d; margin-top: 20px; }
        .back-button:hover { background-color: #545b62; }
        #fixationScreen, #preVimImageScreenDiv, #holdImageInstructionScreen, #conditionInstructionScreen { 
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            width: 100%; min-height: 60vh; font-size: 18px; line-height: 1.6;
        }
        #conditionInstructionScreen p { max-width: 80%; margin-bottom: 20px; }
        #fixationCross { font-size: 48px; }
        #preVimImageScreenDiv img { 
            max-width: 100%; 
            max-height: 100%; /* Allows image to fill the panel's height */
            border: 1px solid #ddd; 
            object-fit: contain; /* Ensures aspect ratio is maintained */
        }
        .keyboard-focus { outline: 3px solid dodgerblue; box-shadow: 0 0 8px dodgerblue; }
        #paramButtonsContainer { display: flex; flex-direction: column; align-items: center; }
        #paramButtonsContainer button { width: 80%; margin-bottom: 10px; }
        #languageSelector { position: absolute; bottom: 10px; right: 10px; z-index: 100; }
        #languageSelector button { font-size: 14px; padding: 5px 10px; width: auto; background-color: #f8f9fa; color: #333; border: 1px solid #ddd; }
        #languageSelector button.active-lang { background-color: #007bff; color: white; border-color: #007bff;}
        /* --- NEW --- */
        #downloadResultsBtn { background-color: #28a745; margin-top: 20px; }
        #downloadResultsBtn:hover { background-color: #218838; }
        /* ADD THIS NEW RULE */
        #fineTuneActionButtons {
            display: flex;
            flex-direction: row;
            justify-content: center;
        }
    </style>
</head>
<body id="htmlTag" lang="en">

    <div id="languageSelector">
        <button data-lang="en">English</button>
        <button data-lang="es">Español</button>
    </div>

    <div id="mainMenu" class="main-container">
        <h1 data-lang-key="mainMenuTitle"></h1>
        <p data-lang-key="mainMenuWelcome"></p>
        <button id="testParameterBtn" data-lang-key="testParamButton"></button><br>
        <button id="startActualTaskBtn" data-lang-key="startTaskButton"></button>
        <p id="setInfo" style="margin-top: 20px; font-size: 12px; color: #888;"></p>
    </div>

    <!-- ADD THIS FIRST NEW BLOCK: The Welcome Screen -->
    <div id="welcomeScreen" class="main-container hidden">
        <h1 data-lang-key="welcomeTitle">Welcome!</h1>
        <p data-lang-key="welcomeInstructions"></p>
        <button id="startInstructionsBtn" data-lang-key="continueButton">Continue</button>
    </div>

    <!-- ADD THIS SECOND NEW BLOCK: The How-To Explanation Screen -->
    <div id="howToScreen" class="main-container hidden">
        <h2 data-lang-key="howToTitle">How the Task Works</h2>
        <div style="text-align: left; max-width: 600px; margin: 20px auto;">
            <p data-lang-key="howToStep1"></p>
            <p data-lang-key="howToStep2"></p>
            <p data-lang-key="howToStep3"></p>
        </div>
        <button id="startTutorialBtn" data-lang-key="startPracticeButton">Start Practice Round</button>
    </div>

    <div id="readyScreen" class="main-container hidden">
        <h2 data-lang-key="readyTitle"></h2>
        <p data-lang-key="readyText"></p>
        <button id="startExperimentBtn" data-lang-key="startExperimentButton"></button>
    </div>

    <div id="parameterSelector" class="main-container hidden">
        <h2 data-lang-key="paramSelectorTitle"></h2>
        <div id="paramButtonsContainer"></div>
        <button id="backToMenuFromTestSelectBtn" class="back-button" data-lang-key="backToMenuButton"></button>
    </div>

    <div id="conditionInstructionScreen" class="main-container hidden">
        <h2 id="conditionInstructionTitle"></h2>
        <p id="conditionInstructionText"></p>
        <button id="startTrialFromInstructionsBtn" data-lang-key="trialContinueButton"></button>
    </div>

    <!-- This container now uses the 'split-container' class for the two-panel layout -->
    <div id="preVimScreenContainer" class="split-container hidden">

        <!-- The LEFT panel will hold the visual stimuli (fixation and image) -->
        <div class="image-panel">
            <div id="fixationScreen" class="hidden"><div id="fixationCross">+</div></div>
            <div id="preVimImageScreenDiv" class="hidden"><img id="originalImageDisplay" src="" alt="Original Image"></div>
        </div>

        <!-- The RIGHT panel will hold the text prompt and button -->
        <div class="controls-panel">
            <div id="holdImageInstructionScreen" class="hidden">
                <p id="holdImagePrompt" style="margin-top: 20vh;"></p> <!-- Added style to vertically center the prompt a bit -->
                <button id="holdImageContinueBtn" data-lang-key="trialContinueButton"></button>
            </div>
        </div>

    </div>
    
    <div id="vimTaskInterface" class="split-container hidden">

        <!-- 1. The new LEFT panel for the image -->
        <div class="image-panel">
            
            <!-- MOVE THE COARSE IMAGE DISPLAY HERE -->
            <div class="image-display" id="coarseImageDisplay">
                <p class="preview-instruction" data-lang-key="coarsePreviewText"></p> 
                <img id="coarsePreviewImg" src="" alt="Press Arrow/Hover Mouse">
            </div>

            <!-- MOVE THE FINE-TUNE IMAGE DISPLAY HERE (and hide it) -->
            <div class="image-display hidden" id="fineTuneImageDisplay">
                <img id="fineTuneImg" src="" alt="Fine-tuned image">
            </div>

        </div>

        <!-- 2. The new RIGHT panel for the controls -->
        <div class="controls-panel">
            <!-- TOP SECTION -->
            <h2 id="currentParamDisplay">Parameter: <span></span></h2>
            <p id="vimGeneralInstruction"></p> 

            <!-- ADD THIS FIRST SPACER to push the middle section down -->
            <div class="flex-spacer"></div>

            <!-- MIDDLE SECTION (Interactive Elements) -->
            <div id="coarseStep" class="coarse-selection control-group">
                <p><span data-lang-key="vimCoarsePrompt"></span> <strong id="coarseParamName"></strong>:</p>
                <button data-level-key="low"><span data-lang-key="coarseButtonLow"></span></button>
                <button data-level-key="mid"><span data-lang-key="coarseButtonMid"></span></button>
                <button data-level-key="high"><span data-lang-key="coarseButtonHigh"></span></button>
            </div>

            <div id="fineTuneStep" class="fine-tuning control-group hidden">
                <p><span data-lang-key="fineTunePrompt"></span> <strong id="fineTuneParamName"></strong>:</p>
                <input type="range" id="fineTuneSlider" min="1" max="7" value="4">
                <!-- This is the line you correctly fixed -->
                <p class="slider-value-display"><span id="fineTuneLevelDisplay"></span></p>
                <!-- NOTE: The two buttons that were here have been moved to the bottom -->
            </div>

            <!-- ADD THIS ENTIRE NEW BLOCK -->
            <div id="confidenceStep" class="confidence-rating control-group hidden">
                <p id="confidencePrompt"></p>
                <div class="likert-scale">
                    <button class="likert-button" data-value="1">1</button>
                    <button class="likert-button" data-value="2">2</button>
                    <button class="likert-button" data-value="3">3</button>
                    <button class="likert-button" data-value="4">4</button>
                    <button class="likert-button" data-value="5">5</button>
                    <button class="likert-button" data-value="6">6</button>
                    <button class="likert-button" data-value="7">7</button>
                </div>
                <div class="likert-labels">
                    <span id="likertLabelLow"></span>
                    <span id="likertLabelHigh"></span>
                </div>
            </div>

            <!-- This new spacer element pushes everything below it to the bottom -->
            <div class="flex-spacer"></div>

            <!-- BOTTOM SECTION (Action Buttons) -->
            <div class="controls-bottom">
                <!-- This new wrapper will hold the side-by-side buttons -->
                <div id="fineTuneActionButtons">
                    <button id="backToCoarseBtn" data-lang-key="backToCoarseButton"></button>
                    <button id="confirmSelectionBtn" data-lang-key="confirmLevelButton"></button>
                    <button id="confirmConfidenceBtn" data-lang-key="confirmConfidenceButton" class="hidden"></button>
                </div>
                <button id="backToMenuFromTaskBtn" class="back-button" data-lang-key="exitTaskButton"></button>
            </div>
        </div>

    </div>

    <div id="resultsDisplay" class="main-container hidden">
        <h2 data-lang-key="resultsTitle"></h2>
        <ul id="resultsList"></ul>
        <!-- --- NEW --- -->
        <p id="saveStatus" style="font-style: italic; color: #555;"></p>
        <button id="downloadResultsBtn" data-lang-key="downloadResultsButton">Download Results</button>
        <button id="backToMenuFromResultsBtn" class="back-button hidden" data-lang-key="backToMenuButton"></button>
    </div>

    <script>

        // --- CONFIGURATION AND STATE MANAGEMENT ---
        const DEBUG_SHOW_RESULTS = false; // Set to true to show results for debugging
        
        // REPLACE your existing LANG_STRINGS object

        const LANG_STRINGS = {
            "en": {
                // --- Existing Strings ---
                mainMenuTitle: "Visual Quality Rating Task", mainMenuWelcome: "Welcome! Please read the general instructions before starting.", testParamButton: "Test Single Parameter", startTaskButton: "Start Full Task (12 Trials)", paramSelectorTitle: "Select Parameter to Test", conditionInstructionTitle: "Instructions: {condition} Task", trialContinueButton: "Continue", holdImagePrompt_recall: "Please keep the image you just saw in your mind. Press Continue when ready.", holdImagePrompt_imagine: "Once you have formed a clear mental image of the scene as instructed, press Continue.", vimGeneralInstruction: "Please keep the image of your {sceneType} in your mind.", vimCoarsePrompt: "Select the image that best represents the overall level for", coarseButtonLow: "Low", coarseButtonMid: "Medium", coarseButtonHigh: "High", coarsePreviewText: "Hover over buttons to preview, click to select.", fineTunePrompt: "Now, fine-tune your selection for", selectedLevelLabel: "Selected Level:", backToCoarseButton: "Back to Coarse Selection", confirmLevelButton: "Confirm This Level", backToMenuButton: "Back to Main Menu", exitTaskButton: "Back to Main Menu (Exit Task)", exitConfirmMessage: "Are you sure you want to exit the current task and return to the main menu? Progress will be lost.", resultsTitle: "Trial Results", downloadResultsButton: "Download Results", confidencePrompt: "How confident are you in your selection?", likertLabelLow: "Not at all confident", likertLabelHigh: "Completely confident", confirmConfidenceButton: "Confirm Confidence",
                // --- New Onboarding Strings ---
                welcomeTitle: "Welcome!",
                welcomeInstructions: "Thank you for participating. This experiment investigates the nature of mental imagery. It will take approximately 15-20 minutes. You will first complete a short, interactive practice round, followed by the 12 main trials.",
                continueButton: "Continue",
                howToTitle: "How the Task Works",
                howToStep1: "1. You will be asked to remember or imagine a scene. Please try to form as clear a mental image as you can.",
                howToStep2: "2. You will then adjust an image on the screen to match the qualities of your mental image (e.g., its brightness, blurriness, etc.).",
                howToStep3: "3. After each adjustment, you will rate how confident you are in your choice.",
                startPracticeButton: "Start Practice Round",
                readyTitle: "Practice Complete",
                readyText: "You have completed the practice round. The main experiment will now begin. Remember to take your time and answer as accurately as possible.",
                startExperimentButton: "Start Experiment"
            },
            "es": {
                // --- Existing Strings ---
                mainMenuTitle: "Tarea de Calificación de Calidad Visual", mainMenuWelcome: "¡Bienvenido/a! Por favor, lea las instrucciones generales antes de comenzar.", testParamButton: "Probar un Parámetro", startTaskButton: "Comenzar Tarea Completa (12 Ensayos)", paramSelectorTitle: "Seleccione el Parámetro a Probar", conditionInstructionTitle: "Instrucciones: Tarea de {condition}", trialContinueButton: "Continuar", holdImagePrompt_recall: "Por favor, mantenga la imagen que acaba de ver en su mente. Presione Continuar cuando esté listo/a.", holdImagePrompt_imagine: "Una vez que haya formado una imagen mental clara de la escena como se le indicó, presione Continuar.", vimGeneralInstruction: "Por favor, mantenga la imagen de su {sceneType} en su mente.", vimCoarsePrompt: "Seleccione la imagen que mejor represente el nivel general para", coarseButtonLow: "Bajo", coarseButtonMid: "Medio", coarseButtonHigh: "Alto", coarsePreviewText: "Pase el cursor sobre los botones para previsualizar, haga clic para seleccionar.", fineTunePrompt: "Ahora, ajuste su selección para", selectedLevelLabel: "Nivel Seleccionado:", backToCoarseButton: "Volver a Selección General", confirmLevelButton: "Confirmar este Nivel", backToMenuButton: "Volver al Menú Principal", exitTaskButton: "Volver al Menú Principal (Salir de la Tarea)", exitConfirmMessage: "¿Está seguro/a de que desea salir de la tarea actual y volver al menú principal? El progreso se perderá.", resultsTitle: "Resultados de los Ensayos", downloadResultsButton: "Descargar Resultados", confidencePrompt: "¿Qué tan seguro/a está de su selección?", likertLabelLow: "Nada seguro/a", likertLabelHigh: "Completamente seguro/a", confirmConfidenceButton: "Confirmar Confianza",
                // --- New Onboarding Strings ---
                welcomeTitle: "¡Bienvenido/a!",
                welcomeInstructions: "Gracias por participar. Este experimento investiga la naturaleza de las imágenes mentales. Tomará aproximadamente 15-20 minutos. Primero completará una breve ronda de práctica interactiva, seguida de los 12 ensayos principales.",
                continueButton: "Continuar",
                howToTitle: "Cómo Funciona la Tarea",
                howToStep1: "1. Se le pedirá que recuerde o imagine una escena. Por favor, intente formar la imagen mental más clara posible.",
                howToStep2: "2. Luego, ajustará una imagen en la pantalla para que coincida con las cualidades de su imagen mental (por ejemplo, su brillo, desenfoque, etc.).",
                howToStep3: "3. Después de cada ajuste, calificará qué tan seguro/a está de su elección.",
                startPracticeButton: "Comenzar Ronda de Práctica",
                readyTitle: "Práctica Completada",
                readyText: "Ha completado la ronda de práctica. El experimento principal comenzará ahora. Recuerde tomarse su tiempo y responder con la mayor precisión posible.",
                startExperimentButton: "Comenzar Experimento"
            }
        };

        // REPLACE your existing PARAMETERS object

        const PARAMETERS = {
            saturation:   { name: {en: "Saturation", es: "Saturación"}, levels: 21, coarse: { low: 4, mid: 11, high: 18 }, parameter_specific_instruction: {en: "how colorful or saturated it was.", es: "qué tan colorido o saturado era."}},
            brightness:   { name: {en: "Brightness", es: "Brillo"}, levels: 21, coarse: { low: 4, mid: 11, high: 18 }, parameter_specific_instruction: {en: "how bright or dim it appeared.", es: "qué tan brillante u oscuro parecía."}},
            contrast:     { name: {en: "Contrast", es: "Contraste"}, levels: 21, coarse: { low: 4, mid: 11, high: 18 }, parameter_specific_instruction: {en: "the difference between light and dark areas.", es: "la diferencia entre áreas claras y oscuras."}},
            blurriness:   { name: {en: "Blurriness", es: "Desenfoque"}, levels: 21, coarse: { low: 4, mid: 11, high: 18 }, parameter_specific_instruction: {en: "how sharp or out-of-focus it was.", es: "qué tan nítido o desenfocado estaba."}},
            detailedness: { name: {en: "Detailedness", es: "Nivel de Detalle"}, levels: 21, coarse: { low: 4, mid: 11, high: 18 }, parameter_specific_instruction: {en: "how rich in fine features and textures it was.", es: "qué tan rico en detalles finos y texturas era."}},
            precision:    { name: {en: "Color Precision", es: "Precisión de Color"}, levels: 21, coarse: { low: 4, mid: 11, high: 18 }, parameter_specific_instruction: {en: "how specific or ambiguous the colors were.", es: "qué tan específicos o ambiguos eran los colores."}},
            // --- THIS IS THE NEW ATTENTION CHECK PARAMETER ---
            attention_check: { name: {en: "Attention Check", es: "Prueba de Atención"}, levels: 21, coarse: { low: 4, mid: 11, high: 18 }, 
                parameter_specific_instruction: {
                    en: "For this check, please select the 'Medium' button, then move the slider to level 11.", 
                    es: "Para esta prueba, por favor seleccione el botón 'Medio', y luego mueva el deslizador al nivel 11."
                },
                is_attention_check: true // Flag to identify this special parameter
            }
        };
        
        // ADD THIS NEW DATA OBJECT (replaces the old allTrialsMasterList)

        const IMAGE_DATA = [
            // --- INDOOR IMAGES (6) ---
            { id: 'image01', type: 'indoor', filename: 'image01.png', prompts: {
                episodic_recall:   {en: "Please recall a recent, vivid memory of relaxing in a LIVING ROOM with friends or family present. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria reciente y vívida de estar relajándose en una SALA DE ESTAR con amigos o familiares. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine a quiet, empty LIVING ROOM in the middle of the day, with sunlight coming through a window. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine una SALA DE ESTAR tranquila y vacía a mediodía, con la luz del sol entrando por una ventana. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image03', type: 'indoor', filename: 'image03.png', prompts: {
                episodic_recall:   {en: "Please recall a specific, vivid memory of being in a CLASSROOM, listening to a lesson. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria específica y vívida de estar en un AULA, escuchando una lección. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine an old, empty CLASSROOM after school, with chalk dust on the blackboard. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine un AULA vieja y vacía después de clases, con polvo de tiza en la pizarra. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image04', type: 'indoor', filename: 'image04.png', prompts: {
                episodic_recall:   {en: "Please recall a recent, vivid memory of pushing a shopping cart through a busy SUPERMARKET. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria reciente y vívida de estar empujando un carrito de compras en un SUPERMERCADO concurrido. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine standing in a SUPERMARKET aisle late at night, with almost no one else around. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine que está en el pasillo de un SUPERMERCADO por la noche, casi sin nadie más alrededor. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image08', type: 'indoor', filename: 'image08.png', prompts: {
                episodic_recall:   {en: "Please recall a vivid memory of looking for a specific item in a SUPERMARKET AISLE. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria vívida de estar buscando un artículo específico en un PASILLO DE SUPERMERCADO. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine a brightly lit and perfectly organized SUPERMARKET AISLE that is completely empty. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine un PASILLO DE SUPERMERCADO perfectamente ordenado y muy iluminado, que está completamente vacío. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image09', type: 'indoor', filename: 'image09.png', prompts: {
                episodic_recall:   {en: "Please recall a vivid memory of having a conversation in a comfortable LIVING ROOM. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria vívida de tener una conversación en una SALA DE ESTAR cómoda. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine a minimalist LIVING ROOM with modern furniture and no personal items. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine una SALA DE ESTAR minimalista con muebles modernos y sin objetos personales. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image12', type: 'indoor', filename: 'image12.png', prompts: {
                episodic_recall:   {en: "Please recall a vivid memory of working on a group project with other students in a CLASSROOM. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria vívida de trabajar en un proyecto grupal con otros estudiantes en un AULA. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine the first day of school, in a CLASSROOM filled with students finding their seats. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine el primer día de clases, en un AULA llena de estudiantes buscando sus asientos. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los los ojos y presione Continuar."}
            }},
            // --- OUTDOOR IMAGES (6) ---
            { id: 'image02', type: 'outdoor', filename: 'image02.png', prompts: {
                episodic_recall:   {en: "Please recall a vivid memory of walking down an empty CITY STREET early in the morning. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria vívida de caminar por una CALLE de una CIUDAD vacía temprano en la mañana. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine a wide CITY STREET in a futuristic city, with sleek, silent vehicles. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine una CALLE ancha en una CIUDAD futurista, con vehículos elegantes y silenciosos. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image05', type: 'outdoor', filename: 'image05.png', prompts: {
                episodic_recall:   {en: "Please recall a vivid memory of standing on a BEACH, feeling the spray from the waves. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria vívida de estar en una PLAYA, sintiendo la brisa de las olas. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine a secret BEACH on a tropical island, with a hidden waterfall and no footprints in the sand. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine una PLAYA secreta en una isla tropical, con una cascada escondida y sin huellas en la arena. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image06', type: 'outdoor', filename: 'image06.png', prompts: {
                episodic_recall:   {en: "Please recall a vivid memory of having a picnic or relaxing in a lush, green PARK. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria vívida de tener un picnic o relajarse en un PARQUE verde y frondoso. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine a vast botanical PARK with many strange and colorful exotic plants you've never seen before. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine un vasto PARQUE botánico con muchas plantas exóticas, extrañas y coloridas que nunca ha visto. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image07', type: 'outdoor', filename: 'image07.png', prompts: {
                episodic_recall:   {en: "Please recall a vivid memory of a pleasant walk through a PARK on a cool autumn day. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria vívida de un paseo agradable por un PARQUE en un día fresco de otoño. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine a PARK in the middle of winter, with bare trees and a light dusting of snow on the ground. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine un PARQUE en pleno invierno, con árboles sin hojas y una fina capa de nieve en el suelo. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image10', type: 'outdoor', filename: 'image10.png', prompts: {
                episodic_recall:   {en: "Please recall a vivid memory of being in a crowd on a BUSY CITY STREET. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria vívida de estar entre una multitud en una CALLE CONCURRIDA de una CIUDAD. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine a BUSY CITY STREET during a parade, with confetti in the air and music playing. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine una CALLE CONCURRIDA de una CIUDAD durante un desfile, con confeti en el aire y música sonando. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }},
            { id: 'image11', type: 'outdoor', filename: 'image11.png', prompts: {
                episodic_recall:   {en: "Please recall a vivid memory of playing or building a sandcastle on a sunny BEACH. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, recuerde una memoria vívida de jugar o construir un castillo de arena en una PLAYA soleada. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."},
                scene_imagination: {en: "Please imagine a BEACH at sunset, with the sky full of orange and purple colors. Close your eyes to form a clear image. When you have it, open your eyes and press Continue.", es: "Por favor, imagine una PLAYA al atardecer, con el cielo lleno de colores naranjas y morados. Cierre los ojos para formar una imagen clara. Cuando la tenga, abra los ojos y presione Continuar."}
            }}
        ];

        const GOOGLE_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbwkcpn2kATIjVlfgGAT6um4sN2LOcTU6Qde2vj8mKzd19VtfVxHynh3KR-qMBuNeanSkQ/exec';
        const saveStatus = document.getElementById('saveStatus');

        let currentLanguage = 'en';
        const imageBaseFolder = "images"; 
        const imageExtension = ".png";
        const fineTuneRange = 3; 
        let currentSessionTrials = []; 
        let currentGlobalTrialIndex = 0; 
        let currentTrialData = null;     
        let currentTrialResponses = {};  
        let allCollectedResponses = [];  
        let currentTaskMode = null; 
        // --- NEW ---
        let sessionID = null;
        let currentParameterKey = null;
        let currentParameterConfig = null;
        let actualTaskOrder = []; 
        let currentParameterIndexInTask = 0; 
        let currentFocusableElements = [];
        let currentFocusedIndex = -1;      
        const KEYBOARD_FOCUS_CLASS = 'keyboard-focus';
        const isTouchDevice = (('ontouchstart' in window) || (navigator.maxTouchPoints > 0));

        // --- DOM Elements ---
        const mainMenuDiv = document.getElementById('mainMenu');
        const parameterSelectorDiv = document.getElementById('parameterSelector');
        const paramButtonsContainer = document.getElementById('paramButtonsContainer');
        const vimTaskInterfaceDiv = document.getElementById('vimTaskInterface');
        const resultsDisplayDiv = document.getElementById('resultsDisplay');
        // --- NEW ---
        const downloadResultsBtn = document.getElementById('downloadResultsBtn');
        const conditionInstructionScreenDiv = document.getElementById('conditionInstructionScreen');
        const conditionInstructionTitleH2 = document.getElementById('conditionInstructionTitle');
        const conditionInstructionTextP = document.getElementById('conditionInstructionText');
        const startTrialFromInstructionsBtn = document.getElementById('startTrialFromInstructionsBtn');
        const preVimScreenContainerDiv = document.getElementById('preVimScreenContainer');
        const fixationScreenDiv = document.getElementById('fixationScreen');
        const preVimImageScreenDiv = document.getElementById('preVimImageScreenDiv');
        const originalImageDisplayImg = document.getElementById('originalImageDisplay');
        const holdImageInstructionScreenDiv = document.getElementById('holdImageInstructionScreen');
        const holdImagePromptP = document.getElementById('holdImagePrompt');
        const holdImageContinueBtn = document.getElementById('holdImageContinueBtn');
        const vimGeneralInstructionP = document.getElementById('vimGeneralInstruction');
        const currentParamDisplay = document.getElementById('currentParamDisplay').querySelector('span');
        const coarseStepDiv = document.getElementById('coarseStep');
        const coarseParamNameStrong = document.getElementById('coarseParamName');
        const coarseButtons = coarseStepDiv.querySelectorAll('button');
        const coarsePreviewImg = document.getElementById('coarsePreviewImg');
        const coarseImageDisplayP = document.querySelector('#coarseImageDisplay p.preview-instruction');
        const paramNameInlineSpans = document.querySelectorAll('.param-name-inline');
        const fineTuneStepDiv = document.getElementById('fineTuneStep');
        const fineTuneParamNameStrong = document.getElementById('fineTuneParamName');
        const fineTuneImg = document.getElementById('fineTuneImg');
        const fineTuneSlider = document.getElementById('fineTuneSlider');
        const fineTuneLevelDisplay = document.getElementById('fineTuneLevelDisplay');
        const backToCoarseBtn = document.getElementById('backToCoarseBtn');
        const confirmSelectionBtn = document.getElementById('confirmSelectionBtn');
        const resultsListUl = document.getElementById('resultsList');
        const backToMenuFromTestSelectBtn = document.getElementById('backToMenuFromTestSelectBtn');
        const backToMenuFromTaskBtn = document.getElementById('backToMenuFromTaskBtn');
        const backToMenuFromResultsBtn = document.getElementById('backToMenuFromResultsBtn');

        let currentCoarseSelectionLevel = null;
        let sliderToActualLevelMap = [];

        // ADD these new variable definitions at the top of the script
        const confidenceStepDiv = document.getElementById('confidenceStep');
        const likertButtons = document.querySelectorAll('.likert-button');
        const confirmConfidenceBtn = document.getElementById('confirmConfidenceBtn');
        let currentConfidenceSelection = null;

        const welcomeScreen = document.getElementById('welcomeScreen');
        const howToScreen = document.getElementById('howToScreen');

        // --- Utility Functions ---
        function shuffleArray(array) { 
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        // REPLACE your existing getVariantImagePath function with this one

        function getVariantImagePath(baseImageId, paramKey, level) { 
            // --- THIS IS THE FIX ---
            // If the parameter is an attention check, we need to get an image from a REAL parameter's folder.
            // We can just default to using the 'brightness' folder for this purpose.
            const folderParam = paramKey === 'attention_check' ? 'brightness' : paramKey;

            const levelStr = level < 10 ? '0' + level : level.toString();
            
            // Construct the path using the corrected folder parameter.
            return `${imageBaseFolder}/${folderParam}/${baseImageId}_${folderParam}_${levelStr}${imageExtension}`;
        }

        function getOriginalImagePath(originalFilename) { 
            return `${imageBaseFolder}/originals/${originalFilename}`;
        }
        
        function resetFullTaskState() { 
            currentTrialData = null;
            currentTrialResponses = {};
            currentTaskMode = null;
            // --- MODIFIED ---
            sessionID = null; 
            currentParameterKey = null;
            currentParameterConfig = null;
            actualTaskOrder = [];
            currentParameterIndexInTask = 0;
            currentSessionTrials = [];
            currentGlobalTrialIndex = 0;
            allCollectedResponses = []; 
            console.log("Full task state reset.");
        }

        // ADD THIS NEW HELPER FUNCTION
        function clearAllFocus() {
            // This function finds ANY element that currently has the focus class and removes it.
            const focusedEl = document.querySelector('.' + KEYBOARD_FOCUS_CLASS);
            if (focusedEl) {
                focusedEl.classList.remove(KEYBOARD_FOCUS_CLASS);
            }
            // It also resets the global tracking variables for safety.
            currentFocusableElements = [];
            currentFocusedIndex = -1;
        }

        function updateKeyboardFocus(newIndex) {
            if (currentFocusableElements && currentFocusableElements[currentFocusedIndex]) {
                currentFocusableElements[currentFocusedIndex].classList.remove(KEYBOARD_FOCUS_CLASS);
            }
            currentFocusedIndex = newIndex;
            if (currentFocusableElements && currentFocusableElements[currentFocusedIndex]) {
                currentFocusableElements[currentFocusedIndex].classList.add(KEYBOARD_FOCUS_CLASS);
                currentFocusableElements[currentFocusedIndex].focus(); // Also set browser focus
            }
        }

        function setupMainMenuFocus() {
            currentFocusableElements = [document.getElementById('testParameterBtn'), document.getElementById('startActualTaskBtn')];
            updateKeyboardFocus(0);
        }
        
        function setupParameterSelectorFocus() {
            currentFocusableElements = Array.from(paramButtonsContainer.querySelectorAll('button'));
            updateKeyboardFocus(currentFocusableElements.length > 0 ? 0 : -1);
        }
        
        function setupCoarseStepFocus() {
            currentFocusableElements = Array.from(coarseStepDiv.querySelectorAll('button[data-level-key]'));
            let initialFocus = currentFocusableElements.length > 1 ? 1 : (currentFocusableElements.length === 1 ? 0 : -1);
            updateKeyboardFocus(initialFocus);
            if (initialFocus !== -1 && !isTouchDevice) {
                currentFocusableElements[initialFocus].dispatchEvent(new Event('mouseover'));
            }
        }

        
        // REPLACE your existing showDiv function with this one

        function showDiv(divToShow) { 
            // This list now includes all possible screens that can be shown.
            [mainMenuDiv, welcomeScreen, howToScreen, document.getElementById('readyScreen'),
            parameterSelectorDiv, vimTaskInterfaceDiv, resultsDisplayDiv, 
            preVimScreenContainerDiv, conditionInstructionScreenDiv].forEach(div => {
                if(div) div.classList.add('hidden');
            });

            if (currentFocusableElements && currentFocusableElements[currentFocusedIndex]) {
                currentFocusableElements[currentFocusedIndex].classList.remove(KEYBOARD_FOCUS_CLASS);
            }
            currentFocusableElements = []; currentFocusedIndex = -1;

            if (divToShow) {
                divToShow.classList.remove('hidden');
                if (divToShow === mainMenuDiv) setupMainMenuFocus();
                else if (divToShow === parameterSelectorDiv) setupParameterSelectorFocus();
                else if (divToShow === conditionInstructionScreenDiv) {
                    currentFocusableElements = [startTrialFromInstructionsBtn];
                    updateKeyboardFocus(0);
                } else if (divToShow === vimTaskInterfaceDiv && !coarseStepDiv.classList.contains('hidden')) {
                    setupCoarseStepFocus();
                }
            }
        }
        // --- LANGUAGE SWITCHING ---
        function setLanguage(lang) {
            currentLanguage = lang;
            document.getElementById('htmlTag').lang = lang; 

            document.querySelectorAll('#languageSelector button').forEach(btn => {
                btn.classList.toggle('active-lang', btn.dataset.lang === lang);
            });

            document.querySelectorAll('[data-lang-key]').forEach(el => {
                const key = el.dataset.langKey;
                if (LANG_STRINGS[currentLanguage] && LANG_STRINGS[currentLanguage][key]) {
                    el.textContent = LANG_STRINGS[currentLanguage][key];
                }
            });

            if (!parameterSelectorDiv.classList.contains('hidden')) {
                populateParameterSelector();
            }

            document.getElementById('confidencePrompt').textContent = LANG_STRINGS[lang].confidencePrompt;
            document.getElementById('likertLabelLow').textContent = LANG_STRINGS[lang].likertLabelLow;
            document.getElementById('likertLabelHigh').textContent = LANG_STRINGS[lang].likertLabelHigh;
        }

        // --- Core Application Logic ---

        function showConditionInstructions(trialDataObject) {
            currentTrialData = trialDataObject; 
            if (!currentTrialData) {
                console.error("showConditionInstructions called with invalid trialData!");
                return;
            }

            const conditionName = {
                en: currentTrialData.condition.replace(/_/g, ' '),
                es: currentTrialData.condition === "perceptual_recall" ? "Recuerdo Perceptual" : 
                    currentTrialData.condition === "episodic_recall" ? "Recuerdo Episódico" : "Imaginación de Escena"
            }[currentLanguage];

            let titlePrefix = currentTaskMode === 'test' ? "Test Mode" : `Trial ${currentGlobalTrialIndex + 1} of ${currentSessionTrials.length}`;
            conditionInstructionTitleH2.textContent = `${titlePrefix}: ${conditionName}`;
            conditionInstructionTextP.textContent = currentTrialData.condition_instruction[currentLanguage];
            showDiv(conditionInstructionScreenDiv);
            currentFocusableElements = [startTrialFromInstructionsBtn];
            updateKeyboardFocus(0);
        }

        // REPLACE this event listener
        startTrialFromInstructionsBtn.addEventListener('click', () => {
            if (!currentTrialData) return;
            if (currentTrialData.condition === "perceptual_recall") {
                startPreVimPhase(currentTrialData);
            } else { 
                currentTrialResponses = { 
                    trial_id: currentTrialData.trial_id, condition: currentTrialData.condition,
                    image_id: currentTrialData.base_image_id, parameter_responses: {}
                };
                // It now calls our single, unified function.
                beginVimRating();
            }
        });

        // --- Pre-VIM Task Flow ---
        // REPLACE this function
        function startPreVimPhase(trialData) {
            currentTrialResponses = { 
                trial_id: trialData.trial_id, 
                condition: trialData.condition,
                image_id: trialData.base_image_id, 
                parameter_responses: {}
            };
            
            showDiv(preVimScreenContainerDiv);
            
            fixationScreenDiv.classList.add('hidden');
            preVimImageScreenDiv.classList.add('hidden');
            holdImageInstructionScreenDiv.classList.add('hidden');

            fixationScreenDiv.classList.remove('hidden'); 
            
            setTimeout(() => { 
                fixationScreenDiv.classList.add('hidden');
                preVimImageScreenDiv.classList.remove('hidden');
                originalImageDisplayImg.src = getOriginalImagePath(trialData.original_image_filename);
                
                setTimeout(() => { 
                    preVimImageScreenDiv.classList.add('hidden');
                    originalImageDisplayImg.src = ""; 
                    
                    holdImagePromptP.textContent = LANG_STRINGS[currentLanguage].holdImagePrompt_recall;
                    holdImageInstructionScreenDiv.classList.remove('hidden');
                    
                    currentFocusableElements = [holdImageContinueBtn];
                    updateKeyboardFocus(0);

                }, 1000); // Image display duration: 4 seconds
            }, 2000); // Fixation duration: 1 second
        }

        // REPLACE these two items
        holdImageContinueBtn.addEventListener('click', () => {
            // It now calls our single, unified function.
            beginVimRating();
        });

        // The advanceFromHoldScreen function is no longer needed and can be deleted.

        // --- VIM Parameter Rating Functions ---

        // REPLACE your existing beginVimRating function with this one

        function beginVimRating() {
            if (currentTaskMode === 'tutorial') {
                actualTaskOrder = ['brightness'];
            } else if (currentTaskMode === 'test') {
                actualTaskOrder = [currentParameterKey];
            } else { 
                const realParameters = Object.keys(PARAMETERS).filter(p => p !== 'attention_check');
                let parametersForThisTrial = shuffleArray(realParameters);
                
                // --- THIS IS THE NEW LOGIC ---
                // If the trial is tagged, simply add the attention check as the 7th and final parameter.
                if (currentTrialData.has_attention_check) {
                    parametersForThisTrial.push('attention_check');
                }
                actualTaskOrder = parametersForThisTrial;
            }

            // This part of the logic remains the same
            const sceneTypeKey = currentTrialData.condition === "perceptual_recall" ? "recalled photo" 
                : currentTrialData.condition === "Practice" ? "practice image" 
                : "mental scene";
            const sceneTypeString = {en: sceneTypeKey, es: sceneTypeKey.replace("photo", "foto").replace("image", "imagen").replace("scene", "escena")}[currentLanguage];
            vimGeneralInstructionP.textContent = LANG_STRINGS[currentLanguage].vimGeneralInstruction.replace('{sceneType}', sceneTypeString);
            
            showDiv(vimTaskInterfaceDiv);
            currentParameterIndexInTask = 0;
            loadNextParameterInVim();
        }

        // REPLACE this function
        function loadNextParameterInVim() { 
            if (currentParameterIndexInTask < actualTaskOrder.length) {
                // More parameters to rate for the current trial
                currentParameterKey = actualTaskOrder[currentParameterIndexInTask];
                currentParameterConfig = PARAMETERS[currentParameterKey];
                setupCoarseStepVim(); 
            } else {
                // --- All parameters for the current trial are FINISHED ---
                if (currentTaskMode === 'actual_task_full') {
                    allCollectedResponses.push({...currentTrialResponses}); 
                }
                
                if (currentTaskMode === 'tutorial') {
                    showReadyScreen();
                } else if (currentTaskMode === 'test') {
                    alert(`Test complete for ${PARAMETERS[currentParameterKey].name.en}`);
                    showDiv(parameterSelectorDiv);
                } else {
                    // This was a main trial. Just load the next one.
                    currentGlobalTrialIndex++;
                    if (currentGlobalTrialIndex < currentSessionTrials.length) {
                        showConditionInstructions(currentSessionTrials[currentGlobalTrialIndex]);
                    } else {
                        displayFullResults();
                    }
                }
            }
        }
        
        // REPLACE this function
        // This is your working function with the one necessary line added.
        function setupCoarseStepVim() { 
            clearAllFocus();
            const paramName = currentParameterConfig.name[currentLanguage];
            currentParamDisplay.textContent = paramName;
            coarseParamNameStrong.textContent = currentParameterConfig.parameter_specific_instruction[currentLanguage]; 
            fineTuneParamNameStrong.textContent = currentParameterConfig.parameter_specific_instruction[currentLanguage];
            coarseButtons.forEach(button => {
                const levelKey = button.dataset.levelKey;
                button.dataset.level = currentParameterConfig.coarse[levelKey];
            });

            // Show/hide controls in RIGHT panel
            coarseStepDiv.classList.remove('hidden');
            fineTuneStepDiv.classList.add('hidden');
            confidenceStepDiv.classList.add('hidden'); // Also hide confidence step

            // --- THIS IS THE FIX ---
            // Clear highlighting from BOTH sets of buttons.
            likertButtons.forEach(btn => btn.classList.remove('selected'));
            coarseButtons.forEach(btn => btn.classList.remove('selected')); // THIS IS THE NEW, ADDED LINE

            // Show/hide images in LEFT panel
            document.getElementById('coarseImageDisplay').classList.remove('hidden');
            document.getElementById('fineTuneImageDisplay').classList.add('hidden');

            // Hide ALL action buttons at the bottom initially for the coarse step
            backToCoarseBtn.classList.add('hidden');
            confirmSelectionBtn.classList.add('hidden');
            confirmConfidenceBtn.classList.add('hidden');
            
            // Reset preview
            coarsePreviewImg.src = ""; 
            if (coarseImageDisplayP) coarseImageDisplayP.classList.remove('hidden');
            setupCoarseStepFocus();
        }

        // REPLACE your existing setupFineTuneStepVim function with this one

        function setupFineTuneStepVim(coarseLevelValue) {
            clearAllFocus();
            currentCoarseSelectionLevel = coarseLevelValue;
            fineTuneParamNameStrong.textContent = currentParameterConfig.parameter_specific_instruction[currentLanguage]; 
            const totalParamLevels = currentParameterConfig.levels;
            
            // --- THIS LOGIC IS UNCHANGED ---
            // Determine the min and max levels for the slider range
            let minL, maxL;
            if (coarseLevelValue === PARAMETERS[currentParameterKey].coarse.low) {
                minL = 1;
                maxL = 7;
            } else if (coarseLevelValue === PARAMETERS[currentParameterKey].coarse.mid) {
                minL = 8;
                maxL = 14;
            } else { // High
                minL = 15;
                maxL = 21;
            }
            
            sliderToActualLevelMap = [];
            for (let i = minL; i <= maxL; i++) {
                sliderToActualLevelMap.push(i);
            }

            // --- THIS LOGIC IS NEW (FOR RANDOMIZATION) ---
            // Instead of centering on the coarse value, pick a random starting index for the slider.
            const randomSliderIndex = Math.floor(Math.random() * sliderToActualLevelMap.length); // Get a random index from 0 to length-1
            const initialSliderValue = randomSliderIndex + 1; // Slider values are 1-based

            // --- THIS LOGIC IS NOW UPDATED TO USE THE RANDOM VALUE ---
            fineTuneSlider.min = 1;
            fineTuneSlider.max = sliderToActualLevelMap.length;
            fineTuneSlider.value = initialSliderValue; // Set the slider to the random position

            updateFineTuneImageVim(fineTuneSlider.value);
            
            // --- THIS LOGIC IS UNCHANGED ---
            coarseStepDiv.classList.add('hidden');
            fineTuneStepDiv.classList.remove('hidden');
            document.getElementById('coarseImageDisplay').classList.add('hidden');
            document.getElementById('fineTuneImageDisplay').classList.remove('hidden');
            
            backToCoarseBtn.classList.remove('hidden');
            confirmSelectionBtn.classList.remove('hidden');
            
            fineTuneSlider.focus(); 
            currentFocusableElements = [fineTuneSlider, backToCoarseBtn, confirmSelectionBtn];
            updateKeyboardFocus(0); 
        }

        function updateFineTuneImageVim(sliderValStr) { 
            const sliderValue = parseInt(sliderValStr);
            const actualLevel = sliderToActualLevelMap[sliderValue - 1];
            if (actualLevel !== undefined && currentTrialData && currentParameterKey) { 
                fineTuneImg.src = getVariantImagePath(currentTrialData.base_image_id, currentParameterKey, actualLevel);
                fineTuneLevelDisplay.textContent = actualLevel;
            }
        }
       
        // --- Start/Setup Functions ---
        function populateParameterSelector() { 
            paramButtonsContainer.innerHTML = ''; 
            Object.keys(PARAMETERS).forEach(key => {
                const button = document.createElement('button');
                button.textContent = `${LANG_STRINGS[currentLanguage].testParamButton.split(' ')[0]} ${PARAMETERS[key].name[currentLanguage]}`;
                button.addEventListener('click', () => startParameterTest(key));
                paramButtonsContainer.appendChild(button);
            });
            setupParameterSelectorFocus(); 
        }

        // REPLACE this function
        function startParameterTest(paramKey) {  
            resetFullTaskState(); 
            currentTaskMode = 'test';
            currentParameterKey = paramKey; 
            currentParameterConfig = PARAMETERS[paramKey]; 
            currentTrialData = {
                trial_id: "TestRun",
                condition: "Parameter Test",
                base_image_id: IMAGE_DATA.length > 0 ? IMAGE_DATA[0].id : "image01"
            };
            // It now calls our single, unified function.
            beginVimRating();
        }

        // ADD THESE THREE NEW FUNCTIONS

        // function getUrlParameter(name) {
        //     name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
        //     var regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
        //     var results = regex.exec(location.search);
        //     return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
        // }

        // REPLACE your existing createTrialList function

        function createTrialList(set = 'A') {
            // This function now ONLY creates the 12 main experimental trials.
            const conditions = ["perceptual_recall", "episodic_recall", "scene_imagination"];
            const indoorImages = IMAGE_DATA.filter(img => img.type === 'indoor');
            const outdoorImages = IMAGE_DATA.filter(img => img.type === 'outdoor');
            
            const groupAssignments = {
                'A': [0, 1, 2], 'B': [1, 2, 0], 'C': [2, 0, 1]
            };
            const assignment = groupAssignments[set.toUpperCase()] || groupAssignments['A'];

            let mainTrials = [];
            let trialCounter = 1;

            conditions.forEach((condition, i) => {
                const groupIndex = assignment[i];
                const indoorGroup = indoorImages.slice(groupIndex * 2, groupIndex * 2 + 2);
                const outdoorGroup = outdoorImages.slice(groupIndex * 2, groupIndex * 2 + 2);

                [...indoorGroup, ...outdoorGroup].forEach(img => {
                    let instruction = (condition === 'perceptual_recall')
                        ? { en: "You will be shown an image for a few seconds...", es: "Se le mostrará una imagen por unos segundos..."}
                        : img.prompts[condition];

                    mainTrials.push({
                        trial_id: `main_${trialCounter++}`,
                        is_attention_check: false,
                        condition: condition,
                        base_image_id: img.id,
                        original_image_filename: img.filename,
                        condition_instruction: instruction
                    });
                });
            });
            return mainTrials;
        }

        // ADD THIS ENTIRE NEW BLOCK OF ONBOARDING LOGIC

        // --- Onboarding Flow Control ---

        // When user clicks "Continue" on welcome screen
        document.getElementById('startInstructionsBtn').addEventListener('click', () => {
            showDiv(howToScreen);
        });

        // When user clicks "Start Practice Round"
        document.getElementById('startTutorialBtn').addEventListener('click', () => {
            startTutorial();
        });

        // REPLACE this function
        function startTutorial() {
            currentTaskMode = 'tutorial';
            currentTrialData = {
                trial_id: "TutorialRun",
                condition: "Practice",
                base_image_id: "tutorial" 
            };
            // It now calls our single, unified function.
            beginVimRating();
        }

        // function showReadyScreen() {
        //     // This screen appears after the tutorial is complete
        //     const readyScreen = document.createElement('div');
        //     readyScreen.className = 'main-container';
        //     readyScreen.innerHTML = `
        //         <h2 data-lang-key="readyTitle">${LANG_STRINGS[currentLanguage].readyTitle}</h2>
        //         <p data-lang-key="readyText">${LANG_STRINGS[currentLanguage].readyText}</p>
        //         <button id="startExperimentBtn" data-lang-key="startExperimentButton">${LANG_STRINGS[currentLanguage].startExperimentButton}</button>
        //     `;
            
        //     // Temporarily replace the body content with this screen
        //     document.body.innerHTML = ''; // Clear everything
        //     document.body.appendChild(readyScreen);
            
        //     // The only button on this screen now starts the real task
        //     document.getElementById('startExperimentBtn').addEventListener('click', () => {
        //         // Reload the page to reset all states cleanly, then start the task
        //         // We add a URL parameter to skip the intro on the next load.
        //         window.location.replace(window.location.pathname + '?run=true');
        //     });
        // }

        // ADD THIS ENTIRE FUNCTION BACK INTO YOUR SCRIPT

        function showReadyScreen() {
            // This function now correctly uses the showDiv system.
            const readyScreenDiv = document.getElementById('readyScreen');
            
            // Populate the text content based on the current language
            readyScreenDiv.querySelector('[data-lang-key="readyTitle"]').textContent = LANG_STRINGS[currentLanguage].readyTitle;
            readyScreenDiv.querySelector('[data-lang-key="readyText"]').textContent = LANG_STRINGS[currentLanguage].readyText;
            readyScreenDiv.querySelector('[data-lang-key="startExperimentButton"]').textContent = LANG_STRINGS[currentLanguage].startExperimentButton;

            // Show the screen
            showDiv(readyScreenDiv);
        }
        
        // REPLACE this function
        function startActualTask() {
            resetFullTaskState(); 
            currentTaskMode = 'actual_task_full';
            sessionID = Date.now();
            const set = 'A'; // This can be changed later with getUrlParameter if needed

            // 1. Create the list of 12 main trials
            currentSessionTrials = createTrialList(set);

            // --- NEW ATTENTION CHECK LOGIC ---
            // 2. Randomly select 3 trials to insert an attention check into
            const attentionCheckCount = 3;
            let indices = Array.from(Array(currentSessionTrials.length).keys()); // [0, 1, 2, ..., 11]
            let shuffledIndices = shuffleArray(indices);
            let attentionCheckIndices = shuffledIndices.slice(0, attentionCheckCount); // Pick the first 3
            
            // 3. "Tag" those trials
            attentionCheckIndices.forEach(index => {
                currentSessionTrials[index].has_attention_check = true;
            });
            console.log("Trials with an attention check:", attentionCheckIndices);

            // 4. Shuffle the final list of 12 trials so their order is random
            currentSessionTrials = shuffleArray(currentSessionTrials);

            // Start the experiment
            currentGlobalTrialIndex = 0;
            allCollectedResponses = []; 
            showConditionInstructions(currentSessionTrials[0]);
        }   

        document.getElementById('startExperimentBtn').addEventListener('click', startActualTask);

        // REPLACE your existing displayFullResults function with this one

        function displayFullResults() {
            // --- This section is now conditional ---
            if (DEBUG_SHOW_RESULTS) {
                resultsListUl.innerHTML = ''; 
                allCollectedResponses.forEach(trialResp => {
                    const trialHeader = document.createElement('li');
                    trialHeader.innerHTML = `<strong>Trial ${trialResp.trial_id} (${trialResp.condition}, Image: ${trialResp.image_id})</strong>`;
                    resultsListUl.appendChild(trialHeader);

                    for (const paramKeyInResp in trialResp.parameter_responses) {
                        const listItem = document.createElement('li');
                        listItem.style.paddingLeft = "20px";
                        listItem.textContent = `${PARAMETERS[paramKeyInResp].name[currentLanguage]}: Level ${trialResp.parameter_responses[paramKeyInResp]}`;
                        resultsListUl.appendChild(listItem);
                    }
                    resultsListUl.appendChild(document.createElement('hr')); 
                });
            } else {
                // If not debugging, ensure the list and title are hidden
                resultsListUl.style.display = 'none';
                document.querySelector('[data-lang-key="resultsTitle"]').style.display = 'none';
            }
            
            showDiv(resultsDisplayDiv);
            console.log("All Collected Responses:", JSON.stringify({ sessionID, results: allCollectedResponses }, null, 2));

            sendDataToGoogleSheet();
        }

        // --- NEW ---
        function downloadResults() {
            if (!sessionID || allCollectedResponses.length === 0) {
                alert("No data to download.");
                return;
            }

            // 1. Structure the data with the session ID
            const dataToDownload = {
                sessionID: sessionID,
                results: allCollectedResponses
            };

            // 2. Convert the data object to a JSON string
            const jsonString = JSON.stringify(dataToDownload, null, 2);

            // 3. Create a Blob from the JSON string
            const blob = new Blob([jsonString], { type: "application/json" });

            // 4. Create a temporary URL for the Blob
            const url = URL.createObjectURL(blob);

            // 5. Create a temporary anchor element to trigger the download
            const a = document.createElement('a');
            a.href = url;
            a.download = `VIM_results_session_${sessionID}.json`; // Set the filename
            document.body.appendChild(a); // Append to body to ensure it's clickable
            a.click(); // Programmatically click the link

            // 6. Clean up by removing the temporary anchor and URL
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Add this entire new function to your script

        // REPLACE your existing sendDataToGoogleSheet function with this one:

        async function sendDataToGoogleSheet() {
            if (!sessionID || allCollectedResponses.length === 0) {
                // If there's no data, just show the button immediately.
                backToMenuFromResultsBtn.classList.remove('hidden');
                return; 
            }

            saveStatus.textContent = LANG_STRINGS[currentLanguage].resultsTitle === "Trial Results" ? "Saving data..." : "Guardando datos...";
            
            try {
                const dataToPost = {
                    sessionID: sessionID,
                    results: allCollectedResponses
                };

                await fetch(GOOGLE_SCRIPT_URL, {
                    method: 'POST',
                    mode: 'no-cors',
                    cache: 'no-cache',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    redirect: 'follow',
                    body: JSON.stringify(dataToPost)
                });

                saveStatus.textContent = LANG_STRINGS[currentLanguage].resultsTitle === "Trial Results" ? "Data saved successfully. Thank you!" : "Datos guardados con éxito. ¡Gracias!";
                saveStatus.style.color = 'green';
                console.log("Data submission successful (assumed).");

            } catch (error) {
                saveStatus.textContent = LANG_STRINGS[currentLanguage].resultsTitle === "Trial Results" ? "Error: Could not save data. Please use the download button." : "Error: No se pudieron guardar los datos. Por favor, use el botón de descarga.";
                saveStatus.style.color = 'red';
                console.error("Error sending data to Google Sheet:", error);
            } finally {
                // --- THIS IS THE NEW PART ---
                // This code will run after the 'try' or 'catch' block finishes.
                // It ensures the user always gets a way to leave the screen.
                backToMenuFromResultsBtn.classList.remove('hidden');
            }
        }

        // --- EVENT LISTENERS ---
        // REPLACE this entire block
        document.addEventListener('DOMContentLoaded', () => {
            resetFullTaskState(); 
            setLanguage('en'); 
            showDiv(mainMenuDiv);
            if(isTouchDevice) document.body.classList.add('touch-device');
        });

        // Language Buttons
        document.querySelectorAll('#languageSelector button').forEach(button => {
            button.addEventListener('click', () => setLanguage(button.dataset.lang));
        });

        // Main Menu Buttons
        document.getElementById('testParameterBtn').addEventListener('click', () => {
            resetFullTaskState(); 
            populateParameterSelector();
            showDiv(parameterSelectorDiv);
        });
        
        document.getElementById('startActualTaskBtn').addEventListener('click', () => {
            // Now, this button simply shows the first welcome screen
            showDiv(welcomeScreen);
        });
        
        // Back Buttons
        backToMenuFromTestSelectBtn.addEventListener('click', () => { resetFullTaskState(); showDiv(mainMenuDiv); });
        backToMenuFromTaskBtn.addEventListener('click', () => {
            let confirmExit = currentTaskMode === 'test' ? true : confirm(LANG_STRINGS[currentLanguage].exitConfirmMessage);
            if (confirmExit) {
                resetFullTaskState();
                showDiv(mainMenuDiv);
            }
        }); 
        backToMenuFromResultsBtn.addEventListener('click', () => { resetFullTaskState(); showDiv(mainMenuDiv); });

        // --- NEW --- Download Button
        downloadResultsBtn.addEventListener('click', downloadResults);

        // REPLACE this entire block to make it more robust

        coarseButtons.forEach(button => {
            button.addEventListener('mouseover', () => {
                if (!currentParameterConfig || coarseStepDiv.classList.contains('hidden') || !currentTrialData) return;
                
                // This is the working preview logic
                const level = parseInt(button.dataset.level);
                coarsePreviewImg.src = getVariantImagePath(currentTrialData.base_image_id, currentParameterKey, level);
                
                // Safety check before using the variable
                if(coarseImageDisplayP) coarseImageDisplayP.classList.add('hidden');
            });
            button.addEventListener('click', () => {
                if (!currentParameterConfig) return;
                setupFineTuneStepVim(parseInt(button.dataset.level)); 
            });
        });
        
        // ... (The rest of the JS code for keyboard handling, etc., remains unchanged) ...
        // REPLACE this event listener block
        document.addEventListener('keydown', (event) => {
            if (document.activeElement.tagName === 'INPUT' && document.activeElement.type !== 'range') return;
            
            if (event.key === "Escape") {
                event.preventDefault();
                const visibleBackButton = document.querySelector('.main-container:not(.hidden) .back-button, .split-container:not(.hidden) .back-button');
                if (visibleBackButton) visibleBackButton.click();
                return;
            }

            // Route to specific handlers based on which screen is active
            if (!welcomeScreen.classList.contains('hidden') && event.key === "Enter") {
                event.preventDefault(); document.getElementById('startInstructionsBtn').click();
            } else if (!howToScreen.classList.contains('hidden') && event.key === "Enter") {
                event.preventDefault(); document.getElementById('startTutorialBtn').click();
            } else if (!document.getElementById('readyScreen').classList.contains('hidden') && event.key === "Enter") {
                event.preventDefault(); document.getElementById('startExperimentBtn').click();
            } else if (!mainMenuDiv.classList.contains('hidden')) {
                handleMainMenuKeys(event);
            } else if (!parameterSelectorDiv.classList.contains('hidden')) {
                handleParameterSelectorKeys(event);
            } else if (!conditionInstructionScreenDiv.classList.contains('hidden') && event.key === "Enter") {
                event.preventDefault(); startTrialFromInstructionsBtn.click();
            } else if (!preVimScreenContainerDiv.classList.contains('hidden') && !holdImageInstructionScreenDiv.classList.contains('hidden') && event.key === "Enter") {
                event.preventDefault(); 
                // It should now call beginVimRating(), just like the mouse click does.
                beginVimRating(); 
            } else if (!vimTaskInterfaceDiv.classList.contains('hidden')) {
                handleVimTaskInterfaceKeys(event);
            }
        });
        
        fineTuneSlider.addEventListener('input', (event) => { 
            if (currentTrialData && currentParameterKey) updateFineTuneImageVim(event.target.value); 
        });

        backToCoarseBtn.addEventListener('click', setupCoarseStepVim); 

        confirmSelectionBtn.addEventListener('click', () => {  
            if (!currentTrialData || !currentParameterKey) {
                console.error("Confirm button clicked with no trial/param context.");
                return;
            }
            // Store the fine-tuned level
            const currentSliderValue = parseInt(fineTuneSlider.value);
            const finalLevel = sliderToActualLevelMap[currentSliderValue - 1];
            
            if (!currentTrialResponses.parameter_responses) {
                currentTrialResponses.parameter_responses = {};
            }
            // We now store the response temporarily in a sub-object
            currentTrialResponses.parameter_responses[currentParameterKey] = {
                level: finalLevel
            };
            
            // Now, transition to the confidence rating step
            showConfidenceStep();
        });

        // ADD this new function to your script

        // REPLACE this function
        function showConfidenceStep() {
            clearAllFocus();
            // Hide the fine-tune UI elements
            fineTuneStepDiv.classList.add('hidden');
            // --- THIS IS THE FIX ---
            // Hide the individual buttons from the previous step
            backToCoarseBtn.classList.add('hidden');
            confirmSelectionBtn.classList.add('hidden');

            // Show the confidence UI elements
            confidenceStepDiv.classList.remove('hidden');
            confirmConfidenceBtn.classList.remove('hidden'); 
            confirmConfidenceBtn.disabled = true; 

            // Reset previous selection
            currentConfidenceSelection = null;
            likertButtons.forEach(btn => btn.classList.remove('selected'));

            // Set up keyboard focus
            currentFocusableElements = Array.from(likertButtons).concat(confirmConfidenceBtn);
            updateKeyboardFocus(3); // Start focus on button '4'
        }

        // ADD this new click handler to your script

        // REPLACE this entire event listener block

        confirmConfidenceBtn.addEventListener('click', () => {
            if (currentConfidenceSelection === null) return;

            // 1. Save the confidence rating to our data object
            if (currentTrialResponses.parameter_responses[currentParameterKey]) {
                currentTrialResponses.parameter_responses[currentParameterKey].confidence = currentConfidenceSelection;
            }

            // 2. Increment the parameter index
            currentParameterIndexInTask++;
            
            // 3. Let the main logic function decide what to do next
            loadNextParameterInVim();
        });

        // ADD this new event listener block for the Likert scale

        likertButtons.forEach(button => {
            button.addEventListener('click', () => {
                // Remove 'selected' from all buttons
                likertButtons.forEach(btn => btn.classList.remove('selected'));
                // Add 'selected' to the clicked button
                button.classList.add('selected');
                // Store the value
                currentConfidenceSelection = parseInt(button.dataset.value);
                // Enable the confirm button
                confirmConfidenceBtn.disabled = false;
                
                // Update keyboard focus to the clicked button
                const buttonIndex = Array.from(likertButtons).indexOf(button);
                if (buttonIndex !== -1) {
                    updateKeyboardFocus(buttonIndex);
                }
            });
        });

        function handleMainMenuKeys(event) {
            if (currentFocusableElements.length === 0) return;
            let handled = false;
            switch (event.key) {
                case "ArrowUp": case "ArrowDown":
                    updateKeyboardFocus(currentFocusedIndex === 0 ? 1 : 0);
                    handled = true;
                    break;
                case "Enter":
                    if (currentFocusedIndex >= 0) currentFocusableElements[currentFocusedIndex].click();
                    handled = true;
                    break;
            }
            if (handled) event.preventDefault();
        }

        function handleParameterSelectorKeys(event) {
            if (currentFocusableElements.length === 0) return;
            let handled = false;
            switch (event.key) {
                case "ArrowUp":
                    updateKeyboardFocus(currentFocusedIndex > 0 ? currentFocusedIndex - 1 : currentFocusableElements.length - 1);
                    handled = true;
                    break;
                case "ArrowDown":
                    updateKeyboardFocus(currentFocusedIndex < currentFocusableElements.length - 1 ? currentFocusedIndex + 1 : 0);
                    handled = true;
                    break;
                case "Enter":
                    if (currentFocusedIndex >= 0) currentFocusableElements[currentFocusedIndex].click();
                    handled = true;
                    break;
                case "Backspace": 
                    backToMenuFromTestSelectBtn.click();
                    handled = true;
                    break;
            }
            if (handled) event.preventDefault();
        }

        // REPLACE the existing handleVimTaskInterfaceKeys function with this one:
        function handleVimTaskInterfaceKeys(event) {
            let handled = false;
            // Logic for Coarse Selection Step
            if (!coarseStepDiv.classList.contains('hidden')) {
                // ... (This part remains exactly the same as your working version) ...
                if (!currentFocusableElements || currentFocusableElements.length === 0) return;
                let newFocusIndex = currentFocusedIndex;
                let arrowPressed = false;
                if (event.key === "ArrowLeft") { newFocusIndex = currentFocusedIndex > 0 ? currentFocusedIndex - 1 : currentFocusableElements.length - 1; arrowPressed = true; handled = true; } 
                else if (event.key === "ArrowRight") { newFocusIndex = currentFocusedIndex < currentFocusableElements.length - 1 ? currentFocusedIndex + 1 : 0; arrowPressed = true; handled = true; }
                if (arrowPressed) {
                    updateKeyboardFocus(newFocusIndex); 
                    const focusedButton = currentFocusableElements[currentFocusedIndex]; 
                    if (focusedButton) {
                        const level = parseInt(focusedButton.dataset.level);
                        if (!isNaN(level) && currentTrialData && currentParameterKey) {
                            coarsePreviewImg.src = getVariantImagePath(currentTrialData.base_image_id, currentParameterKey, level);
                            if (coarseImageDisplayP) coarseImageDisplayP.classList.add('hidden');
                        }
                    }
                } else if (event.key === "Enter") { 
                    if (currentFocusedIndex >= 0 && currentFocusableElements[currentFocusedIndex]) {
                        currentFocusableElements[currentFocusedIndex].click(); 
                        handled = true;
                    }
                }
                if (handled) event.preventDefault();
                return;
            } 
            // Logic for Fine-Tuning Step
            else if (!fineTuneStepDiv.classList.contains('hidden')) {
                // ... (This part remains exactly the same as your working version) ...
                const sliderStep = 1; 
                const sliderIsActiveFocus = document.activeElement === fineTuneSlider;
                switch (event.key) {
                    case "ArrowLeft": if (sliderIsActiveFocus) { fineTuneSlider.value = parseInt(fineTuneSlider.value) - sliderStep; fineTuneSlider.dispatchEvent(new Event('input')); handled = true; } break;
                    case "ArrowRight": if (sliderIsActiveFocus) { fineTuneSlider.value = parseInt(fineTuneSlider.value) + sliderStep; fineTuneSlider.dispatchEvent(new Event('input')); handled = true; } break;
                    case "Enter": confirmSelectionBtn.click(); handled = true; break;
                    case "Backspace": backToCoarseBtn.click(); handled = true; break;
                }
                if (handled) event.preventDefault();
            }
            // --- NEW LOGIC for Confidence Step ---
            else if (!confidenceStepDiv.classList.contains('hidden')) {
                let newFocusIndex = currentFocusedIndex;
                if (event.key === "ArrowLeft") {
                    if (currentFocusedIndex > 0) newFocusIndex = currentFocusedIndex - 1;
                    handled = true;
                } else if (event.key === "ArrowRight") {
                    if (currentFocusedIndex < currentFocusableElements.length - 1) newFocusIndex = currentFocusedIndex + 1;
                    handled = true;
                } else if (event.key === "Enter") {
                    if (currentFocusedIndex >= 0) {
                        currentFocusableElements[currentFocusedIndex].click(); // Select the button
                        if (!confirmConfidenceBtn.disabled) {
                            confirmConfidenceBtn.click(); // If a selection was made, also confirm
                        }
                    }
                    handled = true;
                }
                if (newFocusIndex !== currentFocusedIndex) {
                    updateKeyboardFocus(newFocusIndex);
                }
                if (handled) event.preventDefault();
            }
        }

    </script>
</body>
</html>